var x5 = Object.defineProperty;
var _5 = (n, e, t) => e in n ? x5(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t;
var Hn = (n, e, t) => _5(n, typeof e != "symbol" ? e + "" : e, t);
import {r as N, g as y5, a as S5, c as M5, b as w5, d as i1, u as iv, e as Wo, D as b5, N as n3, s as vh, f as i3, m as Uy, h as E5, k as C5, l as dr, n as Fy, j as T, O as jo, X as T5, R as ky, o as r3, p as A5, q as rv, v as qf, w as wu, x as s3, y as R5, z as o3, _ as Yf, A as P5, B as fn} from "./index-BdDJSQ0C.js";
import {s as de, r as on, Q as I5, m as L5, c as N5, g as O5, R as D5, a as gp, B as r1} from "./state-DUgjr4qF.js";
import {MiscService as U5, TasksService as vp, DaoService as a3} from "./index-B_S8I6Qm.js";
function F5() {
    if (console && console.warn) {
        for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
            e[t] = arguments[t];
        Lo(e[0]) && (e[0] = `react-i18next:: ${e[0]}`),
        console.warn(...e)
    }
}
const By = {};
function s1() {
    for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
    Lo(e[0]) && By[e[0]] || (Lo(e[0]) && (By[e[0]] = new Date),
    F5(...e))
}
const l3 = (n, e) => () => {
    if (n.isInitialized)
        e();
    else {
        const t = () => {
            setTimeout( () => {
                n.off("initialized", t)
            }
            , 0),
            e()
        }
        ;
        n.on("initialized", t)
    }
}
  , zy = (n, e, t) => {
    n.loadNamespaces(e, l3(n, t))
}
  , Vy = (n, e, t, i) => {
    Lo(t) && (t = [t]),
    t.forEach(r => {
        n.options.ns.indexOf(r) < 0 && n.options.ns.push(r)
    }
    ),
    n.loadLanguages(e, l3(n, i))
}
  , k5 = function(n, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = e.languages[0]
      , r = e.options ? e.options.fallbackLng : !1
      , s = e.languages[e.languages.length - 1];
    if (i.toLowerCase() === "cimode")
        return !0;
    const o = (l, u) => {
        const f = e.services.backendConnector.state[`${l}|${u}`];
        return f === -1 || f === 2
    }
    ;
    return t.bindI18n && t.bindI18n.indexOf("languageChanging") > -1 && e.services.backendConnector.backend && e.isLanguageChangingTo && !o(e.isLanguageChangingTo, n) ? !1 : !!(e.hasResourceBundle(i, n) || !e.services.backendConnector.backend || e.options.resources && !e.options.partialBundledLanguages || o(i, n) && (!r || o(s, n)))
}
  , B5 = function(n, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return !e.languages || !e.languages.length ? (s1("i18n.languages were undefined or empty", e.languages),
    !0) : e.options.ignoreJSONStructure !== void 0 ? e.hasLoadedNamespace(n, {
        lng: t.lng,
        precheck: (r, s) => {
            if (t.bindI18n && t.bindI18n.indexOf("languageChanging") > -1 && r.services.backendConnector.backend && r.isLanguageChangingTo && !s(r.isLanguageChangingTo, n))
                return !1
        }
    }) : k5(n, e, t)
}
  , Lo = n => typeof n == "string"
  , z5 = n => typeof n == "object" && n !== null
  , V5 = N.createContext();
class H5 {
    constructor() {
        Hn(this, "getUsedNamespaces", () => Object.keys(this.usedNamespaces));
        this.usedNamespaces = {}
    }
    addUsedNamespaces(e) {
        e.forEach(t => {
            this.usedNamespaces[t] || (this.usedNamespaces[t] = !0)
        }
        )
    }
}
const G5 = (n, e) => {
    const t = N.useRef();
    return N.useEffect( () => {
        t.current = n
    }
    , [n, e]),
    t.current
}
  , c3 = (n, e, t, i) => n.getFixedT(e, t, i)
  , W5 = (n, e, t, i) => N.useCallback(c3(n, e, t, i), [n, e, t, i])
  , hn = function(n) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {i18n: t} = e
      , {i18n: i, defaultNS: r} = N.useContext(V5) || {}
      , s = t || i || S5();
    if (s && !s.reportNamespaces && (s.reportNamespaces = new H5),
    !s) {
        s1("You will need to pass in an i18next instance by using initReactI18next");
        const E = (R, A) => Lo(A) ? A : z5(A) && Lo(A.defaultValue) ? A.defaultValue : Array.isArray(R) ? R[R.length - 1] : R
          , O = [E, {}, !1];
        return O.t = E,
        O.i18n = {},
        O.ready = !1,
        O
    }
    s.options.react && s.options.react.wait !== void 0 && s1("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    const o = {
        ...y5(),
        ...s.options.react,
        ...e
    }
      , {useSuspense: l, keyPrefix: u} = o;
    let f = r || s.options && s.options.defaultNS;
    f = Lo(f) ? [f] : f || ["translation"],
    s.reportNamespaces.addUsedNamespaces && s.reportNamespaces.addUsedNamespaces(f);
    const d = (s.isInitialized || s.initializedStoreOnce) && f.every(E => B5(E, s, o))
      , h = W5(s, e.lng || null, o.nsMode === "fallback" ? f : f[0], u)
      , m = () => h
      , g = () => c3(s, e.lng || null, o.nsMode === "fallback" ? f : f[0], u)
      , [x,S] = N.useState(m);
    let _ = f.join();
    e.lng && (_ = `${e.lng}${_}`);
    const v = G5(_)
      , M = N.useRef(!0);
    N.useEffect( () => {
        const {bindI18n: E, bindI18nStore: O} = o;
        M.current = !0,
        !d && !l && (e.lng ? Vy(s, e.lng, f, () => {
            M.current && S(g)
        }
        ) : zy(s, f, () => {
            M.current && S(g)
        }
        )),
        d && v && v !== _ && M.current && S(g);
        const R = () => {
            M.current && S(g)
        }
        ;
        return E && s && s.on(E, R),
        O && s && s.store.on(O, R),
        () => {
            M.current = !1,
            E && s && E.split(" ").forEach(A => s.off(A, R)),
            O && s && O.split(" ").forEach(A => s.store.off(A, R))
        }
    }
    , [s, _]),
    N.useEffect( () => {
        M.current && d && S(m)
    }
    , [s, u, d]);
    const w = [x, s, d];
    if (w.t = x,
    w.i18n = s,
    w.ready = d,
    d || !d && !l)
        return w;
    throw new Promise(E => {
        e.lng ? Vy(s, e.lng, f, () => E()) : zy(s, f, () => E())
    }
    )
};
/**
 * React Router DOM v6.26.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function xh() {
    return xh = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    xh.apply(this, arguments)
}
function u3(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
function j5(n) {
    return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}
function X5(n, e) {
    return n.button === 0 && (!e || e === "_self") && !j5(n)
}
const $5 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]
  , q5 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"]
  , Y5 = "6";
try {
    window.__reactRouterVersion = Y5
} catch {}
const Z5 = N.createContext({
    isTransitioning: !1
})
  , K5 = "startTransition"
  , Hy = i1[K5];
function J5(n) {
    let {basename: e, children: t, future: i, window: r} = n
      , s = N.useRef();
    s.current == null && (s.current = M5({
        window: r,
        v5Compat: !0
    }));
    let o = s.current
      , [l,u] = N.useState({
        action: o.action,
        location: o.location
    })
      , {v7_startTransition: f} = i || {}
      , d = N.useCallback(h => {
        f && Hy ? Hy( () => u(h)) : u(h)
    }
    , [u, f]);
    return N.useLayoutEffect( () => o.listen(d), [o, d]),
    N.createElement(w5, {
        basename: e,
        children: t,
        location: l.location,
        navigationType: l.action,
        navigator: o,
        future: i
    })
}
const Q5 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , eT = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , tT = N.forwardRef(function(e, t) {
    let {onClick: i, relative: r, reloadDocument: s, replace: o, state: l, target: u, to: f, preventScrollReset: d, unstable_viewTransition: h} = e, m = u3(e, $5), {basename: g} = N.useContext(n3), x, S = !1;
    if (typeof f == "string" && eT.test(f) && (x = f,
    Q5))
        try {
            let w = new URL(window.location.href)
              , E = f.startsWith("//") ? new URL(w.protocol + f) : new URL(f)
              , O = vh(E.pathname, g);
            E.origin === w.origin && O != null ? f = O + E.search + E.hash : S = !0
        } catch {}
    let _ = E5(f, {
        relative: r
    })
      , v = iT(f, {
        replace: o,
        state: l,
        target: u,
        preventScrollReset: d,
        relative: r,
        unstable_viewTransition: h
    });
    function M(w) {
        i && i(w),
        w.defaultPrevented || v(w)
    }
    return N.createElement("a", xh({}, m, {
        href: x || _,
        onClick: S || s ? i : M,
        ref: t,
        target: u
    }))
})
  , ih = N.forwardRef(function(e, t) {
    let {"aria-current": i="page", caseSensitive: r=!1, className: s="", end: o=!1, style: l, to: u, unstable_viewTransition: f, children: d} = e
      , h = u3(e, q5)
      , m = iv(u, {
        relative: h.relative
    })
      , g = Wo()
      , x = N.useContext(b5)
      , {navigator: S, basename: _} = N.useContext(n3)
      , v = x != null && rT(m) && f === !0
      , M = S.encodeLocation ? S.encodeLocation(m).pathname : m.pathname
      , w = g.pathname
      , E = x && x.navigation && x.navigation.location ? x.navigation.location.pathname : null;
    r || (w = w.toLowerCase(),
    E = E ? E.toLowerCase() : null,
    M = M.toLowerCase()),
    E && _ && (E = vh(E, _) || E);
    const O = M !== "/" && M.endsWith("/") ? M.length - 1 : M.length;
    let R = w === M || !o && w.startsWith(M) && w.charAt(O) === "/", A = E != null && (E === M || !o && E.startsWith(M) && E.charAt(M.length) === "/"), F = {
        isActive: R,
        isPending: A,
        isTransitioning: v
    }, I = R ? i : void 0, P;
    typeof s == "function" ? P = s(F) : P = [s, R ? "active" : null, A ? "pending" : null, v ? "transitioning" : null].filter(Boolean).join(" ");
    let D = typeof l == "function" ? l(F) : l;
    return N.createElement(tT, xh({}, h, {
        "aria-current": I,
        className: P,
        ref: t,
        style: D,
        to: u,
        unstable_viewTransition: f
    }), typeof d == "function" ? d(F) : d)
});
var o1;
(function(n) {
    n.UseScrollRestoration = "useScrollRestoration",
    n.UseSubmit = "useSubmit",
    n.UseSubmitFetcher = "useSubmitFetcher",
    n.UseFetcher = "useFetcher",
    n.useViewTransitionState = "useViewTransitionState"
}
)(o1 || (o1 = {}));
var Gy;
(function(n) {
    n.UseFetcher = "useFetcher",
    n.UseFetchers = "useFetchers",
    n.UseScrollRestoration = "useScrollRestoration"
}
)(Gy || (Gy = {}));
function nT(n) {
    let e = N.useContext(C5);
    return e || i3(!1),
    e
}
function iT(n, e) {
    let {target: t, replace: i, state: r, preventScrollReset: s, relative: o, unstable_viewTransition: l} = e === void 0 ? {} : e
      , u = dr()
      , f = Wo()
      , d = iv(n, {
        relative: o
    });
    return N.useCallback(h => {
        if (X5(h, t)) {
            h.preventDefault();
            let m = i !== void 0 ? i : Fy(f) === Fy(d);
            u(n, {
                replace: m,
                state: r,
                preventScrollReset: s,
                relative: o,
                unstable_viewTransition: l
            })
        }
    }
    , [f, u, d, i, r, t, n, s, o, l])
}
function rT(n, e) {
    e === void 0 && (e = {});
    let t = N.useContext(Z5);
    t == null && i3(!1);
    let {basename: i} = nT(o1.useViewTransitionState)
      , r = iv(n, {
        relative: e.relative
    });
    if (!t.isTransitioning)
        return !1;
    let s = vh(t.currentLocation.pathname, i) || t.currentLocation.pathname
      , o = vh(t.nextLocation.pathname, i) || t.nextLocation.pathname;
    return Uy(r.pathname, o) != null || Uy(r.pathname, s) != null
}
const f3 = () => {
    const [n,e] = N.useState([window.innerWidth, window.innerHeight]);
    return N.useEffect( () => {
        const t = () => {
            e([window.innerWidth, window.innerHeight])
        }
        ;
        return window.addEventListener("resize", t),
        () => {
            window.removeEventListener("resize", t)
        }
    }
    , []),
    n
}
  , sT = () => {
    const [n,e] = N.useState(!1)
      , [t,i] = N.useState(!1);
    return N.useEffect( () => on( () => de.isGlobalLoading, r => {
        r ? setTimeout( () => {
            e(!0),
            i(!0)
        }
        , 100) : (i(!1),
        setTimeout( () => {
            e(!1)
        }
        , 350))
    }
    , {
        fireImmediately: !0
    }), []),
    n ? T.jsxs("div", {
        className: "flex-1 absolute left-0 right-0 top-0 bottom-0 flex flex-col items-center justify-center z-[999999999999999]",
        style: {
            opacity: t ? 1 : 0,
            transition: "opacity .3s ease-in-out"
        },
        children: [T.jsx("div", {
            className: "absolute left-0 right-0 top-0 bottom-0 bg-black opacity-60 z-0"
        }), T.jsxs("div", {
            className: "relative  p-4 h-28 w-28 z-10 flex items-center justify-center",
            children: [T.jsx("div", {
                className: "absolute left-0 right-0 top-0 bottom-0 rounded-full  bg-[#313131] opacity-90 z-0"
            }), T.jsx(T5, {
                className: "h-16 w-16 z-20"
            })]
        })]
    }) : null
}
;
function oT() {
    console.debug("AppLayout");
    const {t: n} = hn()
      , {pathname: e} = Wo()
      , t = N.useMemo( () => e.startsWith("/dao") ? "dao" : e.startsWith("/tasks") ? "tasks" : e.startsWith("/boosts") ? "boosts" : e.startsWith("/new") ? "vibrate" : e.startsWith("/stats") ? "stats" : "home", [e])
      , [,i] = f3()
      , [r,s] = N.useState(de.isDaoAvailable);
    return N.useEffect( () => on( () => de.isDaoAvailable, o => {
        s(o)
    }
    , {
        fireImmediately: !0
    }), []),
    T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "flex flex-col justify-end w-[100vw] overflow-x-hidden absolute left-0 right-0 top-[100px] overflow-y-hidden",
            style: {
                height: `${i}px`
            },
            children: [T.jsx("main", {
                className: "flex-1 absolute left-0 right-0 top-0 bottom-0 flex flex-col items-stretch",
                style: {
                    backgroundColor: "#111111"
                },
                children: T.jsx(jo, {})
            }), T.jsxs("nav", {
                className: "flex flex-row justify-around items-stretch p-1 h-16 left-6 right-6 z-40 border rounded-xl poppins-semi-bold mb-6 ml-6 mr-6",
                style: {
                    backgroundColor: "#141414",
                    borderColor: "#2D2D2D",
                    color: "#818181",
                    display: "flex"
                },
                children: [T.jsxs(ih, {
                    to: "",
                    end: !0,
                    className: ["flex flex-col flex-1 items-center justify-end pb-1.5 pt-1.5 rounded-lg", t === "home" ? "active-nav-tab" : ""].join(" "),
                    children: [T.jsxs("svg", {
                        width: "32",
                        height: "32",
                        viewBox: "0 0 33 33",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: [T.jsx("path", {
                            opacity: "0.2",
                            d: "M22.75 7.5V25.5C22.75 26.0304 22.5393 26.5391 22.1642 26.9142C21.7891 27.2893 21.2804 27.5 20.75 27.5H12.75C12.2196 27.5 11.7109 27.2893 11.3358 26.9142C10.9607 26.5391 10.75 26.0304 10.75 25.5V7.5C10.75 6.96957 10.9607 6.46086 11.3358 6.08579C11.7109 5.71071 12.2196 5.5 12.75 5.5H20.75C21.2804 5.5 21.7891 5.71071 22.1642 6.08579C22.5393 6.46086 22.75 6.96957 22.75 7.5Z",
                            fill: "currentColor"
                        }), T.jsx("path", {
                            d: "M20.75 4.5H12.75C11.9544 4.5 11.1913 4.81607 10.6287 5.37868C10.0661 5.94129 9.75 6.70435 9.75 7.5V25.5C9.75 26.2956 10.0661 27.0587 10.6287 27.6213C11.1913 28.1839 11.9544 28.5 12.75 28.5H20.75C21.5456 28.5 22.3087 28.1839 22.8713 27.6213C23.4339 27.0587 23.75 26.2956 23.75 25.5V7.5C23.75 6.70435 23.4339 5.94129 22.8713 5.37868C22.3087 4.81607 21.5456 4.5 20.75 4.5ZM21.75 25.5C21.75 25.7652 21.6446 26.0196 21.4571 26.2071C21.2696 26.3946 21.0152 26.5 20.75 26.5H12.75C12.4848 26.5 12.2304 26.3946 12.0429 26.2071C11.8554 26.0196 11.75 25.7652 11.75 25.5V7.5C11.75 7.23478 11.8554 6.98043 12.0429 6.79289C12.2304 6.60536 12.4848 6.5 12.75 6.5H20.75C21.0152 6.5 21.2696 6.60536 21.4571 6.79289C21.6446 6.98043 21.75 7.23478 21.75 7.5V25.5ZM27.75 11.5V21.5C27.75 21.7652 27.6446 22.0196 27.4571 22.2071C27.2696 22.3946 27.0152 22.5 26.75 22.5C26.4848 22.5 26.2304 22.3946 26.0429 22.2071C25.8554 22.0196 25.75 21.7652 25.75 21.5V11.5C25.75 11.2348 25.8554 10.9804 26.0429 10.7929C26.2304 10.6054 26.4848 10.5 26.75 10.5C27.0152 10.5 27.2696 10.6054 27.4571 10.7929C27.6446 10.9804 27.75 11.2348 27.75 11.5ZM31.75 13.5V19.5C31.75 19.7652 31.6446 20.0196 31.4571 20.2071C31.2696 20.3946 31.0152 20.5 30.75 20.5C30.4848 20.5 30.2304 20.3946 30.0429 20.2071C29.8554 20.0196 29.75 19.7652 29.75 19.5V13.5C29.75 13.2348 29.8554 12.9804 30.0429 12.7929C30.2304 12.6054 30.4848 12.5 30.75 12.5C31.0152 12.5 31.2696 12.6054 31.4571 12.7929C31.6446 12.9804 31.75 13.2348 31.75 13.5ZM7.75 11.5V21.5C7.75 21.7652 7.64464 22.0196 7.45711 22.2071C7.26957 22.3946 7.01522 22.5 6.75 22.5C6.48478 22.5 6.23043 22.3946 6.04289 22.2071C5.85536 22.0196 5.75 21.7652 5.75 21.5V11.5C5.75 11.2348 5.85536 10.9804 6.04289 10.7929C6.23043 10.6054 6.48478 10.5 6.75 10.5C7.01522 10.5 7.26957 10.6054 7.45711 10.7929C7.64464 10.9804 7.75 11.2348 7.75 11.5ZM3.75 13.5V19.5C3.75 19.7652 3.64464 20.0196 3.45711 20.2071C3.26957 20.3946 3.01522 20.5 2.75 20.5C2.48478 20.5 2.23043 20.3946 2.04289 20.2071C1.85536 20.0196 1.75 19.7652 1.75 19.5V13.5C1.75 13.2348 1.85536 12.9804 2.04289 12.7929C2.23043 12.6054 2.48478 12.5 2.75 12.5C3.01522 12.5 3.26957 12.6054 3.45711 12.7929C3.64464 12.9804 3.75 13.2348 3.75 13.5Z",
                            fill: "currentColor"
                        })]
                    }), T.jsx("span", {
                        className: "mt-0.5",
                        style: {
                            fontSize: "0.625rem",
                            lineHeight: "0.625rem"
                        },
                        children: n("Vibrate")
                    })]
                }), T.jsxs(ih, {
                    to: "/dao",
                    className: ["flex flex-col flex-1 items-center justify-end pb-1.5 pt-1.5 rounded-lg", t === "dao" ? "active-nav-tab" : "", r ? "" : "disabled-nav-tab"].join(" "),
                    children: [T.jsxs("svg", {
                        width: "33",
                        height: "33",
                        viewBox: "0 0 33 33",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: [T.jsx("path", {
                            opacity: "0.2",
                            d: "M13.25 4.5V8.5C13.25 8.76522 13.1446 9.01957 12.9571 9.20711C12.7696 9.39464 12.5152 9.5 12.25 9.5H8.25C7.98478 9.5 7.73043 9.39464 7.54289 9.20711C7.35536 9.01957 7.25 8.76522 7.25 8.5V4.5C7.25 4.23478 7.35536 3.98043 7.54289 3.79289C7.73043 3.60536 7.98478 3.5 8.25 3.5H12.25C12.5152 3.5 12.7696 3.60536 12.9571 3.79289C13.1446 3.98043 13.25 4.23478 13.25 4.5ZM26.25 12.5H22.25C21.9848 12.5 21.7304 12.6054 21.5429 12.7929C21.3554 12.9804 21.25 13.2348 21.25 13.5V17.5C21.25 17.7652 21.3554 18.0196 21.5429 18.2071C21.7304 18.3946 21.9848 18.5 22.25 18.5H26.25C26.5152 18.5 26.7696 18.3946 26.9571 18.2071C27.1446 18.0196 27.25 17.7652 27.25 17.5V13.5C27.25 13.2348 27.1446 12.9804 26.9571 12.7929C26.7696 12.6054 26.5152 12.5 26.25 12.5ZM26.25 23.5H22.25C21.9848 23.5 21.7304 23.6054 21.5429 23.7929C21.3554 23.9804 21.25 24.2348 21.25 24.5V28.5C21.25 28.7652 21.3554 29.0196 21.5429 29.2071C21.7304 29.3946 21.9848 29.5 22.25 29.5H26.25C26.5152 29.5 26.7696 29.3946 26.9571 29.2071C27.1446 29.0196 27.25 28.7652 27.25 28.5V24.5C27.25 24.2348 27.1446 23.9804 26.9571 23.7929C26.7696 23.6054 26.5152 23.5 26.25 23.5Z",
                            fill: "currentColor"
                        }), T.jsx("path", {
                            d: "M22.25 19.5H26.25C26.7804 19.5 27.2891 19.2893 27.6642 18.9142C28.0393 18.5391 28.25 18.0304 28.25 17.5V13.5C28.25 12.9696 28.0393 12.4609 27.6642 12.0858C27.2891 11.7107 26.7804 11.5 26.25 11.5H22.25C21.7196 11.5 21.2109 11.7107 20.8358 12.0858C20.4607 12.4609 20.25 12.9696 20.25 13.5V14.5H11.25V10.5H12.25C12.7804 10.5 13.2891 10.2893 13.6642 9.91421C14.0393 9.53914 14.25 9.03043 14.25 8.5V4.5C14.25 3.96957 14.0393 3.46086 13.6642 3.08579C13.2891 2.71071 12.7804 2.5 12.25 2.5H8.25C7.71957 2.5 7.21086 2.71071 6.83579 3.08579C6.46071 3.46086 6.25 3.96957 6.25 4.5V8.5C6.25 9.03043 6.46071 9.53914 6.83579 9.91421C7.21086 10.2893 7.71957 10.5 8.25 10.5H9.25V24.5C9.25 25.2956 9.56607 26.0587 10.1287 26.6213C10.6913 27.1839 11.4544 27.5 12.25 27.5H20.25V28.5C20.25 29.0304 20.4607 29.5391 20.8358 29.9142C21.2109 30.2893 21.7196 30.5 22.25 30.5H26.25C26.7804 30.5 27.2891 30.2893 27.6642 29.9142C28.0393 29.5391 28.25 29.0304 28.25 28.5V24.5C28.25 23.9696 28.0393 23.4609 27.6642 23.0858C27.2891 22.7107 26.7804 22.5 26.25 22.5H22.25C21.7196 22.5 21.2109 22.7107 20.8358 23.0858C20.4607 23.4609 20.25 23.9696 20.25 24.5V25.5H12.25C11.9848 25.5 11.7304 25.3946 11.5429 25.2071C11.3554 25.0196 11.25 24.7652 11.25 24.5V16.5H20.25V17.5C20.25 18.0304 20.4607 18.5391 20.8358 18.9142C21.2109 19.2893 21.7196 19.5 22.25 19.5ZM8.25 4.5H12.25V8.5H8.25V4.5ZM22.25 24.5H26.25V28.5H22.25V24.5ZM22.25 13.5H26.25V17.5H22.25V13.5Z",
                            fill: "currentColor"
                        })]
                    }), T.jsx("span", {
                        className: "mt-1",
                        style: {
                            fontSize: "0.625rem",
                            lineHeight: "0.625rem"
                        },
                        children: n("DAO")
                    })]
                }), T.jsxs(ih, {
                    to: "/tasks",
                    className: ["flex flex-col flex-1 items-center justify-end pb-1.5 pt-1.5 rounded-lg", t === "tasks" ? "active-nav-tab" : "", r ? "" : "disabled-nav-tab"].join(" "),
                    children: [T.jsxs("svg", {
                        width: "33",
                        height: "33",
                        viewBox: "0 0 33 33",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: [T.jsx("path", {
                            opacity: "0.2",
                            d: "M26.45 20.4263L27.4587 24.5L23.75 22.3175L20.0413 24.5L21.05 20.4263L17.75 17.7013L22.0812 17.3675L23.75 13.5L25.4188 17.3675L29.75 17.7013L26.45 20.4263Z",
                            fill: "#818181"
                        }), T.jsx("path", {
                            d: "M4.75 8.5C4.75 8.23478 4.85536 7.98043 5.04289 7.79289C5.23043 7.60536 5.48478 7.5 5.75 7.5H27.75C28.0152 7.5 28.2696 7.60536 28.4571 7.79289C28.6446 7.98043 28.75 8.23478 28.75 8.5C28.75 8.76522 28.6446 9.01957 28.4571 9.20711C28.2696 9.39464 28.0152 9.5 27.75 9.5H5.75C5.48478 9.5 5.23043 9.39464 5.04289 9.20711C4.85536 9.01957 4.75 8.76522 4.75 8.5ZM5.75 17.5H12.75C13.0152 17.5 13.2696 17.3946 13.4571 17.2071C13.6446 17.0196 13.75 16.7652 13.75 16.5C13.75 16.2348 13.6446 15.9804 13.4571 15.7929C13.2696 15.6054 13.0152 15.5 12.75 15.5H5.75C5.48478 15.5 5.23043 15.6054 5.04289 15.7929C4.85536 15.9804 4.75 16.2348 4.75 16.5C4.75 16.7652 4.85536 17.0196 5.04289 17.2071C5.23043 17.3946 5.48478 17.5 5.75 17.5ZM14.75 23.5H5.75C5.48478 23.5 5.23043 23.6054 5.04289 23.7929C4.85536 23.9804 4.75 24.2348 4.75 24.5C4.75 24.7652 4.85536 25.0196 5.04289 25.2071C5.23043 25.3946 5.48478 25.5 5.75 25.5H14.75C15.0152 25.5 15.2696 25.3946 15.4571 25.2071C15.6446 25.0196 15.75 24.7652 15.75 24.5C15.75 24.2348 15.6446 23.9804 15.4571 23.7929C15.2696 23.6054 15.0152 23.5 14.75 23.5ZM30.3862 18.4725L27.5713 20.7962L28.4287 24.26C28.4758 24.451 28.4654 24.6516 28.399 24.8367C28.3326 25.0218 28.213 25.1832 28.0553 25.3008C27.8976 25.4183 27.7088 25.4867 27.5124 25.4975C27.316 25.5083 27.1208 25.4609 26.9513 25.3612L23.75 23.4775L20.5487 25.3612C20.3792 25.4609 20.184 25.5083 19.9876 25.4975C19.7912 25.4867 19.6024 25.4183 19.4447 25.3008C19.287 25.1832 19.1674 25.0218 19.101 24.8367C19.0346 24.6516 19.0242 24.451 19.0713 24.26L19.9275 20.7962L17.1138 18.4725C16.9603 18.3456 16.8483 18.1758 16.7919 17.9848C16.7356 17.7938 16.7376 17.5903 16.7976 17.4005C16.8576 17.2106 16.9729 17.043 17.1288 16.9191C17.2847 16.7952 17.474 16.7206 17.6725 16.705L21.4025 16.4163L22.8312 13.1038C22.9085 12.9241 23.0366 12.771 23.1999 12.6635C23.3632 12.5559 23.5545 12.4986 23.75 12.4986C23.9455 12.4986 24.1368 12.5559 24.3001 12.6635C24.4634 12.771 24.5915 12.9241 24.6688 13.1038L26.0975 16.4163L29.8275 16.705C30.026 16.7206 30.2153 16.7952 30.3712 16.9191C30.5271 17.043 30.6424 17.2106 30.7024 17.4005C30.7624 17.5903 30.7644 17.7938 30.7081 17.9848C30.6518 18.1758 30.5397 18.3456 30.3862 18.4725ZM27.2025 18.5075L25.3412 18.3638C25.1597 18.3498 24.9854 18.2866 24.8371 18.1808C24.6889 18.0751 24.5723 17.9309 24.5 17.7638L23.75 16.0238L23 17.7638C22.9277 17.9309 22.8111 18.0751 22.6629 18.1808C22.5146 18.2866 22.3403 18.3498 22.1588 18.3638L20.2975 18.5075L21.6863 19.655C21.8317 19.7749 21.9403 19.9334 21.9996 20.1123C22.0589 20.2912 22.0664 20.4833 22.0212 20.6663L21.5837 22.4312L23.2425 21.455C23.3963 21.3644 23.5715 21.3167 23.75 21.3167C23.9285 21.3167 24.1037 21.3644 24.2575 21.455L25.9163 22.4312L25.4788 20.6663C25.4336 20.4833 25.4411 20.2912 25.5004 20.1123C25.5597 19.9334 25.6683 19.7749 25.8137 19.655L27.2025 18.5075Z",
                            fill: "currentColor"
                        })]
                    }), T.jsx("span", {
                        className: "mt-1",
                        style: {
                            fontSize: "0.625rem",
                            lineHeight: "0.625rem"
                        },
                        children: n("Tasks")
                    })]
                })]
            }), T.jsx(sT, {}), T.jsx(I5, {
                theme: "dark",
                closeOnClick: !0,
                hideProgressBar: !0,
                bodyStyle: {
                    paddingTop: "0.1rem",
                    paddingBottom: "0.1rem",
                    fontSize: "0.825rem"
                },
                position: "bottom-right",
                newestOnTop: !0,
                toastStyle: {
                    width: "100%",
                    marginBottom: "1rem",
                    borderRadius: "0.5rem"
                },
                autoClose: 2e3,
                style: {
                    bottom: "7rem",
                    paddingRight: "1.5rem",
                    paddingLeft: "1.5rem"
                }
            })]
        })
    })
}
const aT = ({tabs: n, activePath: e}) => T.jsx("nav", {
    className: "flex flex-row justify-around items-stretch p-1 h-12 left-6 right-6 z-40 border rounded-xl poppins-semi-bold ml-16 mr-16 mt-6",
    style: {
        backgroundColor: "#141414",
        borderColor: "#2D2D2D",
        color: "#818181"
    },
    children: n.map(t => T.jsx(ih, {
        to: t.path,
        end: !0,
        className: ["flex flex-col flex-1 items-center justify-center pb-1.5 pt-1.5 rounded-lg", (e.includes("modal") ? e.includes(t.path) : t.path === e) ? "active-upper-tab" : ""].join(" "),
        children: T.jsx("span", {
            className: "text-base",
            children: t.title
        })
    }, t.path))
})
  , lT = () => {
    const {t: n} = hn()
      , {pathname: e} = Wo()
      , t = [{
        path: "/dao",
        title: n("DAO")
    }, {
        path: "/dao/invites",
        title: n("Invites")
    }];
    return T.jsxs(T.Fragment, {
        children: [T.jsx(aT, {
            tabs: t,
            activePath: e
        }), T.jsx(jo, {})]
    })
}
  , Co = ({url: n, fullName: e, className: t}) => {
    const i = N.useMemo( () => {
        if (!e)
            return;
        const r = e.split(" ");
        return `${r[0].charAt(0)}${r[r.length - 1].charAt(0)}`
    }
    , [e]);
    return n ? T.jsx("div", {
        className: `rounded-full flex justify-center items-center ${t}`,
        style: {
            backgroundColor: "#262626",
            backgroundImage: `url(${n})`,
            backgroundSize: "cover"
        }
    }) : i ? T.jsx("div", {
        className: `rounded-full flex justify-center items-center ${t || "text-2xl"} text-center text-white sora-bold`,
        style: {
            backgroundColor: "#4447f2",
            backgroundSize: "cover"
        },
        children: i
    }) : null
}
  , _h = ({onClick: n, children: e, className: t}) => T.jsx("button", {
    className: ["bg-[#4200FF] text-white p-3 text-lg sora-bold flex-row flex justify-center items-center gap-2 rounded-lg w-full", t].join(" "),
    onClick: n,
    children: e
});
function cT() {
    var f;
    const {t: n} = hn()
      , [e,t] = N.useState("")
      , [i,r] = N.useState([])
      , [s,o] = N.useState(0);
    N.useEffect( () => {
        U5.getMiscReferrers().then(d => {
            t(d.link),
            r(d.list),
            o(d.profit)
        }
        )
    }
    , []);
    const l = n("Hey! I'm using XDAO. I'm inviting you to join me on XDAO.")
      , u = N.useCallback( () => {
        location.href = `https://t.me/share/url?text=${l}&${new URLSearchParams({
            url: e
        }).toString()}`
    }
    , [e, l]);
    return T.jsxs("div", {
        className: "p-6 text-white flex-1 flex flex-col items-stretch",
        children: [T.jsx("div", {
            className: "text-xl font-medium mb-1 sora-bold text-center",
            style: {
                color: "#ffffff"
            },
            children: n("Invite Friends and earn more!")
        }), T.jsxs("div", {
            className: "text-xl font-medium mb-10 text-center",
            style: {
                color: "#C7C7C7"
            },
            children: [n("10% of earnings of your Invitees"), T.jsx("br", {}), n("will go to your profit")]
        }), T.jsx("div", {
            className: "text-sm font-medium mb-1 sora-bold",
            style: {
                color: "#C7C7C7"
            },
            children: n("Send your Invite link:")
        }), T.jsxs("div", {
            className: "mb-4 flex flex-row",
            children: [T.jsx("input", {
                type: "text",
                placeholder: "Enter your referral link",
                onChange: () => {}
                ,
                value: (f = de.profile) == null ? void 0 : f.referral_link,
                className: "w-full p-2 rounded-lg text-sm bg-[#1B1B1B] text-[#C7C7C7]"
            }), T.jsx("button", {
                className: "text-white px-4 py-2 rounded-lg ml-2 sora-bold text-xs",
                onClick: u,
                style: {
                    background: "#4200FF"
                },
                children: n("Send")
            })]
        }), T.jsx("div", {
            className: "text-sm font-medium mb-2  sora-bold",
            style: {
                color: "#C7C7C7"
            },
            children: n("Earned with Friends:")
        }), T.jsxs("div", {
            className: "text-xl font-medium mb-1 sora-bold flex flex-row items-center gap-2",
            style: {
                color: "#C7C7C7"
            },
            children: [T.jsx("div", {
                className: "coin-logo h-10 w-10"
            }), T.jsxs("div", {
                children: [s, " $DAO"]
            })]
        }), T.jsx("div", {
            className: "text-sm font-medium mb-2 sora-bold mt-6",
            style: {
                color: "#C7C7C7"
            },
            children: n("Your Invited Friends:")
        }), T.jsxs("div", {
            className: "flex-1 w-full flex items-stretch flex-col justify-between",
            children: [(i == null ? void 0 : i.length) === 0 ? T.jsx("div", {
                className: "w-full  flex-1 flex flex-col gap-4 overflow-hidden relative",
                children: T.jsx("div", {
                    className: "absolute top-0 left-0 right-0 bottom-0 flex flex-col pb-8 pt-6 justify-center items-center",
                    children: T.jsx("svg", {
                        width: "164",
                        height: "164",
                        viewBox: "0 0 164 164",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: T.jsx("path", {
                            d: "M82 0.75C65.9303 0.75 50.2214 5.51523 36.86 14.4431C23.4985 23.371 13.0844 36.0605 6.93482 50.907C0.785204 65.7535 -0.823817 82.0901 2.31123 97.8511C5.44628 113.612 13.1846 128.089 24.5476 139.452C35.9106 150.815 50.388 158.554 66.1489 161.689C81.9099 164.824 98.2466 163.215 113.093 157.065C127.94 150.916 140.629 140.502 149.557 127.14C158.485 113.779 163.25 98.0697 163.25 82C163.227 60.4581 154.66 39.8051 139.427 24.5727C124.195 9.3403 103.542 0.772749 82 0.75ZM82 150.75C68.4026 150.75 55.1105 146.718 43.8046 139.164C32.4987 131.609 23.6868 120.872 18.4833 108.309C13.2798 95.7471 11.9183 81.9237 14.571 68.5875C17.2238 55.2514 23.7716 43.0013 33.3864 33.3864C43.0013 23.7715 55.2514 17.2237 68.5876 14.571C81.9238 11.9183 95.7471 13.2798 108.31 18.4833C120.872 23.6868 131.609 32.4987 139.164 43.8045C146.718 55.1104 150.75 68.4025 150.75 82C150.729 100.227 143.479 117.702 130.591 130.591C117.702 143.479 100.227 150.729 82 150.75ZM130.172 77.5781C130.753 78.1588 131.213 78.8482 131.527 79.6069C131.842 80.3656 132.004 81.1788 132.004 82C132.004 82.8212 131.842 83.6344 131.527 84.3931C131.213 85.1518 130.753 85.8412 130.172 86.4219C129.591 87.0026 128.902 87.4632 128.143 87.7775C127.384 88.0917 126.571 88.2535 125.75 88.2535C124.929 88.2535 124.116 88.0917 123.357 87.7775C122.598 87.4632 121.909 87.0026 121.328 86.4219L113.25 78.3359L105.172 86.4219C103.999 87.5946 102.409 88.2535 100.75 88.2535C99.0915 88.2535 97.5009 87.5946 96.3282 86.4219C95.1554 85.2491 94.4966 83.6585 94.4966 82C94.4966 80.3415 95.1554 78.7509 96.3282 77.5781L104.414 69.5L96.3282 61.4219C95.1554 60.2491 94.4966 58.6585 94.4966 57C94.4966 55.3415 95.1554 53.7509 96.3282 52.5781C97.5009 51.4054 99.0915 50.7465 100.75 50.7465C102.409 50.7465 103.999 51.4054 105.172 52.5781L113.25 60.6641L121.328 52.5781C121.909 51.9974 122.598 51.5368 123.357 51.2225C124.116 50.9083 124.929 50.7465 125.75 50.7465C126.571 50.7465 127.384 50.9083 128.143 51.2225C128.902 51.5368 129.591 51.9974 130.172 52.5781C130.753 53.1588 131.213 53.8482 131.527 54.6069C131.842 55.3656 132.004 56.1788 132.004 57C132.004 57.8212 131.842 58.6344 131.527 59.3931C131.213 60.1518 130.753 60.8412 130.172 61.4219L122.086 69.5L130.172 77.5781ZM67.6719 61.4219L59.586 69.5L67.6719 77.5781C68.8447 78.7509 69.5035 80.3415 69.5035 82C69.5035 83.6585 68.8447 85.2491 67.6719 86.4219C66.4992 87.5946 64.9086 88.2535 63.25 88.2535C61.5915 88.2535 60.0009 87.5946 58.8282 86.4219L50.75 78.3359L42.6719 86.4219C41.4992 87.5946 39.9086 88.2535 38.25 88.2535C36.5915 88.2535 35.0009 87.5946 33.8282 86.4219C32.6554 85.2491 31.9966 83.6585 31.9966 82C31.9966 80.3415 32.6554 78.7509 33.8282 77.5781L41.9141 69.5L33.8282 61.4219C32.6554 60.2491 31.9966 58.6585 31.9966 57C31.9966 55.3415 32.6554 53.7509 33.8282 52.5781C35.0009 51.4054 36.5915 50.7465 38.25 50.7465C39.9086 50.7465 41.4992 51.4054 42.6719 52.5781L50.75 60.6641L58.8282 52.5781C60.0009 51.4054 61.5915 50.7465 63.25 50.7465C64.9086 50.7465 66.4992 51.4054 67.6719 52.5781C68.8447 53.7509 69.5035 55.3415 69.5035 57C69.5035 58.6585 68.8447 60.2491 67.6719 61.4219ZM91.375 122.625C91.375 124.479 90.8252 126.292 89.7951 127.833C88.7649 129.375 87.3007 130.577 85.5877 131.286C83.8746 131.996 81.9896 132.182 80.1711 131.82C78.3525 131.458 76.682 130.565 75.3709 129.254C74.0598 127.943 73.1669 126.273 72.8052 124.454C72.4434 122.635 72.6291 120.75 73.3387 119.037C74.0482 117.324 75.2499 115.86 76.7916 114.83C78.3333 113.8 80.1458 113.25 82 113.25C84.4864 113.25 86.871 114.238 88.6292 115.996C90.3873 117.754 91.375 120.139 91.375 122.625Z",
                            fill: "#868686"
                        })
                    })
                })
            }) : T.jsx("div", {
                className: "w-full  flex-1 flex flex-col gap-4 overflow-x-hidden overflow-y-scroll relative",
                children: T.jsxs("div", {
                    className: "absolute top-0 left-0 right-0 flex flex-col gap-4",
                    children: [i.map(d => T.jsxs("div", {
                        className: "flex flex-row rounded-md justify-between items-center p-3 text-sm",
                        style: {
                            color: "#C7C7C7",
                            background: "#1B1B1B"
                        },
                        children: [T.jsxs("div", {
                            className: "flex flex-row",
                            children: [T.jsx(Co, {
                                className: "h-6 w-6 text-sm",
                                url: (d == null ? void 0 : d.photo_url) || void 0,
                                fullName: d.name || void 0
                            }), T.jsx("div", {
                                className: "ml-4",
                                children: d.name
                            })]
                        }), T.jsx("div", {
                            children: d.coins
                        })]
                    }, d.id)), T.jsx("div", {
                        className: "h-1"
                    })]
                })
            }), T.jsxs(_h, {
                onClick: u,
                children: [T.jsx("svg", {
                    width: "21",
                    height: "22",
                    viewBox: "0 0 21 22",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: T.jsx("path", {
                        d: "M13.8751 4.25017C13.8751 3.9518 13.9936 3.66566 14.2046 3.45468C14.4155 3.2437 14.7017 3.12517 15.0001 3.12517H16.1251V2.00017C16.1251 1.7018 16.2436 1.41566 16.4546 1.20468C16.6655 0.9937 16.9517 0.875173 17.2501 0.875173C17.5484 0.875173 17.8346 0.9937 18.0455 1.20468C18.2565 1.41566 18.3751 1.7018 18.3751 2.00017V3.12517H19.5001C19.7984 3.12517 20.0846 3.2437 20.2955 3.45468C20.5065 3.66566 20.6251 3.9518 20.6251 4.25017C20.6251 4.54854 20.5065 4.83469 20.2955 5.04567C20.0846 5.25665 19.7984 5.37517 19.5001 5.37517H18.3751V6.50017C18.3751 6.79854 18.2565 7.08469 18.0455 7.29567C17.8346 7.50665 17.5484 7.62517 17.2501 7.62517C16.9517 7.62517 16.6655 7.50665 16.4546 7.29567C16.2436 7.08469 16.1251 6.79854 16.1251 6.50017V5.37517H15.0001C14.7017 5.37517 14.4155 5.25665 14.2046 5.04567C13.9936 4.83469 13.8751 4.54854 13.8751 4.25017ZM20.4854 9.31267C20.8407 11.427 20.5149 13.5995 19.5551 15.5166C18.5952 17.4337 17.051 18.9962 15.1454 19.9785C13.2397 20.9608 11.0712 21.3121 8.95284 20.9817C6.8345 20.6513 4.87596 19.6563 3.35996 18.1403C1.84397 16.6243 0.848942 14.6657 0.518538 12.5474C0.188135 10.4291 0.539446 8.26053 1.52176 6.35486C2.50407 4.44919 4.06655 2.90498 5.98365 1.94516C7.90074 0.985334 10.0733 0.659558 12.1876 1.01486C12.4818 1.06459 12.7443 1.22918 12.9172 1.47242C13.0901 1.71566 13.1593 2.01763 13.1096 2.31189C13.0599 2.60616 12.8953 2.86862 12.652 3.04153C12.4088 3.21445 12.1068 3.28365 11.8126 3.23392C11.3788 3.16152 10.9398 3.12515 10.5001 3.12517C9.02172 3.12417 7.573 3.53961 6.31986 4.3239C5.06672 5.10819 4.05984 6.2296 3.41457 7.55967C2.7693 8.88975 2.51173 10.3747 2.67138 11.8444C2.83103 13.3141 3.40143 14.7091 4.31724 15.8695C5.04642 14.9421 5.97584 14.1915 7.03599 13.6739C6.36034 12.9897 5.90213 12.121 5.71898 11.177C5.53584 10.2331 5.63595 9.25601 6.00671 8.36879C6.37748 7.48157 7.00235 6.72382 7.80271 6.19085C8.60307 5.65789 9.54317 5.37352 10.5047 5.37352C11.4663 5.37352 12.4064 5.65789 13.2068 6.19085C14.0071 6.72382 14.632 7.48157 15.0028 8.36879C15.3735 9.25601 15.4736 10.2331 15.2905 11.177C15.1074 12.121 14.6491 12.9897 13.9735 13.6739C15.0339 14.1912 15.9633 14.9418 16.6922 15.8695C17.7864 14.4827 18.3795 12.7667 18.3751 11.0002C18.375 10.5604 18.3386 10.1214 18.2663 9.68767C18.2166 9.39341 18.2858 9.09144 18.4587 8.8482C18.6316 8.60496 18.8941 8.44037 19.1883 8.39064C19.4826 8.34091 19.7846 8.41012 20.0278 8.58303C20.271 8.75595 20.4356 9.01841 20.4854 9.31267ZM10.5001 12.8752C11.0192 12.8752 11.5267 12.7212 11.9584 12.4328C12.3901 12.1443 12.7266 11.7344 12.9252 11.2547C13.1239 10.7751 13.1759 10.2473 13.0746 9.73806C12.9733 9.22886 12.7233 8.76113 12.3562 8.39402C11.9891 8.02691 11.5214 7.7769 11.0122 7.67561C10.503 7.57433 9.97516 7.62631 9.49551 7.82499C9.01585 8.02367 8.60588 8.36012 8.31744 8.7918C8.02901 9.22348 7.87505 9.731 7.87505 10.2502C7.87505 10.9464 8.15161 11.614 8.6439 12.1063C9.13618 12.5986 9.80386 12.8752 10.5001 12.8752ZM10.5001 18.8752C12.127 18.8763 13.7139 18.3707 15.0404 17.4286C14.5181 16.7145 13.8348 16.1337 13.0459 15.7333C12.257 15.3329 11.3847 15.1242 10.5001 15.1242C9.61535 15.1242 8.74313 15.3329 7.95423 15.7333C7.16533 16.1337 6.482 16.7145 5.95974 17.4286C7.28616 18.3707 8.87309 18.8763 10.5001 18.8752Z",
                        fill: "white"
                    })
                }), T.jsx("div", {
                    children: n("Invite Friends")
                })]
            })]
        }), T.jsx("div", {
            className: "h-6"
        }), T.jsx("div", {
            className: "h-16"
        })]
    })
}
const uT = ({children: n, onClick: e, className: t, disabled: i=!1, secondary: r=!1, round: s=!1}) => T.jsx("button", {
    className: `${i ? "bg-[#3C3C3C]" : r ? "bg-[#404040]" : "bg-[#4200FF]"} text-white whitespace-nowrap py-2 px-4 ${s ? "rounded-full" : "rounded-md"} text-base sora-bold ${t ?? ""}`,
    onClick: i ? void 0 : e,
    children: n
})
  , fT = ({users: n, avatarMaxCount: e=5}) => {
    const t = n.length <= e ? n : n.slice(0, e - 1)
      , i = t.length + (n.length > e ? 1 : 0);
    return T.jsx("div", {
        style: {
            width: `${(i - 1) * 1.25 + 2.5}rem`,
            overflowX: "hidden"
        },
        children: T.jsxs("div", {
            className: "flex max-content",
            children: [t.map( (r, s) => T.jsx("div", {
                className: "bg-[#131315] border border-[#2D2D2D] rounded-full flex shrink-0 relative items-center justify-center h-10 w-10",
                style: {
                    transform: `translateX(-${s * 50}%)`,
                    zIndex: 5 - s
                },
                children: T.jsx(Co, {
                    className: "h-6 w-6 text-sm",
                    url: (r == null ? void 0 : r.photo_url) || void 0,
                    fullName: r.full_name || void 0
                })
            }, `AvatarsRow${r.id}`)), n.length > e && T.jsx("div", {
                className: "bg-[#131315] border border-[#2D2D2D] rounded-full flex shrink-0 relative items-center justify-center h-10 w-10",
                style: {
                    transform: `translateX(-${t.length * 50}%)`,
                    zIndex: 5 - t.length
                },
                children: T.jsx("div", {
                    className: "h-6 w-6 text-2xl text-[#818181] text-center",
                    style: {
                        fontSize: "2rem",
                        transform: "translateY(-0.2rem)"
                    },
                    children: "+"
                })
            })]
        })
    })
}
  , dT = [{
    value: 1,
    symbol: ""
}, {
    value: 1e3,
    symbol: "K"
}, {
    value: 1e6,
    symbol: "M"
}, {
    value: 1e9,
    symbol: "G"
}, {
    value: 1e12,
    symbol: "T"
}, {
    value: 1e15,
    symbol: "P"
}, {
    value: 1e18,
    symbol: "E"
}].reverse();
function d3(n) {
    const e = /\.0+$|(\.[0-9]*[1-9])0+$/
      , t = dT.find(i => n >= i.value);
    return t ? (n / t.value).toFixed(0).replace(e, (i, r) => r || "").concat(t.symbol) : "0"
}
const hT = ({profit: n}) => T.jsxs(T.Fragment, {
    children: [T.jsx("div", {
        className: "coin-logo w-6 h-6"
    }), T.jsx("div", {
        style: {
            fontFeatureSettings: "tnum",
            fontVariantNumeric: "tabular-nums"
        },
        children: d3(n)
    }), "$DAO"]
});
if (!N.useState)
    throw new Error("mobx-react-lite requires React with Hooks support");
if (!L5)
    throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
function pT(n) {
    n()
}
function mT(n) {
    n || (n = pT),
    N5({
        reactionScheduler: n
    })
}
function gT(n) {
    return O5(n)
}
var vT = 1e4
  , xT = 1e4
  , _T = function() {
    function n(e) {
        var t = this;
        Object.defineProperty(this, "finalize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: e
        }),
        Object.defineProperty(this, "registrations", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: new Map
        }),
        Object.defineProperty(this, "sweepTimeout", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "sweep", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: function(i) {
                i === void 0 && (i = vT),
                clearTimeout(t.sweepTimeout),
                t.sweepTimeout = void 0;
                var r = Date.now();
                t.registrations.forEach(function(s, o) {
                    r - s.registeredAt >= i && (t.finalize(s.value),
                    t.registrations.delete(o))
                }),
                t.registrations.size > 0 && t.scheduleSweep()
            }
        }),
        Object.defineProperty(this, "finalizeAllImmediately", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: function() {
                t.sweep(0)
            }
        })
    }
    return Object.defineProperty(n.prototype, "register", {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: function(e, t, i) {
            this.registrations.set(i, {
                value: t,
                registeredAt: Date.now()
            }),
            this.scheduleSweep()
        }
    }),
    Object.defineProperty(n.prototype, "unregister", {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: function(e) {
            this.registrations.delete(e)
        }
    }),
    Object.defineProperty(n.prototype, "scheduleSweep", {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: function() {
            this.sweepTimeout === void 0 && (this.sweepTimeout = setTimeout(this.sweep, xT))
        }
    }),
    n
}()
  , yT = typeof FinalizationRegistry < "u" ? FinalizationRegistry : _T
  , a1 = new yT(function(n) {
    var e;
    (e = n.reaction) === null || e === void 0 || e.dispose(),
    n.reaction = null
}
)
  , h3 = {
    exports: {}
}
  , p3 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rl = N;
function ST(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var MT = typeof Object.is == "function" ? Object.is : ST
  , wT = rl.useState
  , bT = rl.useEffect
  , ET = rl.useLayoutEffect
  , CT = rl.useDebugValue;
function TT(n, e) {
    var t = e()
      , i = wT({
        inst: {
            value: t,
            getSnapshot: e
        }
    })
      , r = i[0].inst
      , s = i[1];
    return ET(function() {
        r.value = t,
        r.getSnapshot = e,
        D0(r) && s({
            inst: r
        })
    }, [n, t, e]),
    bT(function() {
        return D0(r) && s({
            inst: r
        }),
        n(function() {
            D0(r) && s({
                inst: r
            })
        })
    }, [n]),
    CT(t),
    t
}
function D0(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !MT(n, t)
    } catch {
        return !0
    }
}
function AT(n, e) {
    return e()
}
var RT = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? AT : TT;
p3.useSyncExternalStore = rl.useSyncExternalStore !== void 0 ? rl.useSyncExternalStore : RT;
h3.exports = p3;
var PT = h3.exports;
function Wy(n) {
    n.reaction = new D5("observer".concat(n.name),function() {
        var e;
        n.stateVersion = Symbol(),
        (e = n.onStoreChange) === null || e === void 0 || e.call(n)
    }
    )
}
function IT(n, e) {
    e === void 0 && (e = "observed");
    var t = ky.useRef(null);
    if (!t.current) {
        var i = {
            reaction: null,
            onStoreChange: null,
            stateVersion: Symbol(),
            name: e,
            subscribe: function(l) {
                return a1.unregister(i),
                i.onStoreChange = l,
                i.reaction || (Wy(i),
                i.stateVersion = Symbol()),
                function() {
                    var u;
                    i.onStoreChange = null,
                    (u = i.reaction) === null || u === void 0 || u.dispose(),
                    i.reaction = null
                }
            },
            getSnapshot: function() {
                return i.stateVersion
            }
        };
        t.current = i
    }
    var r = t.current;
    r.reaction || (Wy(r),
    a1.register(t, r, r)),
    ky.useDebugValue(r.reaction, gT),
    PT.useSyncExternalStore(r.subscribe, r.getSnapshot, r.getSnapshot);
    var s, o;
    if (r.reaction.track(function() {
        try {
            s = n()
        } catch (l) {
            o = l
        }
    }),
    o)
        throw o;
    return s
}
var U0, F0, m3 = typeof Symbol == "function" && Symbol.for, LT = (F0 = (U0 = Object.getOwnPropertyDescriptor(function() {}, "name")) === null || U0 === void 0 ? void 0 : U0.configurable) !== null && F0 !== void 0 ? F0 : !1, jy = m3 ? Symbol.for("react.forward_ref") : typeof N.forwardRef == "function" && N.forwardRef(function(n) {
    return null
}).$$typeof, Xy = m3 ? Symbol.for("react.memo") : typeof N.memo == "function" && N.memo(function(n) {
    return null
}).$$typeof;
function Pi(n, e) {
    var t;
    if (Xy && n.$$typeof === Xy)
        throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
    var i = (t = void 0) !== null && t !== void 0 ? t : !1
      , r = n
      , s = n.displayName || n.name;
    if (jy && n.$$typeof === jy && (i = !0,
    r = n.render,
    typeof r != "function"))
        throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
    var o = function(l, u) {
        return IT(function() {
            return r(l, u)
        }, s)
    };
    return o.displayName = n.displayName,
    LT && Object.defineProperty(o, "name", {
        value: n.name,
        writable: !0,
        configurable: !0
    }),
    n.contextTypes && (o.contextTypes = n.contextTypes),
    i && (o = N.forwardRef(o)),
    o = N.memo(o),
    OT(n, o),
    o
}
var NT = {
    $$typeof: !0,
    render: !0,
    compare: !0,
    type: !0,
    displayName: !0
};
function OT(n, e) {
    Object.keys(n).forEach(function(t) {
        NT[t] || Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
    })
}
var k0;
mT(r3.unstable_batchedUpdates);
k0 = a1.finalizeAllImmediately;
const DT = Pi( ({profit: n}) => {
    var i;
    const {t: e} = hn()
      , t = dr();
    return T.jsxs("div", {
        className: "bg-[#1B1B1B] rounded-lg p-4 text-white",
        children: [T.jsxs("div", {
            className: "flex flex-row text-white font-bold text-base gap-2 sora-bold items-center",
            children: [T.jsx("div", {
                children: e("Your DAO Profit:")
            }), T.jsx(hT, {
                profit: n
            })]
        }), T.jsxs("div", {
            className: "flex mt-3",
            children: [T.jsx(fT, {
                users: ((i = de.dao) == null ? void 0 : i.users) || []
            }), T.jsx(uT, {
                className: "ml-auto",
                secondary: !0,
                round: !0,
                onClick: () => t("/dao/modal/daosettings"),
                children: e("DAO Settings")
            })]
        })]
    })
}
)
  , UT = Pi( () => {
    const {t: n} = hn()
      , {dao: e} = de;
    N.useCallback( () => {
        de.setGlobalLoading(!0)
    }
    , []);
    const t = dr();
    return N.useCallback( () => {
        t("modal/create-syndicate")
    }
    , [t]),
    N.useCallback( () => {
        t("modal/join-syndicate")
    }
    , [t]),
    T.jsxs(T.Fragment, {
        children: [T.jsx(jo, {}), T.jsxs("div", {
            className: "p-6 overflow-y-scroll",
            children: [T.jsx("div", {
                className: "text-xl font-medium mb-1 sora-bold text-center text-white",
                style: {
                    color: "#ffffff"
                },
                children: n("Your DAO")
            }), T.jsx("div", {
                className: "text-xl font-medium mb-4 text-center text-[#C7C7C7]",
                children: n("Boost your earnings up to x3 by farming with friends as a DAO!")
            }), e != null && e.id ? T.jsx(DT, {
                profit: de.daoProfit
            }) : T.jsx(_h, {
                onClick: () => console.log("todo"),
                children: n("Create a DAO")
            }), T.jsx("div", {
                className: "h-8"
            }), T.jsx("div", {
                className: "bg-gradient-to-r from-[#4200FF] to-[#9E00FF] text-white py-2 px-4 text-xl sora-bold rounded-full mx-auto w-fit mb-4",
                children: n("Your Syndicate")
            }), T.jsx("div", {
                className: "text-xl poppins mb-4 text-center",
                style: {
                    color: "#C7C7C7"
                },
                children: n("Become a part of a Syndicate and get a constant x2 Boost!")
            }), T.jsx("div", {
                className: "text-white text-center text-xl sora-bold mt-6",
                children: "Coming soon..."
            }), T.jsx("div", {
                className: "h-24"
            })]
        })]
    })
}
);
function $y() {
    dr();
    const n = N.useCallback( () => {
        de.setGlobalLoading(!0)
    }
    , [])
      , e = N.useCallback( () => {
        de.setGlobalLoading(!0)
    }
    , [])
      , t = [{
        icon: "⚡️",
        name: "Zero energy",
        description: "Loose all your energy instantly.",
        onclick: n
    }, {
        icon: "🤪",
        name: "Looser Boost",
        description: "Loose your level and DAO.",
        onclick: e
    }]
      , {t: i} = hn();
    return T.jsxs("div", {
        className: "flex flex-col h-full p-6",
        children: [T.jsx("h1", {
            className: "text-2xl sora-bold text-left mb-6 text-white",
            children: "Boost Your Energy & Rewards"
        }), T.jsx("div", {
            className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4",
            children: t.map( (r, s) => T.jsxs("div", {
                className: "text-white rounded-lg p-4 shadow-md",
                style: {
                    backgroundColor: "#2d2d2d"
                },
                onClick: r.onclick,
                children: [T.jsxs("div", {
                    className: "flex-row flex justify-between",
                    children: [T.jsxs("div", {
                        className: "flex-row flex items-center poppins-semi-bold",
                        children: [T.jsx("div", {
                            className: "text-lg mb-2 mr-2",
                            children: r.icon
                        }), T.jsx("h2", {
                            className: "text-lg font-bold mb-2",
                            children: r.name
                        })]
                    }), T.jsx("div", {
                        className: "flex-row flex text-xl items-center poppins-semi-bold",
                        children: "∞"
                    })]
                }), T.jsx("p", {
                    className: "text-base text-white",
                    children: r.description
                }), T.jsxs("div", {
                    className: "flex-row flex justify-between items-center mt-2",
                    children: [T.jsx("div", {
                        className: "flex-row flex items-center poppins-semi-bold",
                        children: T.jsxs("div", {
                            className: "text-base font-bold sora-bold",
                            children: [i("Price: "), "0 $DAO"]
                        })
                    }), T.jsx("div", {
                        className: "flex-row flex text-xl items-center poppins-semi-bold",
                        children: T.jsx("button", {
                            className: "pt-2 pb-2 pr-4 pl-4 rounded-md bg-[#4200FF] text-white text-base",
                            children: "Get!"
                        })
                    })]
                })]
            }, s))
        })]
    })
}
class FT {
    constructor() {
        Hn(this, "tasks");
        Hn(this, "tasksCodes");
        Hn(this, "loading");
        Hn(this, "selectedTask");
        this.tasks = {},
        this.tasksCodes = [],
        this.selectedTask = "subscribeTelegram",
        this.loading = !1,
        gp(this)
    }
    async fetchTasks() {
        await vp.getTasksTasks().then(e => {
            const t = {};
            e.forEach(i => {
                t[i.code] = i
            }
            ),
            this.tasks = {
                ...t
            },
            console.log("tasks", this.tasks),
            this.tasksCodes = [...Object.keys(t)]
        }
        )
    }
    setSelectedTask(e) {
        this.selectedTask = e
    }
    get openedTask() {
        return this.tasks[this.selectedTask]
    }
    get isDailyTask() {
        return this.selectedTask === "daily"
    }
}
const sn = new FT
  , kT = Pi( () => {
    const {t: n} = hn()
      , e = dr();
    N.useEffect( () => {
        de.setGlobalLoading(!0),
        sn.fetchTasks().then( () => {
            de.setGlobalLoading(!1)
        }
        )
    }
    , []);
    const t = r => {
        de.setGlobalLoading(!0),
        vp.postTasksClaimUserTask({
            taskId: sn.tasks[r].id
        }).then( () => {
            sn.fetchTasks().then( () => {
                de.setGlobalLoading(!1)
            }
            )
        }
        )
    }
      , i = r => {
        sn.setSelectedTask(r),
        e(r === "daily" ? "modal/daily" : "modal")
    }
    ;
    return T.jsxs("div", {
        className: "flex flex-col absolute top-0 left-0 w-full h-full p-6 overflow-y-auto pb-16",
        children: [T.jsx("h1", {
            className: "text-2xl sora-bold text-left mb-6 text-white",
            children: n("Latest Tasks")
        }), T.jsxs("div", {
            className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4",
            children: [sn.tasksCodes.map( (r, s) => {
                var o, l, u, f, d;
                return T.jsxs("div", {
                    className: "text-white rounded-lg p-4 shadow-md",
                    style: {
                        backgroundColor: "#2d2d2d"
                    },
                    children: [T.jsxs("div", {
                        className: "flex-row flex justify-between",
                        children: [T.jsx("div", {
                            className: "flex-row flex items-center poppins-semi-bold",
                            children: T.jsx("h2", {
                                className: "text-lg font-bold mb-2",
                                children: (o = sn.tasks[r]) == null ? void 0 : o.name
                            })
                        }), T.jsx("div", {
                            className: "flex-row flex text-xl items-center poppins-semi-bold"
                        })]
                    }), T.jsxs("div", {
                        className: "flex-row flex justify-between items-center mt-2",
                        children: [T.jsx("div", {
                            className: "flex-row flex items-center poppins-semi-bold",
                            children: T.jsxs("div", {
                                className: "text-base ",
                                children: [T.jsx("span", {
                                    className: "text-[#A3A3A3]",
                                    children: n("Reward: ")
                                }), (l = sn.tasks[r]) != null && l.reward ? d3(sn.tasks[r].reward) : "∞", " ", "$DAO"]
                            })
                        }), T.jsx("div", {
                            className: "flex-row flex text-xl items-center poppins-semi-bold",
                            children: (u = sn.tasks[r]) != null && u.is_started ? (f = sn.tasks[r]) != null && f.is_completed ? (d = sn.tasks[r]) != null && d.is_claimed ? T.jsx("button", {
                                className: "pt-2 pb-2 pr-4 pl-4 rounded-md bg-[#4200FF] text-white text-base disabled:bg-[#3C3C3C]",
                                disabled: !0,
                                children: "Done"
                            }) : T.jsx("button", {
                                className: "pt-2 pb-2 pr-4 pl-4 rounded-md bg-[#4200FF] text-white text-base disabled:bg-[#3C3C3C]",
                                onClick: () => t(r),
                                children: "Claim"
                            }) : T.jsx("button", {
                                className: "pt-2 pb-2 pr-4 pl-4 rounded-md bg-[#4200FF] text-white text-base disabled:bg-[#3C3C3C]",
                                onClick: () => i(r),
                                children: "Verifying"
                            }) : T.jsx("button", {
                                className: "pt-2 pb-2 pr-4 pl-4 rounded-md bg-[#4200FF] text-white text-base disabled:bg-[#3C3C3C]",
                                onClick: () => i(r),
                                children: "Start"
                            })
                        })]
                    })]
                }, s)
            }
            ), T.jsx("div", {
                className: "bottom-0 left-0 w-full h-6"
            })]
        }), T.jsx(jo, {})]
    })
}
);
var BT = {}
  , sv = {}
  , ov = {}
  , zT = !1;
function VT(n) {
    if (n.sheet)
        return n.sheet;
    for (var e = 0; e < document.styleSheets.length; e++)
        if (document.styleSheets[e].ownerNode === n)
            return document.styleSheets[e]
}
function HT(n) {
    var e = document.createElement("style");
    return e.setAttribute("data-emotion", n.key),
    n.nonce !== void 0 && e.setAttribute("nonce", n.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
}
var GT = function() {
    function n(t) {
        var i = this;
        this._insertTag = function(r) {
            var s;
            i.tags.length === 0 ? i.insertionPoint ? s = i.insertionPoint.nextSibling : i.prepend ? s = i.container.firstChild : s = i.before : s = i.tags[i.tags.length - 1].nextSibling,
            i.container.insertBefore(r, s),
            i.tags.push(r)
        }
        ,
        this.isSpeedy = t.speedy === void 0 ? !zT : t.speedy,
        this.tags = [],
        this.ctr = 0,
        this.nonce = t.nonce,
        this.key = t.key,
        this.container = t.container,
        this.prepend = t.prepend,
        this.insertionPoint = t.insertionPoint,
        this.before = null
    }
    var e = n.prototype;
    return e.hydrate = function(i) {
        i.forEach(this._insertTag)
    }
    ,
    e.insert = function(i) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(HT(this));
        var r = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var s = VT(r);
            try {
                s.insertRule(i, s.cssRules.length)
            } catch {}
        } else
            r.appendChild(document.createTextNode(i));
        this.ctr++
    }
    ,
    e.flush = function() {
        this.tags.forEach(function(i) {
            var r;
            return (r = i.parentNode) == null ? void 0 : r.removeChild(i)
        }),
        this.tags = [],
        this.ctr = 0
    }
    ,
    n
}()
  , Xn = "-ms-"
  , yh = "-moz-"
  , Ut = "-webkit-"
  , g3 = "comm"
  , av = "rule"
  , lv = "decl"
  , WT = "@import"
  , v3 = "@keyframes"
  , jT = "@layer"
  , XT = Math.abs
  , xp = String.fromCharCode
  , $T = Object.assign;
function qT(n, e) {
    return Un(n, 0) ^ 45 ? (((e << 2 ^ Un(n, 0)) << 2 ^ Un(n, 1)) << 2 ^ Un(n, 2)) << 2 ^ Un(n, 3) : 0
}
function x3(n) {
    return n.trim()
}
function YT(n, e) {
    return (n = e.exec(n)) ? n[0] : n
}
function Ft(n, e, t) {
    return n.replace(e, t)
}
function l1(n, e) {
    return n.indexOf(e)
}
function Un(n, e) {
    return n.charCodeAt(e) | 0
}
function zc(n, e, t) {
    return n.slice(e, t)
}
function wr(n) {
    return n.length
}
function cv(n) {
    return n.length
}
function Zf(n, e) {
    return e.push(n),
    n
}
function ZT(n, e) {
    return n.map(e).join("")
}
var _p = 1
  , sl = 1
  , _3 = 0
  , gi = 0
  , _n = 0
  , _l = "";
function yp(n, e, t, i, r, s, o) {
    return {
        value: n,
        root: e,
        parent: t,
        type: i,
        props: r,
        children: s,
        line: _p,
        column: sl,
        length: o,
        return: ""
    }
}
function Zl(n, e) {
    return $T(yp("", null, null, "", null, null, 0), n, {
        length: -n.length
    }, e)
}
function KT() {
    return _n
}
function JT() {
    return _n = gi > 0 ? Un(_l, --gi) : 0,
    sl--,
    _n === 10 && (sl = 1,
    _p--),
    _n
}
function Ti() {
    return _n = gi < _3 ? Un(_l, gi++) : 0,
    sl++,
    _n === 10 && (sl = 1,
    _p++),
    _n
}
function Ar() {
    return Un(_l, gi)
}
function rh() {
    return gi
}
function bu(n, e) {
    return zc(_l, n, e)
}
function Vc(n) {
    switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function y3(n) {
    return _p = sl = 1,
    _3 = wr(_l = n),
    gi = 0,
    []
}
function S3(n) {
    return _l = "",
    n
}
function sh(n) {
    return x3(bu(gi - 1, c1(n === 91 ? n + 2 : n === 40 ? n + 1 : n)))
}
function QT(n) {
    for (; (_n = Ar()) && _n < 33; )
        Ti();
    return Vc(n) > 2 || Vc(_n) > 3 ? "" : " "
}
function eA(n, e) {
    for (; --e && Ti() && !(_n < 48 || _n > 102 || _n > 57 && _n < 65 || _n > 70 && _n < 97); )
        ;
    return bu(n, rh() + (e < 6 && Ar() == 32 && Ti() == 32))
}
function c1(n) {
    for (; Ti(); )
        switch (_n) {
        case n:
            return gi;
        case 34:
        case 39:
            n !== 34 && n !== 39 && c1(_n);
            break;
        case 40:
            n === 41 && c1(n);
            break;
        case 92:
            Ti();
            break
        }
    return gi
}
function tA(n, e) {
    for (; Ti() && n + _n !== 57; )
        if (n + _n === 84 && Ar() === 47)
            break;
    return "/*" + bu(e, gi - 1) + "*" + xp(n === 47 ? n : Ti())
}
function nA(n) {
    for (; !Vc(Ar()); )
        Ti();
    return bu(n, gi)
}
function iA(n) {
    return S3(oh("", null, null, null, [""], n = y3(n), 0, [0], n))
}
function oh(n, e, t, i, r, s, o, l, u) {
    for (var f = 0, d = 0, h = o, m = 0, g = 0, x = 0, S = 1, _ = 1, v = 1, M = 0, w = "", E = r, O = s, R = i, A = w; _; )
        switch (x = M,
        M = Ti()) {
        case 40:
            if (x != 108 && Un(A, h - 1) == 58) {
                l1(A += Ft(sh(M), "&", "&\f"), "&\f") != -1 && (v = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            A += sh(M);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            A += QT(x);
            break;
        case 92:
            A += eA(rh() - 1, 7);
            continue;
        case 47:
            switch (Ar()) {
            case 42:
            case 47:
                Zf(rA(tA(Ti(), rh()), e, t), u);
                break;
            default:
                A += "/"
            }
            break;
        case 123 * S:
            l[f++] = wr(A) * v;
        case 125 * S:
        case 59:
        case 0:
            switch (M) {
            case 0:
            case 125:
                _ = 0;
            case 59 + d:
                v == -1 && (A = Ft(A, /\f/g, "")),
                g > 0 && wr(A) - h && Zf(g > 32 ? Yy(A + ";", i, t, h - 1) : Yy(Ft(A, " ", "") + ";", i, t, h - 2), u);
                break;
            case 59:
                A += ";";
            default:
                if (Zf(R = qy(A, e, t, f, d, r, l, w, E = [], O = [], h), s),
                M === 123)
                    if (d === 0)
                        oh(A, e, R, R, E, s, h, l, O);
                    else
                        switch (m === 99 && Un(A, 3) === 110 ? 100 : m) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            oh(n, R, R, i && Zf(qy(n, R, R, 0, 0, r, l, w, r, E = [], h), O), r, O, h, l, i ? E : O);
                            break;
                        default:
                            oh(A, R, R, R, [""], O, 0, l, O)
                        }
            }
            f = d = g = 0,
            S = v = 1,
            w = A = "",
            h = o;
            break;
        case 58:
            h = 1 + wr(A),
            g = x;
        default:
            if (S < 1) {
                if (M == 123)
                    --S;
                else if (M == 125 && S++ == 0 && JT() == 125)
                    continue
            }
            switch (A += xp(M),
            M * S) {
            case 38:
                v = d > 0 ? 1 : (A += "\f",
                -1);
                break;
            case 44:
                l[f++] = (wr(A) - 1) * v,
                v = 1;
                break;
            case 64:
                Ar() === 45 && (A += sh(Ti())),
                m = Ar(),
                d = h = wr(w = A += nA(rh())),
                M++;
                break;
            case 45:
                x === 45 && wr(A) == 2 && (S = 0)
            }
        }
    return s
}
function qy(n, e, t, i, r, s, o, l, u, f, d) {
    for (var h = r - 1, m = r === 0 ? s : [""], g = cv(m), x = 0, S = 0, _ = 0; x < i; ++x)
        for (var v = 0, M = zc(n, h + 1, h = XT(S = o[x])), w = n; v < g; ++v)
            (w = x3(S > 0 ? m[v] + " " + M : Ft(M, /&\f/g, m[v]))) && (u[_++] = w);
    return yp(n, e, t, r === 0 ? av : l, u, f, d)
}
function rA(n, e, t) {
    return yp(n, e, t, g3, xp(KT()), zc(n, 2, -2), 0)
}
function Yy(n, e, t, i) {
    return yp(n, e, t, lv, zc(n, 0, i), zc(n, i + 1, -1), i)
}
function Ja(n, e) {
    for (var t = "", i = cv(n), r = 0; r < i; r++)
        t += e(n[r], r, n, e) || "";
    return t
}
function sA(n, e, t, i) {
    switch (n.type) {
    case jT:
        if (n.children.length)
            break;
    case WT:
    case lv:
        return n.return = n.return || n.value;
    case g3:
        return "";
    case v3:
        return n.return = n.value + "{" + Ja(n.children, i) + "}";
    case av:
        n.value = n.props.join(",")
    }
    return wr(t = Ja(n.children, i)) ? n.return = n.value + "{" + t + "}" : ""
}
function oA(n) {
    var e = cv(n);
    return function(t, i, r, s) {
        for (var o = "", l = 0; l < e; l++)
            o += n[l](t, i, r, s) || "";
        return o
    }
}
function aA(n) {
    return function(e) {
        e.root || (e = e.return) && n(e)
    }
}
var Zy = function(e) {
    var t = new WeakMap;
    return function(i) {
        if (t.has(i))
            return t.get(i);
        var r = e(i);
        return t.set(i, r),
        r
    }
};
function lA(n) {
    var e = Object.create(null);
    return function(t) {
        return e[t] === void 0 && (e[t] = n(t)),
        e[t]
    }
}
var cA = function(e, t, i) {
    for (var r = 0, s = 0; r = s,
    s = Ar(),
    r === 38 && s === 12 && (t[i] = 1),
    !Vc(s); )
        Ti();
    return bu(e, gi)
}
  , uA = function(e, t) {
    var i = -1
      , r = 44;
    do
        switch (Vc(r)) {
        case 0:
            r === 38 && Ar() === 12 && (t[i] = 1),
            e[i] += cA(gi - 1, t, i);
            break;
        case 2:
            e[i] += sh(r);
            break;
        case 4:
            if (r === 44) {
                e[++i] = Ar() === 58 ? "&\f" : "",
                t[i] = e[i].length;
                break
            }
        default:
            e[i] += xp(r)
        }
    while (r = Ti());
    return e
}
  , fA = function(e, t) {
    return S3(uA(y3(e), t))
}
  , Ky = new WeakMap
  , dA = function(e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
        for (var t = e.value, i = e.parent, r = e.column === i.column && e.line === i.line; i.type !== "rule"; )
            if (i = i.parent,
            !i)
                return;
        if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !Ky.get(i)) && !r) {
            Ky.set(e, !0);
            for (var s = [], o = fA(t, s), l = i.props, u = 0, f = 0; u < o.length; u++)
                for (var d = 0; d < l.length; d++,
                f++)
                    e.props[f] = s[u] ? o[u].replace(/&\f/g, l[d]) : l[d] + " " + o[u]
        }
    }
}
  , hA = function(e) {
    if (e.type === "decl") {
        var t = e.value;
        t.charCodeAt(0) === 108 && t.charCodeAt(2) === 98 && (e.return = "",
        e.value = "")
    }
};
function M3(n, e) {
    switch (qT(n, e)) {
    case 5103:
        return Ut + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
        return Ut + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
        return Ut + n + yh + n + Xn + n + n;
    case 6828:
    case 4268:
        return Ut + n + Xn + n + n;
    case 6165:
        return Ut + n + Xn + "flex-" + n + n;
    case 5187:
        return Ut + n + Ft(n, /(\w+).+(:[^]+)/, Ut + "box-$1$2" + Xn + "flex-$1$2") + n;
    case 5443:
        return Ut + n + Xn + "flex-item-" + Ft(n, /flex-|-self/, "") + n;
    case 4675:
        return Ut + n + Xn + "flex-line-pack" + Ft(n, /align-content|flex-|-self/, "") + n;
    case 5548:
        return Ut + n + Xn + Ft(n, "shrink", "negative") + n;
    case 5292:
        return Ut + n + Xn + Ft(n, "basis", "preferred-size") + n;
    case 6060:
        return Ut + "box-" + Ft(n, "-grow", "") + Ut + n + Xn + Ft(n, "grow", "positive") + n;
    case 4554:
        return Ut + Ft(n, /([^-])(transform)/g, "$1" + Ut + "$2") + n;
    case 6187:
        return Ft(Ft(Ft(n, /(zoom-|grab)/, Ut + "$1"), /(image-set)/, Ut + "$1"), n, "") + n;
    case 5495:
    case 3959:
        return Ft(n, /(image-set\([^]*)/, Ut + "$1$`$1");
    case 4968:
        return Ft(Ft(n, /(.+:)(flex-)?(.*)/, Ut + "box-pack:$3" + Xn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Ut + n + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
        return Ft(n, /(.+)-inline(.+)/, Ut + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
        if (wr(n) - 1 - e > 6)
            switch (Un(n, e + 1)) {
            case 109:
                if (Un(n, e + 4) !== 45)
                    break;
            case 102:
                return Ft(n, /(.+:)(.+)-([^]+)/, "$1" + Ut + "$2-$3$1" + yh + (Un(n, e + 3) == 108 ? "$3" : "$2-$3")) + n;
            case 115:
                return ~l1(n, "stretch") ? M3(Ft(n, "stretch", "fill-available"), e) + n : n
            }
        break;
    case 4949:
        if (Un(n, e + 1) !== 115)
            break;
    case 6444:
        switch (Un(n, wr(n) - 3 - (~l1(n, "!important") && 10))) {
        case 107:
            return Ft(n, ":", ":" + Ut) + n;
        case 101:
            return Ft(n, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Ut + (Un(n, 14) === 45 ? "inline-" : "") + "box$3$1" + Ut + "$2$3$1" + Xn + "$2box$3") + n
        }
        break;
    case 5936:
        switch (Un(n, e + 11)) {
        case 114:
            return Ut + n + Xn + Ft(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
            return Ut + n + Xn + Ft(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
            return Ut + n + Xn + Ft(n, /[svh]\w+-[tblr]{2}/, "lr") + n
        }
        return Ut + n + Xn + n + n
    }
    return n
}
var pA = function(e, t, i, r) {
    if (e.length > -1 && !e.return)
        switch (e.type) {
        case lv:
            e.return = M3(e.value, e.length);
            break;
        case v3:
            return Ja([Zl(e, {
                value: Ft(e.value, "@", "@" + Ut)
            })], r);
        case av:
            if (e.length)
                return ZT(e.props, function(s) {
                    switch (YT(s, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                        return Ja([Zl(e, {
                            props: [Ft(s, /:(read-\w+)/, ":" + yh + "$1")]
                        })], r);
                    case "::placeholder":
                        return Ja([Zl(e, {
                            props: [Ft(s, /:(plac\w+)/, ":" + Ut + "input-$1")]
                        }), Zl(e, {
                            props: [Ft(s, /:(plac\w+)/, ":" + yh + "$1")]
                        }), Zl(e, {
                            props: [Ft(s, /:(plac\w+)/, Xn + "input-$1")]
                        })], r)
                    }
                    return ""
                })
        }
}
  , mA = [pA]
  , gA = function(e) {
    var t = e.key;
    if (t === "css") {
        var i = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(i, function(S) {
            var _ = S.getAttribute("data-emotion");
            _.indexOf(" ") !== -1 && (document.head.appendChild(S),
            S.setAttribute("data-s", ""))
        })
    }
    var r = e.stylisPlugins || mA, s = {}, o, l = [];
    o = e.container || document.head,
    Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + t + ' "]'), function(S) {
        for (var _ = S.getAttribute("data-emotion").split(" "), v = 1; v < _.length; v++)
            s[_[v]] = !0;
        l.push(S)
    });
    var u, f = [dA, hA];
    {
        var d, h = [sA, aA(function(S) {
            d.insert(S)
        })], m = oA(f.concat(r, h)), g = function(_) {
            return Ja(iA(_), m)
        };
        u = function(_, v, M, w) {
            d = M,
            g(_ ? _ + "{" + v.styles + "}" : v.styles),
            w && (x.inserted[v.name] = !0)
        }
    }
    var x = {
        key: t,
        sheet: new GT({
            key: t,
            container: o,
            nonce: e.nonce,
            speedy: e.speedy,
            prepend: e.prepend,
            insertionPoint: e.insertionPoint
        }),
        nonce: e.nonce,
        inserted: s,
        registered: {},
        insert: u
    };
    return x.sheet.hydrate(l),
    x
};
function ol() {
    return ol = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                ({}).hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    ol.apply(null, arguments)
}
var vA = function(n, e) {
    return A5(n, e)
}
  , xA = !0;
function w3(n, e, t) {
    var i = "";
    return t.split(" ").forEach(function(r) {
        n[r] !== void 0 ? e.push(n[r] + ";") : i += r + " "
    }),
    i
}
var uv = function(e, t, i) {
    var r = e.key + "-" + t.name;
    (i === !1 || xA === !1) && e.registered[r] === void 0 && (e.registered[r] = t.styles)
}
  , fv = function(e, t, i) {
    uv(e, t, i);
    var r = e.key + "-" + t.name;
    if (e.inserted[t.name] === void 0) {
        var s = t;
        do
            e.insert(t === s ? "." + r : "", s, e.sheet, !0),
            s = s.next;
        while (s !== void 0)
    }
};
function _A(n) {
    for (var e = 0, t, i = 0, r = n.length; r >= 4; ++i,
    r -= 4)
        t = n.charCodeAt(i) & 255 | (n.charCodeAt(++i) & 255) << 8 | (n.charCodeAt(++i) & 255) << 16 | (n.charCodeAt(++i) & 255) << 24,
        t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16),
        t ^= t >>> 24,
        e = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (r) {
    case 3:
        e ^= (n.charCodeAt(i + 2) & 255) << 16;
    case 2:
        e ^= (n.charCodeAt(i + 1) & 255) << 8;
    case 1:
        e ^= n.charCodeAt(i) & 255,
        e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16)
    }
    return e ^= e >>> 13,
    e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16),
    ((e ^ e >>> 15) >>> 0).toString(36)
}
var yA = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , SA = !1
  , MA = /[A-Z]|^ms/g
  , wA = /_EMO_([^_]+?)_([^]*?)_EMO_/g
  , b3 = function(e) {
    return e.charCodeAt(1) === 45
}
  , Jy = function(e) {
    return e != null && typeof e != "boolean"
}
  , B0 = lA(function(n) {
    return b3(n) ? n : n.replace(MA, "-$&").toLowerCase()
})
  , Qy = function(e, t) {
    switch (e) {
    case "animation":
    case "animationName":
        if (typeof t == "string")
            return t.replace(wA, function(i, r, s) {
                return br = {
                    name: r,
                    styles: s,
                    next: br
                },
                r
            })
    }
    return yA[e] !== 1 && !b3(e) && typeof t == "number" && t !== 0 ? t + "px" : t
}
  , bA = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function Hc(n, e, t) {
    if (t == null)
        return "";
    var i = t;
    if (i.__emotion_styles !== void 0)
        return i;
    switch (typeof t) {
    case "boolean":
        return "";
    case "object":
        {
            var r = t;
            if (r.anim === 1)
                return br = {
                    name: r.name,
                    styles: r.styles,
                    next: br
                },
                r.name;
            var s = t;
            if (s.styles !== void 0) {
                var o = s.next;
                if (o !== void 0)
                    for (; o !== void 0; )
                        br = {
                            name: o.name,
                            styles: o.styles,
                            next: br
                        },
                        o = o.next;
                var l = s.styles + ";";
                return l
            }
            return EA(n, e, t)
        }
    case "function":
        {
            if (n !== void 0) {
                var u = br
                  , f = t(n);
                return br = u,
                Hc(n, e, f)
            }
            break
        }
    }
    var d = t;
    if (e == null)
        return d;
    var h = e[d];
    return h !== void 0 ? h : d
}
function EA(n, e, t) {
    var i = "";
    if (Array.isArray(t))
        for (var r = 0; r < t.length; r++)
            i += Hc(n, e, t[r]) + ";";
    else
        for (var s in t) {
            var o = t[s];
            if (typeof o != "object") {
                var l = o;
                e != null && e[l] !== void 0 ? i += s + "{" + e[l] + "}" : Jy(l) && (i += B0(s) + ":" + Qy(s, l) + ";")
            } else {
                if (s === "NO_COMPONENT_SELECTOR" && SA)
                    throw new Error(bA);
                if (Array.isArray(o) && typeof o[0] == "string" && (e == null || e[o[0]] === void 0))
                    for (var u = 0; u < o.length; u++)
                        Jy(o[u]) && (i += B0(s) + ":" + Qy(s, o[u]) + ";");
                else {
                    var f = Hc(n, e, o);
                    switch (s) {
                    case "animation":
                    case "animationName":
                        {
                            i += B0(s) + ":" + f + ";";
                            break
                        }
                    default:
                        i += s + "{" + f + "}"
                    }
                }
            }
        }
    return i
}
var e2 = /label:\s*([^\s;\n{]+)\s*(;|$)/g, br;
function Sp(n, e, t) {
    if (n.length === 1 && typeof n[0] == "object" && n[0] !== null && n[0].styles !== void 0)
        return n[0];
    var i = !0
      , r = "";
    br = void 0;
    var s = n[0];
    if (s == null || s.raw === void 0)
        i = !1,
        r += Hc(t, e, s);
    else {
        var o = s;
        r += o[0]
    }
    for (var l = 1; l < n.length; l++)
        if (r += Hc(t, e, n[l]),
        i) {
            var u = s;
            r += u[l]
        }
    e2.lastIndex = 0;
    for (var f = "", d; (d = e2.exec(r)) !== null; )
        f += "-" + d[1];
    var h = _A(r) + f;
    return {
        name: h,
        styles: r,
        next: br
    }
}
var CA = function(e) {
    return e()
}
  , E3 = i1.useInsertionEffect ? i1.useInsertionEffect : !1
  , C3 = E3 || CA
  , t2 = E3 || N.useLayoutEffect
  , u1 = !1
  , dv = N.createContext(typeof HTMLElement < "u" ? gA({
    key: "css"
}) : null)
  , TA = dv.Provider
  , AA = function() {
    return N.useContext(dv)
}
  , Mp = function(e) {
    return N.forwardRef(function(t, i) {
        var r = N.useContext(dv);
        return e(t, r, i)
    })
}
  , Hs = N.createContext({})
  , RA = function() {
    return N.useContext(Hs)
}
  , PA = function(e, t) {
    if (typeof t == "function") {
        var i = t(e);
        return i
    }
    return ol({}, e, t)
}
  , IA = Zy(function(n) {
    return Zy(function(e) {
        return PA(n, e)
    })
})
  , LA = function(e) {
    var t = N.useContext(Hs);
    return e.theme !== t && (t = IA(t)(e.theme)),
    N.createElement(Hs.Provider, {
        value: t
    }, e.children)
};
function NA(n) {
    var e = n.displayName || n.name || "Component"
      , t = function(s, o) {
        var l = N.useContext(Hs);
        return N.createElement(n, ol({
            theme: l,
            ref: o
        }, s))
    }
      , i = N.forwardRef(t);
    return i.displayName = "WithTheme(" + e + ")",
    vA(i, n)
}
var Eu = {}.hasOwnProperty
  , f1 = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__"
  , hv = function(e, t) {
    var i = {};
    for (var r in t)
        Eu.call(t, r) && (i[r] = t[r]);
    return i[f1] = e,
    i
}
  , OA = function(e) {
    var t = e.cache
      , i = e.serialized
      , r = e.isStringTag;
    return uv(t, i, r),
    C3(function() {
        return fv(t, i, r)
    }),
    null
}
  , DA = Mp(function(n, e, t) {
    var i = n.css;
    typeof i == "string" && e.registered[i] !== void 0 && (i = e.registered[i]);
    var r = n[f1]
      , s = [i]
      , o = "";
    typeof n.className == "string" ? o = w3(e.registered, s, n.className) : n.className != null && (o = n.className + " ");
    var l = Sp(s, void 0, N.useContext(Hs));
    o += e.key + "-" + l.name;
    var u = {};
    for (var f in n)
        Eu.call(n, f) && f !== "css" && f !== f1 && !u1 && (u[f] = n[f]);
    return u.className = o,
    t && (u.ref = t),
    N.createElement(N.Fragment, null, N.createElement(OA, {
        cache: e,
        serialized: l,
        isStringTag: typeof r == "string"
    }), N.createElement(r, u))
})
  , pv = DA
  , n2 = function(e, t) {
    var i = arguments;
    if (t == null || !Eu.call(t, "css"))
        return N.createElement.apply(void 0, i);
    var r = i.length
      , s = new Array(r);
    s[0] = pv,
    s[1] = hv(e, t);
    for (var o = 2; o < r; o++)
        s[o] = i[o];
    return N.createElement.apply(null, s)
}
  , UA = Mp(function(n, e) {
    var t = n.styles
      , i = Sp([t], void 0, N.useContext(Hs))
      , r = N.useRef();
    return t2(function() {
        var s = e.key + "-global"
          , o = new e.sheet.constructor({
            key: s,
            nonce: e.sheet.nonce,
            container: e.sheet.container,
            speedy: e.sheet.isSpeedy
        })
          , l = !1
          , u = document.querySelector('style[data-emotion="' + s + " " + i.name + '"]');
        return e.sheet.tags.length && (o.before = e.sheet.tags[0]),
        u !== null && (l = !0,
        u.setAttribute("data-emotion", s),
        o.hydrate([u])),
        r.current = [o, l],
        function() {
            o.flush()
        }
    }, [e]),
    t2(function() {
        var s = r.current
          , o = s[0]
          , l = s[1];
        if (l) {
            s[1] = !1;
            return
        }
        if (i.next !== void 0 && fv(e, i.next, !0),
        o.tags.length) {
            var u = o.tags[o.tags.length - 1].nextElementSibling;
            o.before = u,
            o.flush()
        }
        e.insert("", i, o, !1)
    }, [e, i.name]),
    null
});
function T3() {
    for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
    return Sp(e)
}
var FA = function() {
    var e = T3.apply(void 0, arguments)
      , t = "animation-" + e.name;
    return {
        name: t,
        styles: "@keyframes " + t + "{" + e.styles + "}",
        anim: 1,
        toString: function() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
        }
    }
}
  , kA = function n(e) {
    for (var t = e.length, i = 0, r = ""; i < t; i++) {
        var s = e[i];
        if (s != null) {
            var o = void 0;
            switch (typeof s) {
            case "boolean":
                break;
            case "object":
                {
                    if (Array.isArray(s))
                        o = n(s);
                    else {
                        o = "";
                        for (var l in s)
                            s[l] && l && (o && (o += " "),
                            o += l)
                    }
                    break
                }
            default:
                o = s
            }
            o && (r && (r += " "),
            r += o)
        }
    }
    return r
};
function BA(n, e, t) {
    var i = []
      , r = w3(n, i, t);
    return i.length < 2 ? t : r + e(i)
}
var zA = function(e) {
    var t = e.cache
      , i = e.serializedArr;
    return C3(function() {
        for (var r = 0; r < i.length; r++)
            fv(t, i[r], !1)
    }),
    null
}
  , VA = Mp(function(n, e) {
    var t = !1
      , i = []
      , r = function() {
        if (t && u1)
            throw new Error("css can only be used during render");
        for (var f = arguments.length, d = new Array(f), h = 0; h < f; h++)
            d[h] = arguments[h];
        var m = Sp(d, e.registered);
        return i.push(m),
        uv(e, m, !1),
        e.key + "-" + m.name
    }
      , s = function() {
        if (t && u1)
            throw new Error("cx can only be used during render");
        for (var f = arguments.length, d = new Array(f), h = 0; h < f; h++)
            d[h] = arguments[h];
        return BA(e.registered, r, kA(d))
    }
      , o = {
        css: r,
        cx: s,
        theme: N.useContext(Hs)
    }
      , l = n.children(o);
    return t = !0,
    N.createElement(N.Fragment, null, N.createElement(zA, {
        cache: e,
        serializedArr: i
    }), l)
});
const HA = Object.freeze(Object.defineProperty({
    __proto__: null,
    CacheProvider: TA,
    ClassNames: VA,
    Global: UA,
    ThemeContext: Hs,
    ThemeProvider: LA,
    __unsafe_useEmotionCache: AA,
    createElement: n2,
    css: T3,
    jsx: n2,
    keyframes: FA,
    useTheme: RA,
    withEmotionCache: Mp,
    withTheme: NA
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Ur = rv(HA);
var wp = {};
Object.defineProperty(wp, "__esModule", {
    value: !0
});
wp.default = void 0;
const GA = `
	.react-timekeeper-button-reset {
		background: 0;
		border: 0;
		box-shadow: none;
		text-shadow: none;
		-webkit-appearance: none;
		-moz-appearance: none;
		cursor: pointer;
	}
	.react-timekeeper-button-reset:hover, .react-timekeeper-button-reset:focus, .react-timekeeper-button-reset:active {
		outline: none;
	}
	.react-timekeeper-button-reset::-moz-focus-inner {
		border: 0;
		padding: 0;
	}
	.react-timekeeper-noscroll {
		overflow: hidden;
	}
	.react-timekeeper-scrollbar-measure {
		width: 100px;
		height: 100px;
		overflow: scroll;
		position: absolute;
		top: -9999px;
	}
`;
var WA = GA;
wp.default = WA;
var bp = {}
  , ot = {};
Object.defineProperty(ot, "__esModule", {
    value: !0
});
ot.VISIBLE_NUMBERS_PER_CIRCLE = ot.NUMBER_REGULAR_FONT_SIZE = ot.NUMBER_RADIUS_REGULAR = ot.NUMBER_OUTER_POSITION = ot.MODE = ot.MINUTES = ot.MERIDIEM = ot.INNER_NUMBER_RADIUS = ot.INNER_NUMBER_POSITIONING = ot.INITIAL_MINUTE_TRANSFORM = ot.INITIAL_HOUR_TRANSFORM = ot.HOUR_24_OUTER_FONT_SIZE = ot.HOUR_24_INNER_FONT_SIZE = ot.CLOCK_VALUES = ot.CLOCK_SIZE = ot.CLOCK_RADIUS = void 0;
ot.getClockHandCirclePosition = i4;
ot.getClockHandCircleRadius = r4;
ot.getClockHandLength = n4;
ot.getOuterNumberPosition = QA;
const A3 = ["05", 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, "00"].map(n => n.toString());
ot.MINUTES = A3;
const jA = Array.from(Array(60), (n, e) => e.toString())
  , i2 = Array.from(Array(12), (n, e) => (e + 1).toString())
  , z0 = Array.from(Array(23), (n, e) => (e + 1).toString()).concat("00");
let Rr;
ot.MODE = Rr;
(function(n) {
    n.MINUTES = "MINUTES",
    n.HOURS_12 = "HOURS_12",
    n.HOURS_24 = "HOURS_24"
}
)(Rr || (ot.MODE = Rr = {}));
let d1;
ot.MERIDIEM = d1;
(function(n) {
    n.am = "am",
    n.pm = "pm"
}
)(d1 || (ot.MERIDIEM = d1 = {}));
const XA = {
    [Rr.MINUTES]: {
        increments: 60,
        numbers: A3,
        dropdown: jA
    },
    [Rr.HOURS_12]: {
        increments: 12,
        numbers: i2,
        dropdown: i2
    },
    [Rr.HOURS_24]: {
        increments: 12,
        numbers: z0.slice(12),
        numbersInner: z0.slice(0, 12),
        dropdown: z0
    }
};
ot.CLOCK_VALUES = XA;
const $A = 12;
ot.VISIBLE_NUMBERS_PER_CIRCLE = $A;
const mv = 110;
ot.CLOCK_RADIUS = mv;
const qA = mv * 2;
ot.CLOCK_SIZE = qA;
const R3 = 77;
ot.INNER_NUMBER_RADIUS = R3;
const YA = 16;
ot.NUMBER_REGULAR_FONT_SIZE = YA;
const ZA = 15;
ot.HOUR_24_INNER_FONT_SIZE = ZA;
const KA = 13;
ot.HOUR_24_OUTER_FONT_SIZE = KA;
const P3 = 34;
ot.NUMBER_RADIUS_REGULAR = P3;
const JA = 32
  , I3 = 28
  , yl = 22;
ot.NUMBER_OUTER_POSITION = yl;
const gv = 18
  , Sh = mv - R3 + I3 / 2;
function QA(n) {
    return n === Rr.HOURS_24 ? gv : yl
}
const e4 = yl - 32;
ot.INITIAL_HOUR_TRANSFORM = e4;
const t4 = yl + 28;
ot.INITIAL_MINUTE_TRANSFORM = t4;
function n4(n, e) {
    return n !== Rr.HOURS_24 ? yl : e ? Sh : gv
}
function i4(n, e) {
    return n !== Rr.HOURS_24 ? yl : e ? Sh : gv
}
function r4(n, e) {
    return n !== Rr.HOURS_24 ? P3 / 2 : e ? I3 / 2 : JA / 2
}
const s4 = 22
  , o4 = {
    exit: Sh + s4,
    enter: Sh
};
ot.INNER_NUMBER_POSITIONING = o4;
Object.defineProperty(bp, "__esModule", {
    value: !0
});
bp.default = void 0;
var a4 = Ur
  , l4 = ot;
const c4 = 20
  , u4 = (0,
a4.css)(`-webkit-tap-highlight-color:transparent;-webkit-font-smoothing:antialiased;font-smoothing:antialiased;font-family:var(--main-font-family, 'Roboto', sans-serif);background:var(--main-bg, white);box-shadow:var(
		--main-box-shadow,
		0 3px 11px rgba(0, 0, 0, 0.1),
		0 3px 6px rgba(0, 0, 0, 0.15)
	);border-radius:3px;display:inline-block;width:`, l4.CLOCK_RADIUS * 2 + c4 * 2, "px;position:relative;user-select:none;", "");
var f4 = u4;
bp.default = f4;
var vv = {}
  , xv = {}
  , ks = {}
  , Ii = {};
Object.defineProperty(Ii, "__esModule", {
    value: !0
});
Ii.getNormalizedTimeValue = h4;
Ii.getTimeValue = L3;
Ii.isHourMode = p4;
Ii.isMinuteMode = m4;
Ii.isSameTime = g4;
var Gc = ot;
function d4(n) {
    return n === Gc.MODE.MINUTES ? "minute" : "hour"
}
function L3(n, e) {
    const t = d4(n);
    return e[t]
}
function h4(n, e) {
    const t = L3(n, e);
    return n === Gc.MODE.HOURS_12 ? t % 12 : t
}
function p4(n) {
    return n === Gc.MODE.HOURS_12 || n === Gc.MODE.HOURS_24
}
function m4(n) {
    return n === Gc.MODE.MINUTES
}
function g4(n, e) {
    return n.hour === e.hour && n.minute === e.minute
}
Object.defineProperty(ks, "__esModule", {
    value: !0
});
ks.wrapper = ks.options = ks.option = void 0;
var _v = Ur, v4 = Ii, r2;
function x4(n, e) {
    return e || (e = n.slice(0)),
    Object.freeze(Object.defineProperties(n, {
        raw: {
            value: Object.freeze(e)
        }
    }))
}
const _4 = "#f4f4f4"
  , y4 = "#8c8c8c"
  , S4 = "#ddd"
  , N3 = "#EAF8FF"
  , M4 = "right: -22px;"
  , w4 = "right: -10px;"
  , b4 = `
	left: 50%;
	transform: translateX(-50%);
`
  , E4 = (0,
_v.keyframes)(r2 || (r2 = x4([`
	0% { opacity: 0; }
	100% { opacity: 1; }
`])))
  , C4 = (n, e) => (0,
_v.css)("position:absolute;display:inline-block;background:white;border:var(--dropdown-border, 1px solid ", _4, `);border-radius:2px;padding:6px 0;z-index:20;top:62px;height:250px;overflow-y:auto;box-shadow:var(
		--dropdown-shadow,
		0 1px 3px rgba(0, 0, 0, 0.12),
		0 1px 2px rgba(0, 0, 0, 0.24)
	);opacity:0;animation:`, E4, " 0.2s ease-out both;", n ? b4 : (0,
v4.isMinuteMode)(e) ? w4 : M4, ";", "");
ks.wrapper = C4;
const T4 = {
    name: "ho1x7s",
    styles: "position:relative;list-style:none;padding:0;margin:0"
};
ks.options = T4;
const A4 = "background: ".concat(N3, ";")
  , R4 = "var(--dropdown-text-color, ".concat(y4, ")")
  , P4 = "var(--dropdown-text-color-disabled, ".concat(S4, ")")
  , I4 = n => {
    let {active: e, enabled: t} = n;
    return (0,
    _v.css)("background:transparent;padding:7px 30px;font-size:16px;color:", t ? R4 : P4, ";cursor:", t ? "pointer" : "not-allowed", ";&:hover{background:", t && "var(--dropdown-hover-bg, ".concat(N3, ")"), ";}", e && A4, ";", "")
}
;
ks.option = I4;
var Zi = {}
  , L4 = T.Fragment;
function N4(n, e, t) {
    return Eu.call(e, "css") ? T.jsx(pv, hv(n, e), t) : T.jsx(n, e, t)
}
function O4(n, e, t) {
    return Eu.call(e, "css") ? T.jsxs(pv, hv(n, e), t) : T.jsxs(n, e, t)
}
const D4 = Object.freeze(Object.defineProperty({
    __proto__: null,
    Fragment: L4,
    jsx: N4,
    jsxs: O4
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Ki = rv(D4);
Object.defineProperty(Zi, "__esModule", {
    value: !0
});
Zi.ConfigProvider = k4;
Zi.configContext = void 0;
Zi.default = B4;
var yv = F4(N)
  , U4 = Ki;
function O3(n) {
    if (typeof WeakMap != "function")
        return null;
    var e = new WeakMap
      , t = new WeakMap;
    return (O3 = function(i) {
        return i ? t : e
    }
    )(n)
}
function F4(n, e) {
    if (n && n.__esModule)
        return n;
    if (n === null || typeof n != "object" && typeof n != "function")
        return {
            default: n
        };
    var t = O3(e);
    if (t && t.has(n))
        return t.get(n);
    var i = {}
      , r = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var s in n)
        if (s !== "default" && Object.prototype.hasOwnProperty.call(n, s)) {
            var o = r ? Object.getOwnPropertyDescriptor(n, s) : null;
            o && (o.get || o.set) ? Object.defineProperty(i, s, o) : i[s] = n[s]
        }
    return i.default = n,
    t && t.set(n, i),
    i
}
const Sv = (0,
yv.createContext)({});
Zi.configContext = Sv;
function k4(n) {
    let {children: e, coarseMinutes: t=5, forceCoarseMinutes: i=!1, switchToMinuteOnHourSelect: r=!1, switchToMinuteOnHourDropdownSelect: s=!1, closeOnMinuteSelect: o=!1, hour24Mode: l=!1, onDoneClick: u=null, doneButton: f=null} = n;
    const d = (0,
    yv.useMemo)( () => {
        if (t < 1)
            throw new Error("coarseMinutes must be at least 1");
        return {
            coarseMinutes: t,
            forceCoarseMinutes: i,
            switchToMinuteOnHourSelect: r,
            switchToMinuteOnHourDropdownSelect: s,
            closeOnMinuteSelect: o,
            hour24Mode: l,
            onDoneClick: u,
            doneButton: f
        }
    }
    , [t, i, r, s, o, u, l, f]);
    return (0,
    U4.jsx)(Sv.Provider, {
        value: d,
        children: e
    })
}
function B4() {
    return (0,
    yv.useContext)(Sv)
}
var Cu = {};
Object.defineProperty(Cu, "__esModule", {
    value: !0
});
Cu.calcOffset = V4;
Cu.getScrollBarWidth = z4;
function z4() {
    const n = document.createElement("div");
    n.className = "react-timekeeper-scrollbar-measure",
    document.body.appendChild(n);
    const e = n.offsetWidth - n.clientWidth;
    return document.body.removeChild(n),
    e
}
function V4(n) {
    const e = window.getComputedStyle(n, null);
    return function(i, r) {
        const s = parseInt(e.borderLeftWidth, 10) || 0
          , o = parseInt(e.borderTopWidth, 10) || 0
          , l = n.getBoundingClientRect();
        return {
            offsetX: i - s - l.left,
            offsetY: r - o - l.top
        }
    }
}
var Ji = {}
  , H4 = "Expected a function"
  , s2 = NaN
  , G4 = "[object Symbol]"
  , W4 = /^\s+|\s+$/g
  , j4 = /^[-+]0x[0-9a-f]+$/i
  , X4 = /^0b[01]+$/i
  , $4 = /^0o[0-7]+$/i
  , q4 = parseInt
  , Y4 = typeof qf == "object" && qf && qf.Object === Object && qf
  , Z4 = typeof self == "object" && self && self.Object === Object && self
  , K4 = Y4 || Z4 || Function("return this")()
  , J4 = Object.prototype
  , Q4 = J4.toString
  , eR = Math.max
  , tR = Math.min
  , V0 = function() {
    return K4.Date.now()
};
function nR(n, e, t) {
    var i, r, s, o, l, u, f = 0, d = !1, h = !1, m = !0;
    if (typeof n != "function")
        throw new TypeError(H4);
    e = o2(e) || 0,
    h1(t) && (d = !!t.leading,
    h = "maxWait"in t,
    s = h ? eR(o2(t.maxWait) || 0, e) : s,
    m = "trailing"in t ? !!t.trailing : m);
    function g(R) {
        var A = i
          , F = r;
        return i = r = void 0,
        f = R,
        o = n.apply(F, A),
        o
    }
    function x(R) {
        return f = R,
        l = setTimeout(v, e),
        d ? g(R) : o
    }
    function S(R) {
        var A = R - u
          , F = R - f
          , I = e - A;
        return h ? tR(I, s - F) : I
    }
    function _(R) {
        var A = R - u
          , F = R - f;
        return u === void 0 || A >= e || A < 0 || h && F >= s
    }
    function v() {
        var R = V0();
        if (_(R))
            return M(R);
        l = setTimeout(v, S(R))
    }
    function M(R) {
        return l = void 0,
        m && i ? g(R) : (i = r = void 0,
        o)
    }
    function w() {
        l !== void 0 && clearTimeout(l),
        f = 0,
        i = u = r = l = void 0
    }
    function E() {
        return l === void 0 ? o : M(V0())
    }
    function O() {
        var R = V0()
          , A = _(R);
        if (i = arguments,
        r = this,
        u = R,
        A) {
            if (l === void 0)
                return x(u);
            if (h)
                return l = setTimeout(v, e),
                g(u)
        }
        return l === void 0 && (l = setTimeout(v, e)),
        o
    }
    return O.cancel = w,
    O.flush = E,
    O
}
function h1(n) {
    var e = typeof n;
    return !!n && (e == "object" || e == "function")
}
function iR(n) {
    return !!n && typeof n == "object"
}
function rR(n) {
    return typeof n == "symbol" || iR(n) && Q4.call(n) == G4
}
function o2(n) {
    if (typeof n == "number")
        return n;
    if (rR(n))
        return s2;
    if (h1(n)) {
        var e = typeof n.valueOf == "function" ? n.valueOf() : n;
        n = h1(e) ? e + "" : e
    }
    if (typeof n != "string")
        return n === 0 ? n : +n;
    n = n.replace(W4, "");
    var t = X4.test(n);
    return t || $4.test(n) ? q4(n.slice(2), t ? 2 : 8) : j4.test(n) ? s2 : +n
}
var sR = nR
  , js = {};
Object.defineProperty(js, "__esModule", {
    value: !0
});
js.TIME_PARSE_24 = void 0;
js.composeTime = cR;
js.parseMeridiem = lR;
js.parseTime = U3;
const oR = new RegExp(/^(\d{1,2}?):(\d{2}?)\s?(am|pm)$/i)
  , D3 = new RegExp(/^(\d{1,2}?):(\d{2}?)$/);
js.TIME_PARSE_24 = D3;
const aR = {
    hour: 12,
    minute: 30
};
function U3(n) {
    if (n == null)
        return aR;
    let e = 0
      , t = 0
      , i = null;
    if (typeof n == "string") {
        let r = n.match(oR);
        if (r)
            e = parseInt(r[1], 10),
            t = parseInt(r[2], 10),
            i = r[3].toLowerCase();
        else {
            if (r = n.match(D3),
            !r)
                throw new Error("Could not parse time (string)");
            e = parseInt(r[1], 10),
            t = parseInt(r[2], 10)
        }
    } else if (typeof n == "object") {
        if (!Number.isInteger(n.hour) || !Number.isInteger(n.minute))
            throw new Error("Time and minute must both be valid integers");
        e = n.hour,
        t = n.minute,
        "meridiem"in n && (i = n.meridiem.toLowerCase())
    }
    if (t > 60)
        throw new Error("Minute out of range (> 60)");
    if (i != null) {
        if (e > 12)
            throw new Error("Hour out of range (> 12)");
        i === "pm" && e !== 12 ? e += 12 : i === "am" && e === 12 && (e = 0)
    } else {
        if (e > 24)
            throw new Error("Hour out of range (> 24)");
        e === 24 && (e = 0)
    }
    return {
        hour: e,
        minute: t
    }
}
function lR(n) {
    return U3(n).hour >= 12 ? "pm" : "am"
}
function cR(n, e, t) {
    const i = ("0" + e).slice(-2)
      , r = n === 24 ? 0 : n
      , s = n >= 12 ? "pm" : "am";
    let o = n;
    n > 12 ? o = n - 12 : n === 0 && (o = n = 12);
    let l = !0;
    return t && (!t.validateHour(r) || !t.validateMinute(r, e)) && (l = !1),
    {
        formatted24: "".concat(r, ":").concat(i),
        formatted12: "".concat(o, ":").concat(i, " ").concat(s),
        formattedSimple: "".concat(o, ":").concat(i),
        hour: r,
        hour12: o,
        minute: e,
        meridiem: s,
        isValid: l
    }
}
var Ep = {};
Object.defineProperty(Ep, "__esModule", {
    value: !0
});
Ep.default = void 0;
var uR = js;
function a2(n) {
    const e = n.match(uR.TIME_PARSE_24);
    if (!e)
        throw new Error("Could not parse time for disabled time range");
    return {
        hour: parseInt(e[1], 10),
        minute: parseInt(e[2], 10)
    }
}
function fR(n, e, t, i) {
    const r = n
      , s = t
      , o = n === t;
    return n < t || o && e < i ? l => l <= r || l >= s : l => l <= r && l >= s
}
function dR(n, e, t, i, r) {
    return (s, o) => r(s) ? s === n ? o <= e : s === t ? o >= i : !0 : !1
}
class hR {
    constructor(e, t) {
        const {hour: i, minute: r} = a2(e)
          , {hour: s, minute: o} = a2(t);
        if (i === s && r === o)
            throw new Error("invalid date range - same time");
        this.validateHour = fR(i, r, s, o),
        this.validateMinute = dR(i, r, s, o, this.validateHour)
    }
}
Ep.default = hR;
Object.defineProperty(Ji, "__esModule", {
    value: !0
});
Ji.StateProvider = _R;
Ji.default = yR;
Ji.stateContext = void 0;
var $n = N
  , pR = Mv(sR)
  , ma = js
  , mR = Mv(Zi)
  , Ss = Ii
  , oo = ot
  , gR = Mv(Ep)
  , vR = Ki;
function Mv(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
const wv = (0,
$n.createContext)({});
Ji.stateContext = wv;
function xR(n, e) {
    switch (e.type) {
    case "SET_TIME":
        return {
            ...n,
            time: e.time,
            meridiem: e.meridiem || n.meridiem
        };
    case "SET_MODE":
        return {
            ...n,
            mode: e.mode
        };
    case "SET_MERIDIEM":
        return {
            ...n,
            meridiem: e.meridiem
        }
    }
    return n
}
function _R(n) {
    let {onChange: e, time: t, children: i, disabledTimeRange: r} = n;
    const s = (0,
    mR.default)()
      , [o,l] = (0,
    $n.useReducer)(xR, null, () => ({
        time: (0,
        ma.parseTime)(t),
        mode: s.hour24Mode ? oo.MODE.HOURS_24 : oo.MODE.HOURS_12,
        meridiem: (0,
        ma.parseMeridiem)(t)
    }))
      , {mode: u, time: f, meridiem: d} = o
      , h = (0,
    $n.useRef)(f)
      , m = (0,
    $n.useRef)(e)
      , g = (0,
    $n.useRef)(s.onDoneClick);
    (0,
    $n.useEffect)( () => {
        m.current = e
    }
    , [e]),
    (0,
    $n.useEffect)( () => {
        g.current = s.onDoneClick
    }
    , [s.onDoneClick]);
    const x = (0,
    $n.useMemo)( () => {
        const A = r == null ? void 0 : r.from
          , F = r == null ? void 0 : r.to;
        return !A || !F ? null : new gR.default(A,F)
    }
    , [r == null ? void 0 : r.from, r == null ? void 0 : r.to]);
    (0,
    $n.useEffect)( () => {
        if (t == null)
            return;
        const A = (0,
        ma.parseTime)(t);
        if ((0,
        Ss.isSameTime)(A, h.current))
            return;
        const F = {
            type: "SET_TIME",
            time: (0,
            ma.parseTime)(t)
        };
        s.hour24Mode || (F.meridiem = (0,
        ma.parseMeridiem)(t)),
        l(F)
    }
    , [s.hour24Mode, t]);
    const S = (0,
    $n.useCallback)( () => {
        const A = h.current;
        return (0,
        ma.composeTime)(A.hour, A.minute, x)
    }
    , [x])
      , _ = (0,
    $n.useMemo)( () => (0,
    pR.default)( () => {
        typeof m.current == "function" && m.current(S())
    }
    , 80), [S])
      , v = (0,
    $n.useCallback)( (A, F) => {
        l({
            type: "SET_TIME",
            time: A,
            meridiem: F
        }),
        h.current = A,
        _()
    }
    , [_]);
    function M(A) {
        if (d === A)
            return;
        const F = {
            minute: f.minute,
            hour: 0
        };
        A === "am" ? F.hour = f.hour - 12 : A === "pm" && (F.hour = f.hour + 12),
        v(F, A)
    }
    const w = (0,
    $n.useCallback)(A => {
        let F = A;
        (0,
        Ss.isHourMode)(A) && (F = s.hour24Mode ? oo.MODE.HOURS_24 : oo.MODE.HOURS_12),
        l({
            type: "SET_MODE",
            mode: F
        })
    }
    , [s.hour24Mode])
      , E = (0,
    $n.useCallback)(A => {
        A.type === "clock" && A.canAutoChangeMode ? s.switchToMinuteOnHourSelect && (0,
        Ss.isHourMode)(u) ? w(oo.MODE.MINUTES) : s.closeOnMinuteSelect && (0,
        Ss.isMinuteMode)(u) && g.current && g.current(S()) : A.type === "dropdown" && s.switchToMinuteOnHourDropdownSelect && (0,
        Ss.isHourMode)(u) && w(oo.MODE.MINUTES)
    }
    , [s.switchToMinuteOnHourSelect, s.closeOnMinuteSelect, s.switchToMinuteOnHourDropdownSelect, S, u, w])
      , O = (0,
    $n.useCallback)( (A, F) => {
        A = A % 60,
        u === oo.MODE.HOURS_12 && d === "pm" && (A += 12);
        const I = (0,
        Ss.isHourMode)(u) ? "hour" : "minute"
          , P = h.current;
        if (P[I] === A && F.type === "clock" && !F.canAutoChangeMode || x && ((0,
        Ss.isHourMode)(u) && !x.validateHour(A) || (0,
        Ss.isMinuteMode)(u) && !x.validateMinute(P.hour, A)))
            return;
        E(F);
        const D = {
            ...P,
            [I]: A
        };
        v(D)
    }
    , [u, d, E, x, v])
      , R = {
        time: f,
        mode: u,
        updateTimeValue: O,
        updateMeridiem: M,
        setMode: w,
        getComposedTime: S,
        disabledTimeRangeValidator: x,
        meridiem: d
    };
    return (0,
    vR.jsx)(wv.Provider, {
        value: R,
        children: i
    })
}
function yR() {
    return (0,
    $n.useContext)(wv)
}
Object.defineProperty(xv, "__esModule", {
    value: !0
});
xv.default = CR;
var Kl = N
  , H0 = ER(ks)
  , SR = F3(Zi)
  , MR = Cu
  , wR = Ii
  , Jl = ot
  , bR = F3(Ji)
  , G0 = Ki;
function F3(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function k3(n) {
    if (typeof WeakMap != "function")
        return null;
    var e = new WeakMap
      , t = new WeakMap;
    return (k3 = function(i) {
        return i ? t : e
    }
    )(n)
}
function ER(n, e) {
    if (n && n.__esModule)
        return n;
    if (n === null || typeof n != "object" && typeof n != "function")
        return {
            default: n
        };
    var t = k3(e);
    if (t && t.has(n))
        return t.get(n);
    var i = {}
      , r = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var s in n)
        if (s !== "default" && Object.prototype.hasOwnProperty.call(n, s)) {
            var o = r ? Object.getOwnPropertyDescriptor(n, s) : null;
            o && (o.get || o.set) ? Object.defineProperty(i, s, o) : i[s] = n[s]
        }
    return i.default = n,
    t && t.set(n, i),
    i
}
let W0 = null;
function CR(n) {
    let {close: e} = n;
    const {hour24Mode: t} = (0,
    SR.default)()
      , {updateTimeValue: i, mode: r, time: s, meridiem: o, disabledTimeRangeValidator: l} = (0,
    bR.default)()
      , u = (0,
    Kl.useRef)(null)
      , f = (0,
    Kl.useRef)(null)
      , d = (0,
    Kl.useMemo)( () => {
        const _ = Jl.CLOCK_VALUES[r].dropdown;
        let v = () => !0;
        return l && (r === Jl.MODE.HOURS_12 ? o === "am" ? v = (M, w) => l.validateHour((w + 1) % 12) : v = (M, w) => {
            const E = w === 11 ? 12 : w + 13;
            return l.validateHour(E)
        }
        : r === Jl.MODE.HOURS_24 ? v = (M, w) => l.validateHour((w + 1) % 24) : r === Jl.MODE.MINUTES && (v = M => l.validateMinute(s.hour, parseInt(M, 10)))),
        _.map( (M, w) => ({
            value: M,
            enabled: v(M, w)
        }))
    }
    , [r, l, o, s.hour])
      , h = (0,
    wR.getNormalizedTimeValue)(r, s).toString();
    function m() {
        document.documentElement.style.paddingRight = W0 + "px",
        document.documentElement.classList.add("react-timekeeper-noscroll")
    }
    function g() {
        document.documentElement.style.paddingRight = "0",
        document.documentElement.classList.remove("react-timekeeper-noscroll")
    }
    const x = (0,
    Kl.useCallback)(_ => {
        !u.current || !_.target || u.current.contains(_.target) || e()
    }
    , [e]);
    (0,
    Kl.useEffect)( () => (W0 == null && (W0 = (0,
    MR.getScrollBarWidth)()),
    f.current && u.current && (u.current.scrollTop = f.current.offsetTop),
    document.addEventListener("click", x, !1),
    () => {
        document.removeEventListener("click", x, !1),
        g()
    }
    ), [x]);
    function S(_, v) {
        if (!v)
            return;
        let M = parseInt(_, 10);
        r === Jl.MODE.HOURS_12 && M === 12 && (M = 0),
        i(M, {
            type: "dropdown"
        }),
        e()
    }
    return (0,
    G0.jsx)("div", {
        css: H0.wrapper(t, r),
        ref: u,
        onMouseEnter: m,
        onMouseLeave: g,
        className: "react-timekeeper__time-dropdown",
        "data-testid": "time-dropdown",
        children: (0,
        G0.jsx)("ul", {
            css: H0.options,
            className: "react-timekeeper__dropdown-numbers",
            children: d.map(_ => {
                let {value: v, enabled: M} = _;
                const w = h === v;
                return (0,
                G0.jsx)("li", {
                    ref: E => w ? f.current = E : "",
                    className: "react-timekeeper__dropdown-number ".concat(w ? "react-timekeeper__dropdown-number--active" : ""),
                    css: H0.option({
                        active: w,
                        enabled: M
                    }),
                    onClick: () => S(v, M),
                    "data-testid": "time-dropdown_number",
                    children: v
                }, v)
            }
            )
        })
    })
}
var hi = {};
Object.defineProperty(hi, "__esModule", {
    value: !0
});
hi.wrapper = hi.time = hi.minuteWrapper = hi.meridiem = hi.hourWrapper = hi.colon = void 0;
var Xs = Ur, l2;
function TR(n, e) {
    return e || (e = n.slice(0)),
    Object.freeze(Object.defineProperties(n, {
        raw: {
            value: Object.freeze(e)
        }
    }))
}
const bv = "#8C8C8C"
  , AR = "#8EDDFD"
  , RR = n => (0,
Xs.css)("background:var(--top-bg, white);padding:14px 16px;border-radius:3px 3px 0 0;position:relative;", n && `
		display: flex;
		justify-content: center;
	`, ";", "");
hi.wrapper = RR;
const PR = n => (0,
Xs.css)("width:72px;text-align:right;position:relative;display:inline-block;", !n && "margin-left: 20px;", ";", "");
hi.hourWrapper = PR;
const IR = n => (0,
Xs.css)("position:relative;display:inline-block;", n && "width: 72px;", ";", "");
hi.minuteWrapper = IR;
const LR = (0,
Xs.css)("color:var(--top-colon-color, ", bv, ");font-weight:500;display:inline-block;font-size:46px;vertical-align:2px;margin:0 5px;line-height:normal;", "");
hi.colon = LR;
const NR = (0,
Xs.keyframes)(l2 || (l2 = TR([`
	from { transform: scale(1); }
	30% { transform: scale(0.88); }
	60% { transform: scale(1.05); }
	to { transform: scale(1); }
`])))
  , OR = (0,
Xs.css)("color:var(--top-selected-color, ", AR, ");animation:", NR, " 0.6s ease-out;", "")
  , DR = n => (0,
Xs.css)("color:var(--top-text-color, ", bv, ");display:inline-block;font-size:48px;cursor:pointer;user-select:none;line-height:normal;", n && OR, ";", "");
hi.time = DR;
const UR = (0,
Xs.css)("color:var(--top-meridiem-color, ", bv, ");display:inline-block;font-size:13px;text-transform:uppercase;margin-left:2px;padding:10px 8px;vertical-align:1px;", "");
hi.meridiem = UR;
Object.defineProperty(vv, "__esModule", {
    value: !0
});
vv.default = HR;
var FR = N
  , c2 = Ev(xv)
  , kR = Ev(Ji)
  , BR = Ev(Zi)
  , ao = VR(hi)
  , jr = ot
  , zR = Ii
  , Xr = Ki;
function B3(n) {
    if (typeof WeakMap != "function")
        return null;
    var e = new WeakMap
      , t = new WeakMap;
    return (B3 = function(i) {
        return i ? t : e
    }
    )(n)
}
function VR(n, e) {
    if (n && n.__esModule)
        return n;
    if (n === null || typeof n != "object" && typeof n != "function")
        return {
            default: n
        };
    var t = B3(e);
    if (t && t.has(n))
        return t.get(n);
    var i = {}
      , r = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var s in n)
        if (s !== "default" && Object.prototype.hasOwnProperty.call(n, s)) {
            var o = r ? Object.getOwnPropertyDescriptor(n, s) : null;
            o && (o.get || o.set) ? Object.defineProperty(i, s, o) : i[s] = n[s]
        }
    return i.default = n,
    t && t.set(n, i),
    i
}
function Ev(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function HR() {
    const {hour24Mode: n} = (0,
    BR.default)()
      , {mode: e, time: t, updateMeridiem: i, setMode: r} = (0,
    kR.default)()
      , [s,o] = (0,
    FR.useState)(null);
    function l(x) {
        const S = e === jr.MODE.MINUTES ? "minute" : "hour";
        if (x === S)
            o(S);
        else {
            const _ = e === jr.MODE.MINUTES ? jr.MODE.HOURS_24 : jr.MODE.MINUTES;
            r(_)
        }
    }
    const u = n ? t.hour : t.hour % 12 === 0 ? 12 : t.hour % 12
      , f = t.hour >= 12 ? jr.MERIDIEM.pm : jr.MERIDIEM.am;
    function d() {
        const x = f === jr.MERIDIEM.am ? jr.MERIDIEM.pm : jr.MERIDIEM.am;
        i(x)
    }
    const h = (0,
    zR.isHourMode)(e)
      , m = ("0" + t.minute).slice(-2)
      , g = () => o(null);
    return (0,
    Xr.jsxs)("div", {
        css: ao.wrapper(n),
        className: "react-timekeeper__top-bar",
        "data-testid": "topbar",
        children: [(0,
        Xr.jsxs)("div", {
            css: ao.hourWrapper(n),
            className: "react-timekeeper__tb-minute-wrapper",
            children: [(0,
            Xr.jsx)("span", {
                css: [ao.time(h), "", ""],
                onClick: () => l("hour"),
                "data-testid": "topbar_hour",
                className: "react-timekeeper__tb-hour ".concat(h ? "react-timekeeper__tb-hour--active" : ""),
                children: u
            }), s === "hour" && (0,
            Xr.jsx)(c2.default, {
                close: g
            })]
        }), (0,
        Xr.jsx)("span", {
            css: ao.colon,
            className: "react-timekeeper__tb-colon",
            children: ":"
        }), (0,
        Xr.jsxs)("div", {
            css: ao.minuteWrapper(n),
            className: "react-timekeeper__tb-hour-wrapper",
            children: [(0,
            Xr.jsx)("span", {
                css: ao.time(!h),
                onClick: () => l("minute"),
                "data-testid": "topbar_minute",
                className: "react-timekeeper__tb-minute ".concat(h ? "" : "react-timekeeper__tb-minute--active"),
                children: m
            }), s === "minute" && (0,
            Xr.jsx)(c2.default, {
                close: g
            })]
        }), !n && (0,
        Xr.jsx)("button", {
            name: "meridiem",
            type: "button",
            onClick: d,
            css: ao.meridiem,
            "data-testid": "topbar_meridiem",
            className: "react-timekeeper-button-reset react-timekeeper__tb-meridiem",
            children: f
        })]
    })
}
var Cv = {}
  , Tv = {}
  , Av = Au()
  , mt = n => Tu(n, Av)
  , Rv = Au();
mt.write = n => Tu(n, Rv);
var Cp = Au();
mt.onStart = n => Tu(n, Cp);
var Pv = Au();
mt.onFrame = n => Tu(n, Pv);
var Iv = Au();
mt.onFinish = n => Tu(n, Iv);
var Qa = [];
mt.setTimeout = (n, e) => {
    const t = mt.now() + e
      , i = () => {
        const s = Qa.findIndex(o => o.cancel == i);
        ~s && Qa.splice(s, 1),
        Os -= ~s ? 1 : 0
    }
      , r = {
        time: t,
        handler: n,
        cancel: i
    };
    return Qa.splice(z3(t), 0, r),
    Os += 1,
    V3(),
    r
}
;
var z3 = n => ~(~Qa.findIndex(e => e.time > n) || ~Qa.length);
mt.cancel = n => {
    Cp.delete(n),
    Pv.delete(n),
    Iv.delete(n),
    Av.delete(n),
    Rv.delete(n)
}
;
mt.sync = n => {
    p1 = !0,
    mt.batchedUpdates(n),
    p1 = !1
}
;
mt.throttle = n => {
    let e;
    function t() {
        try {
            n(...e)
        } finally {
            e = null
        }
    }
    function i(...r) {
        e = r,
        mt.onStart(t)
    }
    return i.handler = n,
    i.cancel = () => {
        Cp.delete(t),
        e = null
    }
    ,
    i
}
;
var Lv = typeof window < "u" ? window.requestAnimationFrame : () => {}
;
mt.use = n => Lv = n;
mt.now = typeof performance < "u" ? () => performance.now() : Date.now;
mt.batchedUpdates = n => n();
mt.catch = console.error;
mt.frameLoop = "always";
mt.advance = () => {
    mt.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : G3()
}
;
var Ns = -1
  , Os = 0
  , p1 = !1;
function Tu(n, e) {
    p1 ? (e.delete(n),
    n(0)) : (e.add(n),
    V3())
}
function V3() {
    Ns < 0 && (Ns = 0,
    mt.frameLoop !== "demand" && Lv(H3))
}
function GR() {
    Ns = -1
}
function H3() {
    ~Ns && (Lv(H3),
    mt.batchedUpdates(G3))
}
function G3() {
    const n = Ns;
    Ns = mt.now();
    const e = z3(Ns);
    if (e && (W3(Qa.splice(0, e), t => t.handler()),
    Os -= e),
    !Os) {
        GR();
        return
    }
    Cp.flush(),
    Av.flush(n ? Math.min(64, Ns - n) : 16.667),
    Pv.flush(),
    Rv.flush(),
    Iv.flush()
}
function Au() {
    let n = new Set
      , e = n;
    return {
        add(t) {
            Os += e == n && !n.has(t) ? 1 : 0,
            n.add(t)
        },
        delete(t) {
            return Os -= e == n && n.has(t) ? 1 : 0,
            n.delete(t)
        },
        flush(t) {
            e.size && (n = new Set,
            Os -= e.size,
            W3(e, i => i(t) && n.add(i)),
            Os += n.size,
            e = n)
        }
    }
}
function W3(n, e) {
    n.forEach(t => {
        try {
            e(t)
        } catch (i) {
            mt.catch(i)
        }
    }
    )
}
var WR = Object.defineProperty
  , jR = (n, e) => {
    for (var t in e)
        WR(n, t, {
            get: e[t],
            enumerable: !0
        })
}
  , $i = {};
jR($i, {
    assign: () => $3,
    colors: () => Bs,
    createStringInterpolator: () => Ov,
    skipAnimation: () => X3,
    to: () => j3,
    willAdvance: () => Dv
});
function m1() {}
var XR = (n, e, t) => Object.defineProperty(n, e, {
    value: t,
    writable: !0,
    configurable: !0
})
  , Se = {
    arr: Array.isArray,
    obj: n => !!n && n.constructor.name === "Object",
    fun: n => typeof n == "function",
    str: n => typeof n == "string",
    num: n => typeof n == "number",
    und: n => n === void 0
};
function Qr(n, e) {
    if (Se.arr(n)) {
        if (!Se.arr(e) || n.length !== e.length)
            return !1;
        for (let t = 0; t < n.length; t++)
            if (n[t] !== e[t])
                return !1;
        return !0
    }
    return n === e
}
var rt = (n, e) => n.forEach(e);
function Or(n, e, t) {
    if (Se.arr(n)) {
        for (let i = 0; i < n.length; i++)
            e.call(t, n[i], `${i}`);
        return
    }
    for (const i in n)
        n.hasOwnProperty(i) && e.call(t, n[i], i)
}
var ni = n => Se.und(n) ? [] : Se.arr(n) ? n : [n];
function Mc(n, e) {
    if (n.size) {
        const t = Array.from(n);
        n.clear(),
        rt(t, e)
    }
}
var _c = (n, ...e) => Mc(n, t => t(...e)), Nv = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), Ov, j3, Bs = null, X3 = !1, Dv = m1, $3 = n => {
    n.to && (j3 = n.to),
    n.now && (mt.now = n.now),
    n.colors !== void 0 && (Bs = n.colors),
    n.skipAnimation != null && (X3 = n.skipAnimation),
    n.createStringInterpolator && (Ov = n.createStringInterpolator),
    n.requestAnimationFrame && mt.use(n.requestAnimationFrame),
    n.batchedUpdates && (mt.batchedUpdates = n.batchedUpdates),
    n.willAdvance && (Dv = n.willAdvance),
    n.frameLoop && (mt.frameLoop = n.frameLoop)
}
, wc = new Set, Wi = [], j0 = [], Mh = 0, Ru = {
    get idle() {
        return !wc.size && !Wi.length
    },
    start(n) {
        Mh > n.priority ? (wc.add(n),
        mt.onStart($R)) : (q3(n),
        mt(g1))
    },
    advance: g1,
    sort(n) {
        if (Mh)
            mt.onFrame( () => Ru.sort(n));
        else {
            const e = Wi.indexOf(n);
            ~e && (Wi.splice(e, 1),
            Y3(n))
        }
    },
    clear() {
        Wi = [],
        wc.clear()
    }
};
function $R() {
    wc.forEach(q3),
    wc.clear(),
    mt(g1)
}
function q3(n) {
    Wi.includes(n) || Y3(n)
}
function Y3(n) {
    Wi.splice(qR(Wi, e => e.priority > n.priority), 0, n)
}
function g1(n) {
    const e = j0;
    for (let t = 0; t < Wi.length; t++) {
        const i = Wi[t];
        Mh = i.priority,
        i.idle || (Dv(i),
        i.advance(n),
        i.idle || e.push(i))
    }
    return Mh = 0,
    j0 = Wi,
    j0.length = 0,
    Wi = e,
    Wi.length > 0
}
function qR(n, e) {
    const t = n.findIndex(e);
    return t < 0 ? n.length : t
}
var YR = (n, e, t) => Math.min(Math.max(t, n), e)
  , ZR = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
}
  , cr = "[-+]?\\d*\\.?\\d+"
  , wh = cr + "%";
function Tp(...n) {
    return "\\(\\s*(" + n.join(")\\s*,\\s*(") + ")\\s*\\)"
}
var KR = new RegExp("rgb" + Tp(cr, cr, cr))
  , JR = new RegExp("rgba" + Tp(cr, cr, cr, cr))
  , QR = new RegExp("hsl" + Tp(cr, wh, wh))
  , eP = new RegExp("hsla" + Tp(cr, wh, wh, cr))
  , tP = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/
  , nP = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/
  , iP = /^#([0-9a-fA-F]{6})$/
  , rP = /^#([0-9a-fA-F]{8})$/;
function sP(n) {
    let e;
    return typeof n == "number" ? n >>> 0 === n && n >= 0 && n <= 4294967295 ? n : null : (e = iP.exec(n)) ? parseInt(e[1] + "ff", 16) >>> 0 : Bs && Bs[n] !== void 0 ? Bs[n] : (e = KR.exec(n)) ? (ga(e[1]) << 24 | ga(e[2]) << 16 | ga(e[3]) << 8 | 255) >>> 0 : (e = JR.exec(n)) ? (ga(e[1]) << 24 | ga(e[2]) << 16 | ga(e[3]) << 8 | d2(e[4])) >>> 0 : (e = tP.exec(n)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = rP.exec(n)) ? parseInt(e[1], 16) >>> 0 : (e = nP.exec(n)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = QR.exec(n)) ? (u2(f2(e[1]), Kf(e[2]), Kf(e[3])) | 255) >>> 0 : (e = eP.exec(n)) ? (u2(f2(e[1]), Kf(e[2]), Kf(e[3])) | d2(e[4])) >>> 0 : null
}
function X0(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n
}
function u2(n, e, t) {
    const i = t < .5 ? t * (1 + e) : t + e - t * e
      , r = 2 * t - i
      , s = X0(r, i, n + 1 / 3)
      , o = X0(r, i, n)
      , l = X0(r, i, n - 1 / 3);
    return Math.round(s * 255) << 24 | Math.round(o * 255) << 16 | Math.round(l * 255) << 8
}
function ga(n) {
    const e = parseInt(n, 10);
    return e < 0 ? 0 : e > 255 ? 255 : e
}
function f2(n) {
    return (parseFloat(n) % 360 + 360) % 360 / 360
}
function d2(n) {
    const e = parseFloat(n);
    return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255)
}
function Kf(n) {
    const e = parseFloat(n);
    return e < 0 ? 0 : e > 100 ? 1 : e / 100
}
function h2(n) {
    let e = sP(n);
    if (e === null)
        return n;
    e = e || 0;
    const t = (e & 4278190080) >>> 24
      , i = (e & 16711680) >>> 16
      , r = (e & 65280) >>> 8
      , s = (e & 255) / 255;
    return `rgba(${t}, ${i}, ${r}, ${s})`
}
var al = (n, e, t) => {
    if (Se.fun(n))
        return n;
    if (Se.arr(n))
        return al({
            range: n,
            output: e,
            extrapolate: t
        });
    if (Se.str(n.output[0]))
        return Ov(n);
    const i = n
      , r = i.output
      , s = i.range || [0, 1]
      , o = i.extrapolateLeft || i.extrapolate || "extend"
      , l = i.extrapolateRight || i.extrapolate || "extend"
      , u = i.easing || (f => f);
    return f => {
        const d = aP(f, s);
        return oP(f, s[d], s[d + 1], r[d], r[d + 1], u, o, l, i.map)
    }
}
;
function oP(n, e, t, i, r, s, o, l, u) {
    let f = u ? u(n) : n;
    if (f < e) {
        if (o === "identity")
            return f;
        o === "clamp" && (f = e)
    }
    if (f > t) {
        if (l === "identity")
            return f;
        l === "clamp" && (f = t)
    }
    return i === r ? i : e === t ? n <= e ? i : r : (e === -1 / 0 ? f = -f : t === 1 / 0 ? f = f - e : f = (f - e) / (t - e),
    f = s(f),
    i === -1 / 0 ? f = -f : r === 1 / 0 ? f = f + i : f = f * (r - i) + i,
    f)
}
function aP(n, e) {
    for (var t = 1; t < e.length - 1 && !(e[t] >= n); ++t)
        ;
    return t - 1
}
var lP = (n, e="end") => t => {
    t = e === "end" ? Math.min(t, .999) : Math.max(t, .001);
    const i = t * n
      , r = e === "end" ? Math.floor(i) : Math.ceil(i);
    return YR(0, 1, r / n)
}
  , bh = 1.70158
  , Jf = bh * 1.525
  , p2 = bh + 1
  , m2 = 2 * Math.PI / 3
  , g2 = 2 * Math.PI / 4.5
  , Qf = n => n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375
  , Z3 = {
    linear: n => n,
    easeInQuad: n => n * n,
    easeOutQuad: n => 1 - (1 - n) * (1 - n),
    easeInOutQuad: n => n < .5 ? 2 * n * n : 1 - Math.pow(-2 * n + 2, 2) / 2,
    easeInCubic: n => n * n * n,
    easeOutCubic: n => 1 - Math.pow(1 - n, 3),
    easeInOutCubic: n => n < .5 ? 4 * n * n * n : 1 - Math.pow(-2 * n + 2, 3) / 2,
    easeInQuart: n => n * n * n * n,
    easeOutQuart: n => 1 - Math.pow(1 - n, 4),
    easeInOutQuart: n => n < .5 ? 8 * n * n * n * n : 1 - Math.pow(-2 * n + 2, 4) / 2,
    easeInQuint: n => n * n * n * n * n,
    easeOutQuint: n => 1 - Math.pow(1 - n, 5),
    easeInOutQuint: n => n < .5 ? 16 * n * n * n * n * n : 1 - Math.pow(-2 * n + 2, 5) / 2,
    easeInSine: n => 1 - Math.cos(n * Math.PI / 2),
    easeOutSine: n => Math.sin(n * Math.PI / 2),
    easeInOutSine: n => -(Math.cos(Math.PI * n) - 1) / 2,
    easeInExpo: n => n === 0 ? 0 : Math.pow(2, 10 * n - 10),
    easeOutExpo: n => n === 1 ? 1 : 1 - Math.pow(2, -10 * n),
    easeInOutExpo: n => n === 0 ? 0 : n === 1 ? 1 : n < .5 ? Math.pow(2, 20 * n - 10) / 2 : (2 - Math.pow(2, -20 * n + 10)) / 2,
    easeInCirc: n => 1 - Math.sqrt(1 - Math.pow(n, 2)),
    easeOutCirc: n => Math.sqrt(1 - Math.pow(n - 1, 2)),
    easeInOutCirc: n => n < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * n, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * n + 2, 2)) + 1) / 2,
    easeInBack: n => p2 * n * n * n - bh * n * n,
    easeOutBack: n => 1 + p2 * Math.pow(n - 1, 3) + bh * Math.pow(n - 1, 2),
    easeInOutBack: n => n < .5 ? Math.pow(2 * n, 2) * ((Jf + 1) * 2 * n - Jf) / 2 : (Math.pow(2 * n - 2, 2) * ((Jf + 1) * (n * 2 - 2) + Jf) + 2) / 2,
    easeInElastic: n => n === 0 ? 0 : n === 1 ? 1 : -Math.pow(2, 10 * n - 10) * Math.sin((n * 10 - 10.75) * m2),
    easeOutElastic: n => n === 0 ? 0 : n === 1 ? 1 : Math.pow(2, -10 * n) * Math.sin((n * 10 - .75) * m2) + 1,
    easeInOutElastic: n => n === 0 ? 0 : n === 1 ? 1 : n < .5 ? -(Math.pow(2, 20 * n - 10) * Math.sin((20 * n - 11.125) * g2)) / 2 : Math.pow(2, -20 * n + 10) * Math.sin((20 * n - 11.125) * g2) / 2 + 1,
    easeInBounce: n => 1 - Qf(1 - n),
    easeOutBounce: Qf,
    easeInOutBounce: n => n < .5 ? (1 - Qf(1 - 2 * n)) / 2 : (1 + Qf(2 * n - 1)) / 2,
    steps: lP
}
  , Wc = Symbol.for("FluidValue.get")
  , ll = Symbol.for("FluidValue.observers")
  , Gi = n => !!(n && n[Wc])
  , di = n => n && n[Wc] ? n[Wc]() : n
  , v2 = n => n[ll] || null;
function cP(n, e) {
    n.eventObserved ? n.eventObserved(e) : n(e)
}
function jc(n, e) {
    const t = n[ll];
    t && t.forEach(i => {
        cP(i, e)
    }
    )
}
var K3 = class {
    constructor(e) {
        if (!e && !(e = this.get))
            throw Error("Unknown getter");
        uP(this, e)
    }
}
  , uP = (n, e) => J3(n, Wc, e);
function Sl(n, e) {
    if (n[Wc]) {
        let t = n[ll];
        t || J3(n, ll, t = new Set),
        t.has(e) || (t.add(e),
        n.observerAdded && n.observerAdded(t.size, e))
    }
    return e
}
function Xc(n, e) {
    const t = n[ll];
    if (t && t.has(e)) {
        const i = t.size - 1;
        i ? t.delete(e) : n[ll] = null,
        n.observerRemoved && n.observerRemoved(i, e)
    }
}
var J3 = (n, e, t) => Object.defineProperty(n, e, {
    value: t,
    writable: !0,
    configurable: !0
}), ah = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, fP = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, x2 = new RegExp(`(${ah.source})(%|[a-z]+)`,"i"), dP = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, Ap = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, Q3 = n => {
    const [e,t] = hP(n);
    if (!e || Nv())
        return n;
    const i = window.getComputedStyle(document.documentElement).getPropertyValue(e);
    if (i)
        return i.trim();
    if (t && t.startsWith("--")) {
        const r = window.getComputedStyle(document.documentElement).getPropertyValue(t);
        return r || n
    } else {
        if (t && Ap.test(t))
            return Q3(t);
        if (t)
            return t
    }
    return n
}
, hP = n => {
    const e = Ap.exec(n);
    if (!e)
        return [, ];
    const [,t,i] = e;
    return [t, i]
}
, $0, pP = (n, e, t, i, r) => `rgba(${Math.round(e)}, ${Math.round(t)}, ${Math.round(i)}, ${r})`, ew = n => {
    $0 || ($0 = Bs ? new RegExp(`(${Object.keys(Bs).join("|")})(?!\\w)`,"g") : /^\b$/);
    const e = n.output.map(s => di(s).replace(Ap, Q3).replace(fP, h2).replace($0, h2))
      , t = e.map(s => s.match(ah).map(Number))
      , r = t[0].map( (s, o) => t.map(l => {
        if (!(o in l))
            throw Error('The arity of each "output" value must be equal');
        return l[o]
    }
    )).map(s => al({
        ...n,
        output: s
    }));
    return s => {
        var u;
        const o = !x2.test(e[0]) && ((u = e.find(f => x2.test(f))) == null ? void 0 : u.replace(ah, ""));
        let l = 0;
        return e[0].replace(ah, () => `${r[l++](s)}${o || ""}`).replace(dP, pP)
    }
}
, Uv = "react-spring: ", tw = n => {
    const e = n;
    let t = !1;
    if (typeof e != "function")
        throw new TypeError(`${Uv}once requires a function parameter`);
    return (...i) => {
        t || (e(...i),
        t = !0)
    }
}
, mP = tw(console.warn);
function nw() {
    mP(`${Uv}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
var gP = tw(console.warn);
function vP() {
    gP(`${Uv}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)
}
function Rp(n) {
    return Se.str(n) && (n[0] == "#" || /\d/.test(n) || !Nv() && Ap.test(n) || n in (Bs || {}))
}
var va, lh = new WeakMap, xP = n => n.forEach( ({target: e, contentRect: t}) => {
    var i;
    return (i = lh.get(e)) == null ? void 0 : i.forEach(r => r(t))
}
);
function _P(n, e) {
    va || typeof ResizeObserver < "u" && (va = new ResizeObserver(xP));
    let t = lh.get(e);
    return t || (t = new Set,
    lh.set(e, t)),
    t.add(n),
    va && va.observe(e),
    () => {
        const i = lh.get(e);
        i && (i.delete(n),
        !i.size && va && va.unobserve(e))
    }
}
var ch = new Set, Ql, yP = () => {
    const n = () => {
        ch.forEach(e => e({
            width: window.innerWidth,
            height: window.innerHeight
        }))
    }
    ;
    return window.addEventListener("resize", n),
    () => {
        window.removeEventListener("resize", n)
    }
}
, SP = n => (ch.add(n),
Ql || (Ql = yP()),
() => {
    ch.delete(n),
    !ch.size && Ql && (Ql(),
    Ql = void 0)
}
), iw = (n, {container: e=document.documentElement}={}) => e === document.documentElement ? SP(n) : _P(n, e), MP = (n, e, t) => e - n === 0 ? 1 : (t - n) / (e - n), wP = {
    x: {
        length: "Width",
        position: "Left"
    },
    y: {
        length: "Height",
        position: "Top"
    }
}, bP = class {
    constructor(n, e) {
        this.createAxis = () => ({
            current: 0,
            progress: 0,
            scrollLength: 0
        }),
        this.updateAxis = t => {
            const i = this.info[t]
              , {length: r, position: s} = wP[t];
            i.current = this.container[`scroll${s}`],
            i.scrollLength = this.container[`scroll${r}`] - this.container[`client${r}`],
            i.progress = MP(0, i.scrollLength, i.current)
        }
        ,
        this.update = () => {
            this.updateAxis("x"),
            this.updateAxis("y")
        }
        ,
        this.sendEvent = () => {
            this.callback(this.info)
        }
        ,
        this.advance = () => {
            this.update(),
            this.sendEvent()
        }
        ,
        this.callback = n,
        this.container = e,
        this.info = {
            time: 0,
            x: this.createAxis(),
            y: this.createAxis()
        }
    }
}
, ec = new WeakMap, _2 = new WeakMap, q0 = new WeakMap, y2 = n => n === document.documentElement ? window : n, EP = (n, {container: e=document.documentElement}={}) => {
    let t = q0.get(e);
    t || (t = new Set,
    q0.set(e, t));
    const i = new bP(n,e);
    if (t.add(i),
    !ec.has(e)) {
        const s = () => (t == null || t.forEach(l => l.advance()),
        !0);
        ec.set(e, s);
        const o = y2(e);
        window.addEventListener("resize", s, {
            passive: !0
        }),
        e !== document.documentElement && _2.set(e, iw(s, {
            container: e
        })),
        o.addEventListener("scroll", s, {
            passive: !0
        })
    }
    const r = ec.get(e);
    return mt(r),
    () => {
        var l;
        mt.cancel(r);
        const s = q0.get(e);
        if (!s || (s.delete(i),
        s.size))
            return;
        const o = ec.get(e);
        ec.delete(e),
        o && (y2(e).removeEventListener("scroll", o),
        window.removeEventListener("resize", o),
        (l = _2.get(e)) == null || l())
    }
}
;
function CP(n) {
    const e = N.useRef(null);
    return e.current === null && (e.current = n()),
    e.current
}
var pi = Nv() ? N.useEffect : N.useLayoutEffect
  , TP = () => {
    const n = N.useRef(!1);
    return pi( () => (n.current = !0,
    () => {
        n.current = !1
    }
    ), []),
    n
}
;
function Fv() {
    const n = N.useState()[1]
      , e = TP();
    return () => {
        e.current && n(Math.random())
    }
}
function AP(n, e) {
    const [t] = N.useState( () => ({
        inputs: e,
        result: n()
    }))
      , i = N.useRef()
      , r = i.current;
    let s = r;
    return s ? e && s.inputs && RP(e, s.inputs) || (s = {
        inputs: e,
        result: n()
    }) : s = t,
    N.useEffect( () => {
        i.current = s,
        r == t && (t.inputs = t.result = void 0)
    }
    , [s]),
    s.result
}
function RP(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0; t < n.length; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
var Pp = n => N.useEffect(n, PP)
  , PP = [];
function v1(n) {
    const e = N.useRef();
    return N.useEffect( () => {
        e.current = n
    }
    ),
    e.current
}
var IP = () => {
    const [n,e] = N.useState(null);
    return pi( () => {
        const t = window.matchMedia("(prefers-reduced-motion)")
          , i = r => {
            e(r.matches),
            $3({
                skipAnimation: r.matches
            })
        }
        ;
        return i(t),
        t.addEventListener ? t.addEventListener("change", i) : t.addListener(i),
        () => {
            t.removeEventListener ? t.removeEventListener("change", i) : t.removeListener(i)
        }
    }
    , []),
    n
}
  , $c = Symbol.for("Animated:node")
  , LP = n => !!n && n[$c] === n
  , Mr = n => n && n[$c]
  , kv = (n, e) => XR(n, $c, e)
  , Ip = n => n && n[$c] && n[$c].getPayload()
  , rw = class {
    constructor() {
        kv(this, this)
    }
    getPayload() {
        return this.payload || []
    }
}
  , Pu = class extends rw {
    constructor(e) {
        super(),
        this._value = e,
        this.done = !0,
        this.durationProgress = 0,
        Se.num(this._value) && (this.lastPosition = this._value)
    }
    static create(e) {
        return new Pu(e)
    }
    getPayload() {
        return [this]
    }
    getValue() {
        return this._value
    }
    setValue(e, t) {
        return Se.num(e) && (this.lastPosition = e,
        t && (e = Math.round(e / t) * t,
        this.done && (this.lastPosition = e))),
        this._value === e ? !1 : (this._value = e,
        !0)
    }
    reset() {
        const {done: e} = this;
        this.done = !1,
        Se.num(this._value) && (this.elapsedTime = 0,
        this.durationProgress = 0,
        this.lastPosition = this._value,
        e && (this.lastVelocity = null),
        this.v0 = null)
    }
}
  , qc = class extends Pu {
    constructor(e) {
        super(0),
        this._string = null,
        this._toString = al({
            output: [e, e]
        })
    }
    static create(e) {
        return new qc(e)
    }
    getValue() {
        const e = this._string;
        return e ?? (this._string = this._toString(this._value))
    }
    setValue(e) {
        if (Se.str(e)) {
            if (e == this._string)
                return !1;
            this._string = e,
            this._value = 1
        } else if (super.setValue(e))
            this._string = null;
        else
            return !1;
        return !0
    }
    reset(e) {
        e && (this._toString = al({
            output: [this.getValue(), e]
        })),
        this._value = 0,
        super.reset()
    }
}
  , Eh = {
    dependencies: null
}
  , Lp = class extends rw {
    constructor(e) {
        super(),
        this.source = e,
        this.setValue(e)
    }
    getValue(e) {
        const t = {};
        return Or(this.source, (i, r) => {
            LP(i) ? t[r] = i.getValue(e) : Gi(i) ? t[r] = di(i) : e || (t[r] = i)
        }
        ),
        t
    }
    setValue(e) {
        this.source = e,
        this.payload = this._makePayload(e)
    }
    reset() {
        this.payload && rt(this.payload, e => e.reset())
    }
    _makePayload(e) {
        if (e) {
            const t = new Set;
            return Or(e, this._addToPayload, t),
            Array.from(t)
        }
    }
    _addToPayload(e) {
        Eh.dependencies && Gi(e) && Eh.dependencies.add(e);
        const t = Ip(e);
        t && rt(t, i => this.add(i))
    }
}
  , sw = class extends Lp {
    constructor(e) {
        super(e)
    }
    static create(e) {
        return new sw(e)
    }
    getValue() {
        return this.source.map(e => e.getValue())
    }
    setValue(e) {
        const t = this.getPayload();
        return e.length == t.length ? t.map( (i, r) => i.setValue(e[r])).some(Boolean) : (super.setValue(e.map(NP)),
        !0)
    }
}
;
function NP(n) {
    return (Rp(n) ? qc : Pu).create(n)
}
function x1(n) {
    const e = Mr(n);
    return e ? e.constructor : Se.arr(n) ? sw : Rp(n) ? qc : Pu
}
var S2 = (n, e) => {
    const t = !Se.fun(n) || n.prototype && n.prototype.isReactComponent;
    return N.forwardRef( (i, r) => {
        const s = N.useRef(null)
          , o = t && N.useCallback(x => {
            s.current = UP(r, x)
        }
        , [r])
          , [l,u] = DP(i, e)
          , f = Fv()
          , d = () => {
            const x = s.current;
            if (t && !x)
                return;
            (x ? e.applyAnimatedValues(x, l.getValue(!0)) : !1) === !1 && f()
        }
          , h = new OP(d,u)
          , m = N.useRef();
        pi( () => (m.current = h,
        rt(u, x => Sl(x, h)),
        () => {
            m.current && (rt(m.current.deps, x => Xc(x, m.current)),
            mt.cancel(m.current.update))
        }
        )),
        N.useEffect(d, []),
        Pp( () => () => {
            const x = m.current;
            rt(x.deps, S => Xc(S, x))
        }
        );
        const g = e.getComponentProps(l.getValue());
        return N.createElement(n, {
            ...g,
            ref: o
        })
    }
    )
}
  , OP = class {
    constructor(e, t) {
        this.update = e,
        this.deps = t
    }
    eventObserved(e) {
        e.type == "change" && mt.write(this.update)
    }
}
;
function DP(n, e) {
    const t = new Set;
    return Eh.dependencies = t,
    n.style && (n = {
        ...n,
        style: e.createAnimatedStyle(n.style)
    }),
    n = new Lp(n),
    Eh.dependencies = null,
    [n, t]
}
function UP(n, e) {
    return n && (Se.fun(n) ? n(e) : n.current = e),
    e
}
var M2 = Symbol.for("AnimatedComponent")
  , FP = (n, {applyAnimatedValues: e= () => !1, createAnimatedStyle: t=r => new Lp(r), getComponentProps: i=r => r}={}) => {
    const r = {
        applyAnimatedValues: e,
        createAnimatedStyle: t,
        getComponentProps: i
    }
      , s = o => {
        const l = w2(o) || "Anonymous";
        return Se.str(o) ? o = s[o] || (s[o] = S2(o, r)) : o = o[M2] || (o[M2] = S2(o, r)),
        o.displayName = `Animated(${l})`,
        o
    }
    ;
    return Or(n, (o, l) => {
        Se.arr(n) && (l = w2(o)),
        s[l] = s(o)
    }
    ),
    {
        animated: s
    }
}
  , w2 = n => Se.str(n) ? n : n && Se.str(n.displayName) ? n.displayName : Se.fun(n) && n.name || null
  , kP = class {
}
;
function ei(n, ...e) {
    return Se.fun(n) ? n(...e) : n
}
var bc = (n, e) => n === !0 || !!(e && n && (Se.fun(n) ? n(e) : ni(n).includes(e)))
  , ow = (n, e) => Se.obj(n) ? e && n[e] : n
  , aw = (n, e) => n.default === !0 ? n[e] : n.default ? n.default[e] : void 0
  , BP = n => n
  , Np = (n, e=BP) => {
    let t = zP;
    n.default && n.default !== !0 && (n = n.default,
    t = Object.keys(n));
    const i = {};
    for (const r of t) {
        const s = e(n[r], r);
        Se.und(s) || (i[r] = s)
    }
    return i
}
  , zP = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"]
  , VP = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
};
function HP(n) {
    const e = {};
    let t = 0;
    if (Or(n, (i, r) => {
        VP[r] || (e[r] = i,
        t++)
    }
    ),
    t)
        return e
}
function Op(n) {
    const e = HP(n);
    if (e) {
        const t = {
            to: e
        };
        return Or(n, (i, r) => r in e || (t[r] = i)),
        t
    }
    return {
        ...n
    }
}
function Yc(n) {
    return n = di(n),
    Se.arr(n) ? n.map(Yc) : Rp(n) ? $i.createStringInterpolator({
        range: [0, 1],
        output: [n, n]
    })(1) : n
}
function lw(n) {
    for (const e in n)
        return !0;
    return !1
}
function _1(n) {
    return Se.fun(n) || Se.arr(n) && Se.obj(n[0])
}
function y1(n, e) {
    var t;
    (t = n.ref) == null || t.delete(n),
    e == null || e.delete(n)
}
function Bv(n, e) {
    var t;
    e && n.ref !== e && ((t = n.ref) == null || t.delete(n),
    e.add(n),
    n.ref = e)
}
function GP(n, e, t=1e3) {
    pi( () => {
        if (e) {
            let i = 0;
            rt(n, (r, s) => {
                const o = r.current;
                if (o.length) {
                    let l = t * e[s];
                    isNaN(l) ? l = i : i = l,
                    rt(o, u => {
                        rt(u.queue, f => {
                            const d = f.delay;
                            f.delay = h => l + ei(d || 0, h)
                        }
                        )
                    }
                    ),
                    r.start()
                }
            }
            )
        } else {
            let i = Promise.resolve();
            rt(n, r => {
                const s = r.current;
                if (s.length) {
                    const o = s.map(l => {
                        const u = l.queue;
                        return l.queue = [],
                        u
                    }
                    );
                    i = i.then( () => (rt(s, (l, u) => rt(o[u] || [], f => l.queue.push(f))),
                    Promise.all(r.start())))
                }
            }
            )
        }
    }
    )
}
var cw = {
    default: {
        tension: 170,
        friction: 26
    },
    gentle: {
        tension: 120,
        friction: 14
    },
    wobbly: {
        tension: 180,
        friction: 12
    },
    stiff: {
        tension: 210,
        friction: 20
    },
    slow: {
        tension: 280,
        friction: 60
    },
    molasses: {
        tension: 280,
        friction: 120
    }
}
  , S1 = {
    ...cw.default,
    mass: 1,
    damping: 1,
    easing: Z3.linear,
    clamp: !1
}
  , WP = class {
    constructor() {
        this.velocity = 0,
        Object.assign(this, S1)
    }
}
;
function jP(n, e, t) {
    t && (t = {
        ...t
    },
    b2(t, e),
    e = {
        ...t,
        ...e
    }),
    b2(n, e),
    Object.assign(n, e);
    for (const o in S1)
        n[o] == null && (n[o] = S1[o]);
    let {frequency: i, damping: r} = n;
    const {mass: s} = n;
    return Se.und(i) || (i < .01 && (i = .01),
    r < 0 && (r = 0),
    n.tension = Math.pow(2 * Math.PI / i, 2) * s,
    n.friction = 4 * Math.PI * r * s / i),
    n
}
function b2(n, e) {
    if (!Se.und(e.decay))
        n.duration = void 0;
    else {
        const t = !Se.und(e.tension) || !Se.und(e.friction);
        (t || !Se.und(e.frequency) || !Se.und(e.damping) || !Se.und(e.mass)) && (n.duration = void 0,
        n.decay = void 0),
        t && (n.frequency = void 0)
    }
}
var E2 = []
  , XP = class {
    constructor() {
        this.changed = !1,
        this.values = E2,
        this.toValues = null,
        this.fromValues = E2,
        this.config = new WP,
        this.immediate = !1
    }
}
;
function uw(n, {key: e, props: t, defaultProps: i, state: r, actions: s}) {
    return new Promise( (o, l) => {
        let u, f, d = bc(t.cancel ?? (i == null ? void 0 : i.cancel), e);
        if (d)
            g();
        else {
            Se.und(t.pause) || (r.paused = bc(t.pause, e));
            let x = i == null ? void 0 : i.pause;
            x !== !0 && (x = r.paused || bc(x, e)),
            u = ei(t.delay || 0, e),
            x ? (r.resumeQueue.add(m),
            s.pause()) : (s.resume(),
            m())
        }
        function h() {
            r.resumeQueue.add(m),
            r.timeouts.delete(f),
            f.cancel(),
            u = f.time - mt.now()
        }
        function m() {
            u > 0 && !$i.skipAnimation ? (r.delayed = !0,
            f = mt.setTimeout(g, u),
            r.pauseQueue.add(h),
            r.timeouts.add(f)) : g()
        }
        function g() {
            r.delayed && (r.delayed = !1),
            r.pauseQueue.delete(h),
            r.timeouts.delete(f),
            n <= (r.cancelId || 0) && (d = !0);
            try {
                s.start({
                    ...t,
                    callId: n,
                    cancel: d
                }, o)
            } catch (x) {
                l(x)
            }
        }
    }
    )
}
var zv = (n, e) => e.length == 1 ? e[0] : e.some(t => t.cancelled) ? el(n.get()) : e.every(t => t.noop) ? fw(n.get()) : or(n.get(), e.every(t => t.finished))
  , fw = n => ({
    value: n,
    noop: !0,
    finished: !0,
    cancelled: !1
})
  , or = (n, e, t=!1) => ({
    value: n,
    finished: e,
    cancelled: t
})
  , el = n => ({
    value: n,
    cancelled: !0,
    finished: !1
});
function dw(n, e, t, i) {
    const {callId: r, parentId: s, onRest: o} = e
      , {asyncTo: l, promise: u} = t;
    return !s && n === l && !e.reset ? u : t.promise = (async () => {
        t.asyncId = r,
        t.asyncTo = n;
        const f = Np(e, (_, v) => v === "onRest" ? void 0 : _);
        let d, h;
        const m = new Promise( (_, v) => (d = _,
        h = v))
          , g = _ => {
            const v = r <= (t.cancelId || 0) && el(i) || r !== t.asyncId && or(i, !1);
            if (v)
                throw _.result = v,
                h(_),
                _
        }
          , x = (_, v) => {
            const M = new M1
              , w = new C2;
            return (async () => {
                if ($i.skipAnimation)
                    throw Zc(t),
                    w.result = or(i, !1),
                    h(w),
                    w;
                g(M);
                const E = Se.obj(_) ? {
                    ..._
                } : {
                    ...v,
                    to: _
                };
                E.parentId = r,
                Or(f, (R, A) => {
                    Se.und(E[A]) && (E[A] = R)
                }
                );
                const O = await i.start(E);
                return g(M),
                t.paused && await new Promise(R => {
                    t.resumeQueue.add(R)
                }
                ),
                O
            }
            )()
        }
        ;
        let S;
        if ($i.skipAnimation)
            return Zc(t),
            or(i, !1);
        try {
            let _;
            Se.arr(n) ? _ = (async v => {
                for (const M of v)
                    await x(M)
            }
            )(n) : _ = Promise.resolve(n(x, i.stop.bind(i))),
            await Promise.all([_.then(d), m]),
            S = or(i.get(), !0, !1)
        } catch (_) {
            if (_ instanceof M1)
                S = _.result;
            else if (_ instanceof C2)
                S = _.result;
            else
                throw _
        } finally {
            r == t.asyncId && (t.asyncId = s,
            t.asyncTo = s ? l : void 0,
            t.promise = s ? u : void 0)
        }
        return Se.fun(o) && mt.batchedUpdates( () => {
            o(S, i, i.item)
        }
        ),
        S
    }
    )()
}
function Zc(n, e) {
    Mc(n.timeouts, t => t.cancel()),
    n.pauseQueue.clear(),
    n.resumeQueue.clear(),
    n.asyncId = n.asyncTo = n.promise = void 0,
    e && (n.cancelId = e)
}
var M1 = class extends Error {
    constructor() {
        super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.")
    }
}
  , C2 = class extends Error {
    constructor() {
        super("SkipAnimationSignal")
    }
}
  , w1 = n => n instanceof Dp
  , $P = 1
  , Dp = class extends K3 {
    constructor() {
        super(...arguments),
        this.id = $P++,
        this._priority = 0
    }
    get priority() {
        return this._priority
    }
    set priority(e) {
        this._priority != e && (this._priority = e,
        this._onPriorityChange(e))
    }
    get() {
        const e = Mr(this);
        return e && e.getValue()
    }
    to(...e) {
        return $i.to(this, e)
    }
    interpolate(...e) {
        return nw(),
        $i.to(this, e)
    }
    toJSON() {
        return this.get()
    }
    observerAdded(e) {
        e == 1 && this._attach()
    }
    observerRemoved(e) {
        e == 0 && this._detach()
    }
    _attach() {}
    _detach() {}
    _onChange(e, t=!1) {
        jc(this, {
            type: "change",
            parent: this,
            value: e,
            idle: t
        })
    }
    _onPriorityChange(e) {
        this.idle || Ru.sort(this),
        jc(this, {
            type: "priority",
            parent: this,
            priority: e
        })
    }
}
  , Bo = Symbol.for("SpringPhase")
  , hw = 1
  , b1 = 2
  , E1 = 4
  , Y0 = n => (n[Bo] & hw) > 0
  , Ms = n => (n[Bo] & b1) > 0
  , tc = n => (n[Bo] & E1) > 0
  , T2 = (n, e) => e ? n[Bo] |= b1 | hw : n[Bo] &= ~b1
  , A2 = (n, e) => e ? n[Bo] |= E1 : n[Bo] &= ~E1
  , Vv = class extends Dp {
    constructor(n, e) {
        if (super(),
        this.animation = new XP,
        this.defaultProps = {},
        this._state = {
            paused: !1,
            delayed: !1,
            pauseQueue: new Set,
            resumeQueue: new Set,
            timeouts: new Set
        },
        this._pendingCalls = new Set,
        this._lastCallId = 0,
        this._lastToId = 0,
        this._memoizedDuration = 0,
        !Se.und(n) || !Se.und(e)) {
            const t = Se.obj(n) ? {
                ...n
            } : {
                ...e,
                from: n
            };
            Se.und(t.default) && (t.default = !0),
            this.start(t)
        }
    }
    get idle() {
        return !(Ms(this) || this._state.asyncTo) || tc(this)
    }
    get goal() {
        return di(this.animation.to)
    }
    get velocity() {
        const n = Mr(this);
        return n instanceof Pu ? n.lastVelocity || 0 : n.getPayload().map(e => e.lastVelocity || 0)
    }
    get hasAnimated() {
        return Y0(this)
    }
    get isAnimating() {
        return Ms(this)
    }
    get isPaused() {
        return tc(this)
    }
    get isDelayed() {
        return this._state.delayed
    }
    advance(n) {
        let e = !0
          , t = !1;
        const i = this.animation;
        let {toValues: r} = i;
        const {config: s} = i
          , o = Ip(i.to);
        !o && Gi(i.to) && (r = ni(di(i.to))),
        i.values.forEach( (f, d) => {
            if (f.done)
                return;
            const h = f.constructor == qc ? 1 : o ? o[d].lastPosition : r[d];
            let m = i.immediate
              , g = h;
            if (!m) {
                if (g = f.lastPosition,
                s.tension <= 0) {
                    f.done = !0;
                    return
                }
                let x = f.elapsedTime += n;
                const S = i.fromValues[d]
                  , _ = f.v0 != null ? f.v0 : f.v0 = Se.arr(s.velocity) ? s.velocity[d] : s.velocity;
                let v;
                const M = s.precision || (S == h ? .005 : Math.min(1, Math.abs(h - S) * .001));
                if (Se.und(s.duration))
                    if (s.decay) {
                        const w = s.decay === !0 ? .998 : s.decay
                          , E = Math.exp(-(1 - w) * x);
                        g = S + _ / (1 - w) * (1 - E),
                        m = Math.abs(f.lastPosition - g) <= M,
                        v = _ * E
                    } else {
                        v = f.lastVelocity == null ? _ : f.lastVelocity;
                        const w = s.restVelocity || M / 10
                          , E = s.clamp ? 0 : s.bounce
                          , O = !Se.und(E)
                          , R = S == h ? f.v0 > 0 : S < h;
                        let A, F = !1;
                        const I = 1
                          , P = Math.ceil(n / I);
                        for (let D = 0; D < P && (A = Math.abs(v) > w,
                        !(!A && (m = Math.abs(h - g) <= M,
                        m))); ++D) {
                            O && (F = g == h || g > h == R,
                            F && (v = -v * E,
                            g = h));
                            const W = -s.tension * 1e-6 * (g - h)
                              , X = -s.friction * .001 * v
                              , G = (W + X) / s.mass;
                            v = v + G * I,
                            g = g + v * I
                        }
                    }
                else {
                    let w = 1;
                    s.duration > 0 && (this._memoizedDuration !== s.duration && (this._memoizedDuration = s.duration,
                    f.durationProgress > 0 && (f.elapsedTime = s.duration * f.durationProgress,
                    x = f.elapsedTime += n)),
                    w = (s.progress || 0) + x / this._memoizedDuration,
                    w = w > 1 ? 1 : w < 0 ? 0 : w,
                    f.durationProgress = w),
                    g = S + s.easing(w) * (h - S),
                    v = (g - f.lastPosition) / n,
                    m = w == 1
                }
                f.lastVelocity = v,
                Number.isNaN(g) && (console.warn("Got NaN while animating:", this),
                m = !0)
            }
            o && !o[d].done && (m = !1),
            m ? f.done = !0 : e = !1,
            f.setValue(g, s.round) && (t = !0)
        }
        );
        const l = Mr(this)
          , u = l.getValue();
        if (e) {
            const f = di(i.to);
            (u !== f || t) && !s.decay ? (l.setValue(f),
            this._onChange(f)) : t && s.decay && this._onChange(u),
            this._stop()
        } else
            t && this._onChange(u)
    }
    set(n) {
        return mt.batchedUpdates( () => {
            this._stop(),
            this._focus(n),
            this._set(n)
        }
        ),
        this
    }
    pause() {
        this._update({
            pause: !0
        })
    }
    resume() {
        this._update({
            pause: !1
        })
    }
    finish() {
        if (Ms(this)) {
            const {to: n, config: e} = this.animation;
            mt.batchedUpdates( () => {
                this._onStart(),
                e.decay || this._set(n, !1),
                this._stop()
            }
            )
        }
        return this
    }
    update(n) {
        return (this.queue || (this.queue = [])).push(n),
        this
    }
    start(n, e) {
        let t;
        return Se.und(n) ? (t = this.queue || [],
        this.queue = []) : t = [Se.obj(n) ? n : {
            ...e,
            to: n
        }],
        Promise.all(t.map(i => this._update(i))).then(i => zv(this, i))
    }
    stop(n) {
        const {to: e} = this.animation;
        return this._focus(this.get()),
        Zc(this._state, n && this._lastCallId),
        mt.batchedUpdates( () => this._stop(e, n)),
        this
    }
    reset() {
        this._update({
            reset: !0
        })
    }
    eventObserved(n) {
        n.type == "change" ? this._start() : n.type == "priority" && (this.priority = n.priority + 1)
    }
    _prepareNode(n) {
        const e = this.key || "";
        let {to: t, from: i} = n;
        t = Se.obj(t) ? t[e] : t,
        (t == null || _1(t)) && (t = void 0),
        i = Se.obj(i) ? i[e] : i,
        i == null && (i = void 0);
        const r = {
            to: t,
            from: i
        };
        return Y0(this) || (n.reverse && ([t,i] = [i, t]),
        i = di(i),
        Se.und(i) ? Mr(this) || this._set(t) : this._set(i)),
        r
    }
    _update({...n}, e) {
        const {key: t, defaultProps: i} = this;
        n.default && Object.assign(i, Np(n, (o, l) => /^on/.test(l) ? ow(o, t) : o)),
        P2(this, n, "onProps"),
        ic(this, "onProps", n, this);
        const r = this._prepareNode(n);
        if (Object.isFrozen(this))
            throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
        const s = this._state;
        return uw(++this._lastCallId, {
            key: t,
            props: n,
            defaultProps: i,
            state: s,
            actions: {
                pause: () => {
                    tc(this) || (A2(this, !0),
                    _c(s.pauseQueue),
                    ic(this, "onPause", or(this, nc(this, this.animation.to)), this))
                }
                ,
                resume: () => {
                    tc(this) && (A2(this, !1),
                    Ms(this) && this._resume(),
                    _c(s.resumeQueue),
                    ic(this, "onResume", or(this, nc(this, this.animation.to)), this))
                }
                ,
                start: this._merge.bind(this, r)
            }
        }).then(o => {
            if (n.loop && o.finished && !(e && o.noop)) {
                const l = pw(n);
                if (l)
                    return this._update(l, !0)
            }
            return o
        }
        )
    }
    _merge(n, e, t) {
        if (e.cancel)
            return this.stop(!0),
            t(el(this));
        const i = !Se.und(n.to)
          , r = !Se.und(n.from);
        if (i || r)
            if (e.callId > this._lastToId)
                this._lastToId = e.callId;
            else
                return t(el(this));
        const {key: s, defaultProps: o, animation: l} = this
          , {to: u, from: f} = l;
        let {to: d=u, from: h=f} = n;
        r && !i && (!e.default || Se.und(d)) && (d = h),
        e.reverse && ([d,h] = [h, d]);
        const m = !Qr(h, f);
        m && (l.from = h),
        h = di(h);
        const g = !Qr(d, u);
        g && this._focus(d);
        const x = _1(e.to)
          , {config: S} = l
          , {decay: _, velocity: v} = S;
        (i || r) && (S.velocity = 0),
        e.config && !x && jP(S, ei(e.config, s), e.config !== o.config ? ei(o.config, s) : void 0);
        let M = Mr(this);
        if (!M || Se.und(d))
            return t(or(this, !0));
        const w = Se.und(e.reset) ? r && !e.default : !Se.und(h) && bc(e.reset, s)
          , E = w ? h : this.get()
          , O = Yc(d)
          , R = Se.num(O) || Se.arr(O) || Rp(O)
          , A = !x && (!R || bc(o.immediate || e.immediate, s));
        if (g) {
            const D = x1(d);
            if (D !== M.constructor)
                if (A)
                    M = this._set(O);
                else
                    throw Error(`Cannot animate between ${M.constructor.name} and ${D.name}, as the "to" prop suggests`)
        }
        const F = M.constructor;
        let I = Gi(d)
          , P = !1;
        if (!I) {
            const D = w || !Y0(this) && m;
            (g || D) && (P = Qr(Yc(E), O),
            I = !P),
            (!Qr(l.immediate, A) && !A || !Qr(S.decay, _) || !Qr(S.velocity, v)) && (I = !0)
        }
        if (P && Ms(this) && (l.changed && !w ? I = !0 : I || this._stop(u)),
        !x && ((I || Gi(u)) && (l.values = M.getPayload(),
        l.toValues = Gi(d) ? null : F == qc ? [1] : ni(O)),
        l.immediate != A && (l.immediate = A,
        !A && !w && this._set(u)),
        I)) {
            const {onRest: D} = l;
            rt(YP, X => P2(this, e, X));
            const W = or(this, nc(this, u));
            _c(this._pendingCalls, W),
            this._pendingCalls.add(t),
            l.changed && mt.batchedUpdates( () => {
                var X;
                l.changed = !w,
                D == null || D(W, this),
                w ? ei(o.onRest, W) : (X = l.onStart) == null || X.call(l, W, this)
            }
            )
        }
        w && this._set(E),
        x ? t(dw(e.to, e, this._state, this)) : I ? this._start() : Ms(this) && !g ? this._pendingCalls.add(t) : t(fw(E))
    }
    _focus(n) {
        const e = this.animation;
        n !== e.to && (v2(this) && this._detach(),
        e.to = n,
        v2(this) && this._attach())
    }
    _attach() {
        let n = 0;
        const {to: e} = this.animation;
        Gi(e) && (Sl(e, this),
        w1(e) && (n = e.priority + 1)),
        this.priority = n
    }
    _detach() {
        const {to: n} = this.animation;
        Gi(n) && Xc(n, this)
    }
    _set(n, e=!0) {
        const t = di(n);
        if (!Se.und(t)) {
            const i = Mr(this);
            if (!i || !Qr(t, i.getValue())) {
                const r = x1(t);
                !i || i.constructor != r ? kv(this, r.create(t)) : i.setValue(t),
                i && mt.batchedUpdates( () => {
                    this._onChange(t, e)
                }
                )
            }
        }
        return Mr(this)
    }
    _onStart() {
        const n = this.animation;
        n.changed || (n.changed = !0,
        ic(this, "onStart", or(this, nc(this, n.to)), this))
    }
    _onChange(n, e) {
        e || (this._onStart(),
        ei(this.animation.onChange, n, this)),
        ei(this.defaultProps.onChange, n, this),
        super._onChange(n, e)
    }
    _start() {
        const n = this.animation;
        Mr(this).reset(di(n.to)),
        n.immediate || (n.fromValues = n.values.map(e => e.lastPosition)),
        Ms(this) || (T2(this, !0),
        tc(this) || this._resume())
    }
    _resume() {
        $i.skipAnimation ? this.finish() : Ru.start(this)
    }
    _stop(n, e) {
        if (Ms(this)) {
            T2(this, !1);
            const t = this.animation;
            rt(t.values, r => {
                r.done = !0
            }
            ),
            t.toValues && (t.onChange = t.onPause = t.onResume = void 0),
            jc(this, {
                type: "idle",
                parent: this
            });
            const i = e ? el(this.get()) : or(this.get(), nc(this, n ?? t.to));
            _c(this._pendingCalls, i),
            t.changed && (t.changed = !1,
            ic(this, "onRest", i, this))
        }
    }
}
;
function nc(n, e) {
    const t = Yc(e)
      , i = Yc(n.get());
    return Qr(i, t)
}
function pw(n, e=n.loop, t=n.to) {
    const i = ei(e);
    if (i) {
        const r = i !== !0 && Op(i)
          , s = (r || n).reverse
          , o = !r || r.reset;
        return Kc({
            ...n,
            loop: e,
            default: !1,
            pause: void 0,
            to: !s || _1(t) ? t : void 0,
            from: o ? n.from : void 0,
            reset: o,
            ...r
        })
    }
}
function Kc(n) {
    const {to: e, from: t} = n = Op(n)
      , i = new Set;
    return Se.obj(e) && R2(e, i),
    Se.obj(t) && R2(t, i),
    n.keys = i.size ? Array.from(i) : null,
    n
}
function qP(n) {
    const e = Kc(n);
    return Se.und(e.default) && (e.default = Np(e)),
    e
}
function R2(n, e) {
    Or(n, (t, i) => t != null && e.add(i))
}
var YP = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function P2(n, e, t) {
    n.animation[t] = e[t] !== aw(e, t) ? ow(e[t], n.key) : void 0
}
function ic(n, e, ...t) {
    var i, r, s, o;
    (r = (i = n.animation)[e]) == null || r.call(i, ...t),
    (o = (s = n.defaultProps)[e]) == null || o.call(s, ...t)
}
var ZP = ["onStart", "onChange", "onRest"]
  , KP = 1
  , Hv = class {
    constructor(n, e) {
        this.id = KP++,
        this.springs = {},
        this.queue = [],
        this._lastAsyncId = 0,
        this._active = new Set,
        this._changed = new Set,
        this._started = !1,
        this._state = {
            paused: !1,
            pauseQueue: new Set,
            resumeQueue: new Set,
            timeouts: new Set
        },
        this._events = {
            onStart: new Map,
            onChange: new Map,
            onRest: new Map
        },
        this._onFrame = this._onFrame.bind(this),
        e && (this._flush = e),
        n && this.start({
            default: !0,
            ...n
        })
    }
    get idle() {
        return !this._state.asyncTo && Object.values(this.springs).every(n => n.idle && !n.isDelayed && !n.isPaused)
    }
    get item() {
        return this._item
    }
    set item(n) {
        this._item = n
    }
    get() {
        const n = {};
        return this.each( (e, t) => n[t] = e.get()),
        n
    }
    set(n) {
        for (const e in n) {
            const t = n[e];
            Se.und(t) || this.springs[e].set(t)
        }
    }
    update(n) {
        return n && this.queue.push(Kc(n)),
        this
    }
    start(n) {
        let {queue: e} = this;
        return n ? e = ni(n).map(Kc) : this.queue = [],
        this._flush ? this._flush(this, e) : (_w(this, e),
        C1(this, e))
    }
    stop(n, e) {
        if (n !== !!n && (e = n),
        e) {
            const t = this.springs;
            rt(ni(e), i => t[i].stop(!!n))
        } else
            Zc(this._state, this._lastAsyncId),
            this.each(t => t.stop(!!n));
        return this
    }
    pause(n) {
        if (Se.und(n))
            this.start({
                pause: !0
            });
        else {
            const e = this.springs;
            rt(ni(n), t => e[t].pause())
        }
        return this
    }
    resume(n) {
        if (Se.und(n))
            this.start({
                pause: !1
            });
        else {
            const e = this.springs;
            rt(ni(n), t => e[t].resume())
        }
        return this
    }
    each(n) {
        Or(this.springs, n)
    }
    _onFrame() {
        const {onStart: n, onChange: e, onRest: t} = this._events
          , i = this._active.size > 0
          , r = this._changed.size > 0;
        (i && !this._started || r && !this._started) && (this._started = !0,
        Mc(n, ([l,u]) => {
            u.value = this.get(),
            l(u, this, this._item)
        }
        ));
        const s = !i && this._started
          , o = r || s && t.size ? this.get() : null;
        r && e.size && Mc(e, ([l,u]) => {
            u.value = o,
            l(u, this, this._item)
        }
        ),
        s && (this._started = !1,
        Mc(t, ([l,u]) => {
            u.value = o,
            l(u, this, this._item)
        }
        ))
    }
    eventObserved(n) {
        if (n.type == "change")
            this._changed.add(n.parent),
            n.idle || this._active.add(n.parent);
        else if (n.type == "idle")
            this._active.delete(n.parent);
        else
            return;
        mt.onFrame(this._onFrame)
    }
}
;
function C1(n, e) {
    return Promise.all(e.map(t => mw(n, t))).then(t => zv(n, t))
}
async function mw(n, e, t) {
    const {keys: i, to: r, from: s, loop: o, onRest: l, onResolve: u} = e
      , f = Se.obj(e.default) && e.default;
    o && (e.loop = !1),
    r === !1 && (e.to = null),
    s === !1 && (e.from = null);
    const d = Se.arr(r) || Se.fun(r) ? r : void 0;
    d ? (e.to = void 0,
    e.onRest = void 0,
    f && (f.onRest = void 0)) : rt(ZP, S => {
        const _ = e[S];
        if (Se.fun(_)) {
            const v = n._events[S];
            e[S] = ({finished: M, cancelled: w}) => {
                const E = v.get(_);
                E ? (M || (E.finished = !1),
                w && (E.cancelled = !0)) : v.set(_, {
                    value: null,
                    finished: M || !1,
                    cancelled: w || !1
                })
            }
            ,
            f && (f[S] = e[S])
        }
    }
    );
    const h = n._state;
    e.pause === !h.paused ? (h.paused = e.pause,
    _c(e.pause ? h.pauseQueue : h.resumeQueue)) : h.paused && (e.pause = !0);
    const m = (i || Object.keys(n.springs)).map(S => n.springs[S].start(e))
      , g = e.cancel === !0 || aw(e, "cancel") === !0;
    (d || g && h.asyncId) && m.push(uw(++n._lastAsyncId, {
        props: e,
        state: h,
        actions: {
            pause: m1,
            resume: m1,
            start(S, _) {
                g ? (Zc(h, n._lastAsyncId),
                _(el(n))) : (S.onRest = l,
                _(dw(d, S, h, n)))
            }
        }
    })),
    h.paused && await new Promise(S => {
        h.resumeQueue.add(S)
    }
    );
    const x = zv(n, await Promise.all(m));
    if (o && x.finished && !(t && x.noop)) {
        const S = pw(e, o, r);
        if (S)
            return _w(n, [S]),
            mw(n, S, !0)
    }
    return u && mt.batchedUpdates( () => u(x, n, n.item)),
    x
}
function T1(n, e) {
    const t = {
        ...n.springs
    };
    return e && rt(ni(e), i => {
        Se.und(i.keys) && (i = Kc(i)),
        Se.obj(i.to) || (i = {
            ...i,
            to: void 0
        }),
        xw(t, i, r => vw(r))
    }
    ),
    gw(n, t),
    t
}
function gw(n, e) {
    Or(e, (t, i) => {
        n.springs[i] || (n.springs[i] = t,
        Sl(t, n))
    }
    )
}
function vw(n, e) {
    const t = new Vv;
    return t.key = n,
    e && Sl(t, e),
    t
}
function xw(n, e, t) {
    e.keys && rt(e.keys, i => {
        (n[i] || (n[i] = t(i)))._prepareNode(e)
    }
    )
}
function _w(n, e) {
    rt(e, t => {
        xw(n.springs, t, i => vw(i, n))
    }
    )
}
var Ml = ({children: n, ...e}) => {
    const t = N.useContext(Ch)
      , i = e.pause || !!t.pause
      , r = e.immediate || !!t.immediate;
    e = AP( () => ({
        pause: i,
        immediate: r
    }), [i, r]);
    const {Provider: s} = Ch;
    return N.createElement(s, {
        value: e
    }, n)
}
  , Ch = JP(Ml, {});
Ml.Provider = Ch.Provider;
Ml.Consumer = Ch.Consumer;
function JP(n, e) {
    return Object.assign(n, N.createContext(e)),
    n.Provider._context = n,
    n.Consumer._context = n,
    n
}
var Up = () => {
    const n = []
      , e = function(i) {
        vP();
        const r = [];
        return rt(n, (s, o) => {
            if (Se.und(i))
                r.push(s.start());
            else {
                const l = t(i, s, o);
                l && r.push(s.start(l))
            }
        }
        ),
        r
    };
    e.current = n,
    e.add = function(i) {
        n.includes(i) || n.push(i)
    }
    ,
    e.delete = function(i) {
        const r = n.indexOf(i);
        ~r && n.splice(r, 1)
    }
    ,
    e.pause = function() {
        return rt(n, i => i.pause(...arguments)),
        this
    }
    ,
    e.resume = function() {
        return rt(n, i => i.resume(...arguments)),
        this
    }
    ,
    e.set = function(i) {
        rt(n, (r, s) => {
            const o = Se.fun(i) ? i(s, r) : i;
            o && r.set(o)
        }
        )
    }
    ,
    e.start = function(i) {
        const r = [];
        return rt(n, (s, o) => {
            if (Se.und(i))
                r.push(s.start());
            else {
                const l = this._getProps(i, s, o);
                l && r.push(s.start(l))
            }
        }
        ),
        r
    }
    ,
    e.stop = function() {
        return rt(n, i => i.stop(...arguments)),
        this
    }
    ,
    e.update = function(i) {
        return rt(n, (r, s) => r.update(this._getProps(i, r, s))),
        this
    }
    ;
    const t = function(i, r, s) {
        return Se.fun(i) ? i(s, r) : i
    };
    return e._getProps = t,
    e
}
;
function Gv(n, e, t) {
    const i = Se.fun(e) && e;
    i && !t && (t = []);
    const r = N.useMemo( () => i || arguments.length == 3 ? Up() : void 0, [])
      , s = N.useRef(0)
      , o = Fv()
      , l = N.useMemo( () => ({
        ctrls: [],
        queue: [],
        flush(v, M) {
            const w = T1(v, M);
            return s.current > 0 && !l.queue.length && !Object.keys(w).some(O => !v.springs[O]) ? C1(v, M) : new Promise(O => {
                gw(v, w),
                l.queue.push( () => {
                    O(C1(v, M))
                }
                ),
                o()
            }
            )
        }
    }), [])
      , u = N.useRef([...l.ctrls])
      , f = []
      , d = v1(n) || 0;
    N.useMemo( () => {
        rt(u.current.slice(n, d), v => {
            y1(v, r),
            v.stop(!0)
        }
        ),
        u.current.length = n,
        h(d, n)
    }
    , [n]),
    N.useMemo( () => {
        h(0, Math.min(d, n))
    }
    , t);
    function h(v, M) {
        for (let w = v; w < M; w++) {
            const E = u.current[w] || (u.current[w] = new Hv(null,l.flush))
              , O = i ? i(w, E) : e[w];
            O && (f[w] = qP(O))
        }
    }
    const m = u.current.map( (v, M) => T1(v, f[M]))
      , g = N.useContext(Ml)
      , x = v1(g)
      , S = g !== x && lw(g);
    pi( () => {
        s.current++,
        l.ctrls = u.current;
        const {queue: v} = l;
        v.length && (l.queue = [],
        rt(v, M => M())),
        rt(u.current, (M, w) => {
            r == null || r.add(M),
            S && M.start({
                default: g
            });
            const E = f[w];
            E && (Bv(M, E.ref),
            M.ref ? M.queue.push(E) : M.start(E))
        }
        )
    }
    ),
    Pp( () => () => {
        rt(l.ctrls, v => v.stop(!0))
    }
    );
    const _ = m.map(v => ({
        ...v
    }));
    return r ? [_, r] : _
}
function ss(n, e) {
    const t = Se.fun(n)
      , [[i],r] = Gv(1, t ? n : [n], t ? e || [] : e);
    return t || arguments.length == 2 ? [i, r] : i
}
var QP = () => Up()
  , e6 = () => N.useState(QP)[0]
  , t6 = (n, e) => {
    const t = CP( () => new Vv(n,e));
    return Pp( () => () => {
        t.stop()
    }
    ),
    t
}
;
function yw(n, e, t) {
    const i = Se.fun(e) && e;
    i && !t && (t = []);
    let r = !0, s;
    const o = Gv(n, (l, u) => {
        const f = i ? i(l, u) : e;
        return s = f.ref,
        r = r && f.reverse,
        f
    }
    , t || [{}]);
    if (pi( () => {
        rt(o[1].current, (l, u) => {
            const f = o[1].current[u + (r ? 1 : -1)];
            if (Bv(l, s),
            l.ref) {
                f && l.update({
                    to: f.springs
                });
                return
            }
            f ? l.start({
                to: f.springs
            }) : l.start()
        }
        )
    }
    , t),
    i || arguments.length == 3) {
        const l = s ?? o[1];
        return l._getProps = (u, f, d) => {
            const h = Se.fun(u) ? u(d, f) : u;
            if (h) {
                const m = l.current[d + (h.reverse ? 1 : -1)];
                return m && (h.to = m.springs),
                h
            }
        }
        ,
        o
    }
    return o[0]
}
function Sw(n, e, t) {
    const i = Se.fun(e) && e
      , {reset: r, sort: s, trail: o=0, expires: l=!0, exitBeforeEnter: u=!1, onDestroyed: f, ref: d, config: h} = i ? i() : e
      , m = N.useMemo( () => i || arguments.length == 3 ? Up() : void 0, [])
      , g = ni(n)
      , x = []
      , S = N.useRef(null)
      , _ = r ? null : S.current;
    pi( () => {
        S.current = x
    }
    ),
    Pp( () => (rt(x, G => {
        m == null || m.add(G.ctrl),
        G.ctrl.ref = m
    }
    ),
    () => {
        rt(S.current, G => {
            G.expired && clearTimeout(G.expirationId),
            y1(G.ctrl, m),
            G.ctrl.stop(!0)
        }
        )
    }
    ));
    const v = i6(g, i ? i() : e, _)
      , M = r && S.current || [];
    pi( () => rt(M, ({ctrl: G, item: q, key: K}) => {
        y1(G, m),
        ei(f, q, K)
    }
    ));
    const w = [];
    if (_ && rt(_, (G, q) => {
        G.expired ? (clearTimeout(G.expirationId),
        M.push(G)) : (q = w[q] = v.indexOf(G.key),
        ~q && (x[q] = G))
    }
    ),
    rt(g, (G, q) => {
        x[q] || (x[q] = {
            key: v[q],
            item: G,
            phase: "mount",
            ctrl: new Hv
        },
        x[q].ctrl.item = G)
    }
    ),
    w.length) {
        let G = -1;
        const {leave: q} = i ? i() : e;
        rt(w, (K, oe) => {
            const z = _[oe];
            ~K ? (G = x.indexOf(z),
            x[G] = {
                ...z,
                item: g[K]
            }) : q && x.splice(++G, 0, z)
        }
        )
    }
    Se.fun(s) && x.sort( (G, q) => s(G.item, q.item));
    let E = -o;
    const O = Fv()
      , R = Np(e)
      , A = new Map
      , F = N.useRef(new Map)
      , I = N.useRef(!1);
    rt(x, (G, q) => {
        const K = G.key
          , oe = G.phase
          , z = i ? i() : e;
        let ee, Q;
        const ce = ei(z.delay || 0, K);
        if (oe == "mount")
            ee = z.enter,
            Q = "enter";
        else {
            const ue = v.indexOf(K) < 0;
            if (oe != "leave")
                if (ue)
                    ee = z.leave,
                    Q = "leave";
                else if (ee = z.update)
                    Q = "update";
                else
                    return;
            else if (!ue)
                ee = z.enter,
                Q = "enter";
            else
                return
        }
        if (ee = ei(ee, G.item, q),
        ee = Se.obj(ee) ? Op(ee) : {
            to: ee
        },
        !ee.config) {
            const ue = h || R.config;
            ee.config = ei(ue, G.item, q, Q)
        }
        E += o;
        const be = {
            ...R,
            delay: ce + E,
            ref: d,
            immediate: z.immediate,
            reset: !1,
            ...ee
        };
        if (Q == "enter" && Se.und(be.from)) {
            const ue = i ? i() : e
              , Te = Se.und(ue.initial) || _ ? ue.from : ue.initial;
            be.from = ei(Te, G.item, q)
        }
        const {onResolve: Ue} = be;
        be.onResolve = ue => {
            ei(Ue, ue);
            const Te = S.current
              , Me = Te.find(Ye => Ye.key === K);
            if (Me && !(ue.cancelled && Me.phase != "update") && Me.ctrl.idle) {
                const Ye = Te.every(Qe => Qe.ctrl.idle);
                if (Me.phase == "leave") {
                    const Qe = ei(l, Me.item);
                    if (Qe !== !1) {
                        const ze = Qe === !0 ? 0 : Qe;
                        if (Me.expired = !0,
                        !Ye && ze > 0) {
                            ze <= 2147483647 && (Me.expirationId = setTimeout(O, ze));
                            return
                        }
                    }
                }
                Ye && Te.some(Qe => Qe.expired) && (F.current.delete(Me),
                u && (I.current = !0),
                O())
            }
        }
        ;
        const se = T1(G.ctrl, be);
        Q === "leave" && u ? F.current.set(G, {
            phase: Q,
            springs: se,
            payload: be
        }) : A.set(G, {
            phase: Q,
            springs: se,
            payload: be
        })
    }
    );
    const P = N.useContext(Ml)
      , D = v1(P)
      , W = P !== D && lw(P);
    pi( () => {
        W && rt(x, G => {
            G.ctrl.start({
                default: P
            })
        }
        )
    }
    , [P]),
    rt(A, (G, q) => {
        if (F.current.size) {
            const K = x.findIndex(oe => oe.key === q.key);
            x.splice(K, 1)
        }
    }
    ),
    pi( () => {
        rt(F.current.size ? F.current : A, ({phase: G, payload: q}, K) => {
            const {ctrl: oe} = K;
            K.phase = G,
            m == null || m.add(oe),
            W && G == "enter" && oe.start({
                default: P
            }),
            q && (Bv(oe, q.ref),
            (oe.ref || m) && !I.current ? oe.update(q) : (oe.start(q),
            I.current && (I.current = !1)))
        }
        )
    }
    , r ? void 0 : t);
    const X = G => N.createElement(N.Fragment, null, x.map( (q, K) => {
        const {springs: oe} = A.get(q) || q.ctrl
          , z = G({
            ...oe
        }, q.item, q, K);
        return z && z.type ? N.createElement(z.type, {
            ...z.props,
            key: Se.str(q.key) || Se.num(q.key) ? q.key : q.ctrl.id,
            ref: z.ref
        }) : z
    }
    ));
    return m ? [X, m] : X
}
var n6 = 1;
function i6(n, {key: e, keys: t=e}, i) {
    if (t === null) {
        const r = new Set;
        return n.map(s => {
            const o = i && i.find(l => l.item === s && l.phase !== "leave" && !r.has(l));
            return o ? (r.add(o),
            o.key) : n6++
        }
        )
    }
    return Se.und(t) ? n : Se.fun(t) ? n.map(t) : ni(t)
}
var r6 = ({container: n, ...e}={}) => {
    const [t,i] = ss( () => ({
        scrollX: 0,
        scrollY: 0,
        scrollXProgress: 0,
        scrollYProgress: 0,
        ...e
    }), []);
    return pi( () => {
        const r = EP( ({x: s, y: o}) => {
            i.start({
                scrollX: s.current,
                scrollXProgress: s.progress,
                scrollY: o.current,
                scrollYProgress: o.progress
            })
        }
        , {
            container: (n == null ? void 0 : n.current) || void 0
        });
        return () => {
            rt(Object.values(t), s => s.stop()),
            r()
        }
    }
    , []),
    t
}
  , s6 = ({container: n, ...e}) => {
    const [t,i] = ss( () => ({
        width: 0,
        height: 0,
        ...e
    }), []);
    return pi( () => {
        const r = iw( ({width: s, height: o}) => {
            i.start({
                width: s,
                height: o,
                immediate: t.width.get() === 0 || t.height.get() === 0
            })
        }
        , {
            container: (n == null ? void 0 : n.current) || void 0
        });
        return () => {
            rt(Object.values(t), s => s.stop()),
            r()
        }
    }
    , []),
    t
}
  , o6 = {
    any: 0,
    all: 1
};
function a6(n, e) {
    const [t,i] = N.useState(!1)
      , r = N.useRef()
      , s = Se.fun(n) && n
      , o = s ? s() : {}
      , {to: l={}, from: u={}, ...f} = o
      , d = s ? e : n
      , [h,m] = ss( () => ({
        from: u,
        ...f
    }), []);
    return pi( () => {
        const g = r.current
          , {root: x, once: S, amount: _="any", ...v} = d ?? {};
        if (!g || S && t || typeof IntersectionObserver > "u")
            return;
        const M = new WeakMap
          , w = () => (l && m.start(l),
        i(!0),
        S ? void 0 : () => {
            u && m.start(u),
            i(!1)
        }
        )
          , E = R => {
            R.forEach(A => {
                const F = M.get(A.target);
                if (A.isIntersecting !== !!F)
                    if (A.isIntersecting) {
                        const I = w();
                        Se.fun(I) ? M.set(A.target, I) : O.unobserve(A.target)
                    } else
                        F && (F(),
                        M.delete(A.target))
            }
            )
        }
          , O = new IntersectionObserver(E,{
            root: x && x.current || void 0,
            threshold: typeof _ == "number" || Array.isArray(_) ? _ : o6[_],
            ...v
        });
        return O.observe(g),
        () => O.unobserve(g)
    }
    , [d]),
    s ? [r, h] : [r, t]
}
function l6({children: n, ...e}) {
    return n(ss(e))
}
function c6({items: n, children: e, ...t}) {
    const i = yw(n.length, t);
    return n.map( (r, s) => {
        const o = e(r, s);
        return Se.fun(o) ? o(i[s]) : o
    }
    )
}
function u6({items: n, children: e, ...t}) {
    return Sw(n, t)(e)
}
var Fp = class extends Dp {
    constructor(e, t) {
        super(),
        this.source = e,
        this.idle = !0,
        this._active = new Set,
        this.calc = al(...t);
        const i = this._get()
          , r = x1(i);
        kv(this, r.create(i))
    }
    advance(e) {
        const t = this._get()
          , i = this.get();
        Qr(t, i) || (Mr(this).setValue(t),
        this._onChange(t, this.idle)),
        !this.idle && I2(this._active) && Z0(this)
    }
    _get() {
        const e = Se.arr(this.source) ? this.source.map(di) : ni(di(this.source));
        return this.calc(...e)
    }
    _start() {
        this.idle && !I2(this._active) && (this.idle = !1,
        rt(Ip(this), e => {
            e.done = !1
        }
        ),
        $i.skipAnimation ? (mt.batchedUpdates( () => this.advance()),
        Z0(this)) : Ru.start(this))
    }
    _attach() {
        let e = 1;
        rt(ni(this.source), t => {
            Gi(t) && Sl(t, this),
            w1(t) && (t.idle || this._active.add(t),
            e = Math.max(e, t.priority + 1))
        }
        ),
        this.priority = e,
        this._start()
    }
    _detach() {
        rt(ni(this.source), e => {
            Gi(e) && Xc(e, this)
        }
        ),
        this._active.clear(),
        Z0(this)
    }
    eventObserved(e) {
        e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent),
        this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = ni(this.source).reduce( (t, i) => Math.max(t, (w1(i) ? i.priority : 0) + 1), 0))
    }
}
;
function f6(n) {
    return n.idle !== !1
}
function I2(n) {
    return !n.size || Array.from(n).every(f6)
}
function Z0(n) {
    n.idle || (n.idle = !0,
    rt(Ip(n), e => {
        e.done = !0
    }
    ),
    jc(n, {
        type: "idle",
        parent: n
    }))
}
var d6 = (n, ...e) => new Fp(n,e)
  , h6 = (n, ...e) => (nw(),
new Fp(n,e));
$i.assign({
    createStringInterpolator: ew,
    to: (n, e) => new Fp(n,e)
});
var p6 = Ru.advance
  , Mw = /^--/;
function m6(n, e) {
    return e == null || typeof e == "boolean" || e === "" ? "" : typeof e == "number" && e !== 0 && !Mw.test(n) && !(Ec.hasOwnProperty(n) && Ec[n]) ? e + "px" : ("" + e).trim()
}
var L2 = {};
function g6(n, e) {
    if (!n.nodeType || !n.setAttribute)
        return !1;
    const t = n.nodeName === "filter" || n.parentNode && n.parentNode.nodeName === "filter"
      , {style: i, children: r, scrollTop: s, scrollLeft: o, viewBox: l, ...u} = e
      , f = Object.values(u)
      , d = Object.keys(u).map(h => t || n.hasAttribute(h) ? h : L2[h] || (L2[h] = h.replace(/([A-Z])/g, m => "-" + m.toLowerCase())));
    r !== void 0 && (n.textContent = r);
    for (const h in i)
        if (i.hasOwnProperty(h)) {
            const m = m6(h, i[h]);
            Mw.test(h) ? n.style.setProperty(h, m) : n.style[h] = m
        }
    d.forEach( (h, m) => {
        n.setAttribute(h, f[m])
    }
    ),
    s !== void 0 && (n.scrollTop = s),
    o !== void 0 && (n.scrollLeft = o),
    l !== void 0 && n.setAttribute("viewBox", l)
}
var Ec = {
    animationIterationCount: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , v6 = (n, e) => n + e.charAt(0).toUpperCase() + e.substring(1)
  , x6 = ["Webkit", "Ms", "Moz", "O"];
Ec = Object.keys(Ec).reduce( (n, e) => (x6.forEach(t => n[v6(t, e)] = n[e]),
n), Ec);
var _6 = /^(matrix|translate|scale|rotate|skew)/
  , y6 = /^(translate)/
  , S6 = /^(rotate|skew)/
  , K0 = (n, e) => Se.num(n) && n !== 0 ? n + e : n
  , uh = (n, e) => Se.arr(n) ? n.every(t => uh(t, e)) : Se.num(n) ? n === e : parseFloat(n) === e
  , M6 = class extends Lp {
    constructor({x: n, y: e, z: t, ...i}) {
        const r = []
          , s = [];
        (n || e || t) && (r.push([n || 0, e || 0, t || 0]),
        s.push(o => [`translate3d(${o.map(l => K0(l, "px")).join(",")})`, uh(o, 0)])),
        Or(i, (o, l) => {
            if (l === "transform")
                r.push([o || ""]),
                s.push(u => [u, u === ""]);
            else if (_6.test(l)) {
                if (delete i[l],
                Se.und(o))
                    return;
                const u = y6.test(l) ? "px" : S6.test(l) ? "deg" : "";
                r.push(ni(o)),
                s.push(l === "rotate3d" ? ([f,d,h,m]) => [`rotate3d(${f},${d},${h},${K0(m, u)})`, uh(m, 0)] : f => [`${l}(${f.map(d => K0(d, u)).join(",")})`, uh(f, l.startsWith("scale") ? 1 : 0)])
            }
        }
        ),
        r.length && (i.transform = new w6(r,s)),
        super(i)
    }
}
  , w6 = class extends K3 {
    constructor(n, e) {
        super(),
        this.inputs = n,
        this.transforms = e,
        this._value = null
    }
    get() {
        return this._value || (this._value = this._get())
    }
    _get() {
        let n = ""
          , e = !0;
        return rt(this.inputs, (t, i) => {
            const r = di(t[0])
              , [s,o] = this.transforms[i](Se.arr(r) ? r : t.map(di));
            n += " " + s,
            e = e && o
        }
        ),
        e ? "none" : n
    }
    observerAdded(n) {
        n == 1 && rt(this.inputs, e => rt(e, t => Gi(t) && Sl(t, this)))
    }
    observerRemoved(n) {
        n == 0 && rt(this.inputs, e => rt(e, t => Gi(t) && Xc(t, this)))
    }
    eventObserved(n) {
        n.type == "change" && (this._value = null),
        jc(this, n)
    }
}
  , b6 = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
$i.assign({
    batchedUpdates: r3.unstable_batchedUpdates,
    createStringInterpolator: ew,
    colors: ZR
});
var E6 = FP(b6, {
    applyAnimatedValues: g6,
    createAnimatedStyle: n => new M6(n),
    getComponentProps: ({scrollTop: n, scrollLeft: e, ...t}) => t
})
  , Th = E6.animated;
const C6 = Object.freeze(Object.defineProperty({
    __proto__: null,
    Any: kP,
    BailSignal: M1,
    Controller: Hv,
    FrameValue: Dp,
    Globals: $i,
    Interpolation: Fp,
    Spring: l6,
    SpringContext: Ml,
    SpringRef: Up,
    SpringValue: Vv,
    Trail: c6,
    Transition: u6,
    a: Th,
    animated: Th,
    config: cw,
    createInterpolator: al,
    easings: Z3,
    inferTo: Op,
    interpolate: h6,
    to: d6,
    update: p6,
    useChain: GP,
    useInView: a6,
    useIsomorphicLayoutEffect: pi,
    useReducedMotion: IP,
    useResize: s6,
    useScroll: r6,
    useSpring: ss,
    useSpringRef: e6,
    useSpringValue: t6,
    useSprings: Gv,
    useTrail: yw,
    useTransition: Sw
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Wv = rv(C6);
var jv = {}
  , Er = {};
Object.defineProperty(Er, "__esModule", {
    value: !0
});
Er.outerCircle = Er.line = Er.intermediateMinuteCircle = Er.centerCircle = void 0;
var kp = Ur;
const ww = "#bceaff"
  , T6 = "#e6f7ff"
  , A6 = "#ade2fb"
  , R6 = (0,
kp.css)("stroke:var(--hand-line-color, ", ww, ");", "");
Er.line = R6;
const P6 = (0,
kp.css)("fill:var(--hand-circle-center, ", ww, ");", "");
Er.centerCircle = P6;
const I6 = (0,
kp.css)("fill:var(--hand-circle-outer, ", T6, ");", "");
Er.outerCircle = I6;
const L6 = (0,
kp.css)("fill:var(--hand-minute-circle, ", A6, ");", "");
Er.intermediateMinuteCircle = L6;
var cs = {};
Object.defineProperty(cs, "__esModule", {
    value: !0
});
cs.calcAnimationAngle = z6;
cs.deg = D6;
cs.isWithinRadius = B6;
cs.rad = Xv;
cs.transform = k6;
var No = ot;
const {cos: N6, sin: O6} = Math
  , bw = Math.PI
  , Ew = 360 / No.VISIBLE_NUMBERS_PER_CIRCLE;
function Xv(n) {
    return n / (180 / bw)
}
function D6(n) {
    return n * (180 / bw)
}
function U6(n, e) {
    return O6(Xv(n * -Ew - 180)) * (No.CLOCK_RADIUS - e) + No.CLOCK_RADIUS - No.NUMBER_RADIUS_REGULAR / 2
}
function F6(n, e) {
    return N6(Xv(n * -Ew - 180)) * (No.CLOCK_RADIUS - e) + No.CLOCK_RADIUS - No.NUMBER_RADIUS_REGULAR / 2
}
function k6(n, e) {
    const t = U6(n, e)
      , i = F6(n, e);
    return "translate(".concat(t, "px, ").concat(i, "px)")
}
function B6(n, e, t) {
    return Math.sqrt(n * n + e * e) < t
}
function N2(n) {
    return (n % 360 + 360) % 360
}
function z6(n, e) {
    const t = N2(n)
      , i = N2(e);
    let r = t
      , s = t;
    for (; i < r; )
        r -= 360;
    for (; i >= s; )
        s += 360;
    return s - i < i - r ? n - (s - i) : n + (i - r)
}
Object.defineProperty(jv, "__esModule", {
    value: !0
});
jv.default = G6;
var J0 = N
  , ed = Wv
  , A1 = Ii
  , bn = ot
  , td = Er
  , V6 = cs
  , xa = Ki;
function H6(n) {
    return "rotate(".concat(n, " ").concat(bn.CLOCK_RADIUS, " ").concat(bn.CLOCK_RADIUS, ")")
}
function O2(n, e) {
    const t = bn.CLOCK_VALUES[n].increments;
    return (0,
    A1.getTimeValue)(n, e) * (360 / t)
}
function G6(n) {
    let {mode: e, time: t} = n;
    const i = (0,
    J0.useRef)({
        time: t,
        mode: e
    })
      , r = (0,
    J0.useRef)(0)
      , s = t.hour > 0 && t.hour <= 12
      , o = (0,
    bn.getClockHandLength)(e, s)
      , l = (0,
    bn.getClockHandCirclePosition)(e, s)
      , u = (0,
    bn.getClockHandCircleRadius)(e, s)
      , [f,d] = (0,
    ed.useSpring)( () => ({
        immediate: !0,
        rotation: O2(e, t),
        length: o,
        position: l
    }))
      , {rotation: h, length: m, position: g} = f;
    (0,
    J0.useEffect)( () => {
        const _ = h.get()
          , v = O2(e, t);
        if (i.current.mode !== e) {
            r.current = 0,
            i.current.mode = e;
            const M = (0,
            V6.calcAnimationAngle)(_, v);
            d.start({
                immediate: !1,
                rotation: M,
                length: o,
                position: l
            })
        } else
            (0,
            A1.isSameTime)(i.current.time, t) || (i.current.time = t,
            r.current++,
            d.start({
                immediate: !0,
                rotation: v,
                length: o,
                position: l
            }))
    }
    , [l, o, e, h, d, t]);
    const x = (0,
    A1.getTimeValue)(e, t);
    let S;
    return e === bn.MODE.MINUTES && x % 5 && (S = (0,
    xa.jsx)("circle", {
        className: "react-timekeeper__hand-intermediate-circle",
        css: td.intermediateMinuteCircle,
        cx: bn.CLOCK_RADIUS,
        cy: bn.NUMBER_OUTER_POSITION,
        r: 4
    })),
    (0,
    xa.jsx)("svg", {
        width: bn.CLOCK_SIZE,
        height: bn.CLOCK_SIZE,
        viewBox: "0 0 ".concat(bn.CLOCK_SIZE, " ").concat(bn.CLOCK_SIZE),
        xmlns: "http://www.w3.org/2000/svg",
        className: "react-timekeeper__clock-hand",
        children: (0,
        xa.jsxs)(ed.animated.g, {
            transform: h.to(_ => H6(_)),
            children: [(0,
            xa.jsx)(ed.animated.line, {
                className: "react-timekeeper__clock-hand",
                css: td.line,
                x1: bn.CLOCK_RADIUS,
                y1: bn.CLOCK_RADIUS,
                x2: bn.CLOCK_RADIUS,
                y2: m,
                strokeWidth: "1",
                "data-testid": "clock-hand"
            }), (0,
            xa.jsx)("circle", {
                className: "react-timekeeper__hand-circle-center",
                css: td.centerCircle,
                cx: bn.CLOCK_RADIUS,
                cy: bn.CLOCK_RADIUS,
                r: 1.5
            }), (0,
            xa.jsx)(ed.animated.circle, {
                className: "react-timekeeper__hand-circle-outer",
                css: td.outerCircle,
                cx: bn.CLOCK_RADIUS,
                cy: g,
                r: u
            }), S]
        })
    })
}
var cl = {}
  , ul = {};
Object.defineProperty(ul, "__esModule", {
    value: !0
});
ul.numbersWrapperStyle = ul.numbersStyle = void 0;
var W6 = Ur
  , tl = ot;
const j6 = "#999999"
  , X6 = "#ddd";
function $6(n, e) {
    return n ? e ? "var(--numbers-font-size-inner, ".concat(tl.HOUR_24_INNER_FONT_SIZE, "px)") : "var(--numbers-font-size-outer, ".concat(tl.HOUR_24_OUTER_FONT_SIZE, "px)") : "var(--numbers-font-size-reg, ".concat(tl.NUMBER_REGULAR_FONT_SIZE, "px)")
}
const q6 = "var(--numbers-text-color, ".concat(j6, ")")
  , Y6 = "var(--numbers-text-color-disabled, ".concat(X6, ")")
  , Z6 = n => {
    let {hour24Mode: e=!1, inner: t=!1, enabled: i=!0} = n;
    return (0,
    W6.css)("display:inline-block;position:absolute;color:", i ? q6 : Y6, ";transition:color 0.15s ease-out;pointer-events:none;border-radius:99px;width:", tl.NUMBER_RADIUS_REGULAR, "px;height:", tl.NUMBER_RADIUS_REGULAR, "px;text-align:center;line-height:", tl.NUMBER_RADIUS_REGULAR, "px;z-index:5;font-size:", $6(e, t), ";", "")
}
;
ul.numbersStyle = Z6;
const K6 = {
    name: "110a76v",
    styles: "position:absolute;left:0;top:0;z-index:2"
};
ul.numbersWrapperStyle = K6;
Object.defineProperty(cl, "__esModule", {
    value: !0
});
cl.MinuteNumbers = cl.HourNumbers = void 0;
var Bp = N
  , Cc = Wv
  , fh = ot
  , R1 = cs
  , Tc = ul
  , Ac = Ki;
function J6(n) {
    let {anim: e, mode: t, hour24Mode: i, disabledTimeRangeValidator: r, meridiem: s} = n;
    const {opacity: o, translate: l, translateInner: u} = e
      , {numbersOuter: f, numbersInner: d} = (0,
    Bp.useMemo)( () => {
        const {numbers: h, numbersInner: m} = fh.CLOCK_VALUES[t];
        let g;
        t === fh.MODE.HOURS_12 && s === "am" ? g = S => S % 11 + 1 : t === fh.MODE.HOURS_12 && s === "pm" ? g = S => S % 11 + 13 : g = S => S % 12 + 13;
        const x = S => S % 12 + 1;
        return {
            numbersOuter: h.map( (S, _) => {
                var v;
                return {
                    value: S,
                    enabled: (v = r == null ? void 0 : r.validateHour(g(_))) !== null && v !== void 0 ? v : !0
                }
            }
            ),
            numbersInner: m == null ? void 0 : m.map( (S, _) => {
                var v;
                return {
                    value: S,
                    enabled: (v = r == null ? void 0 : r.validateHour(x(_))) !== null && v !== void 0 ? v : !0
                }
            }
            )
        }
    }
    , [t, s, r]);
    return (0,
    Ac.jsxs)(Cc.animated.div, {
        style: {
            opacity: o
        },
        css: Tc.numbersWrapperStyle,
        className: "react-timekeeper__clock-hours",
        children: [f.map( (h, m) => {
            let {value: g, enabled: x} = h;
            return (0,
            Ac.jsx)(Cc.animated.span, {
                css: (0,
                Tc.numbersStyle)({
                    hour24Mode: i,
                    enabled: x
                }),
                "data-testid": "number_hour_outer",
                style: {
                    transform: l.to(S => (0,
                    R1.transform)(m + 1, S))
                },
                children: g
            }, g)
        }
        ), i && d.map( (h, m) => {
            let {value: g, enabled: x} = h;
            return (0,
            Ac.jsx)(Cc.animated.span, {
                css: (0,
                Tc.numbersStyle)({
                    hour24Mode: i,
                    inner: !0,
                    enabled: x
                }),
                "data-testid": "number_hour_inner",
                style: {
                    transform: u.to(S => (0,
                    R1.transform)(m + 1, S))
                },
                children: g
            }, g)
        }
        )]
    })
}
const Q6 = (0,
Bp.memo)(J6, (n, e) => n.mode === e.mode && n.hour24Mode === e.hour24Mode && n.meridiem === e.meridiem && n.disabledTimeRangeValidator === e.disabledTimeRangeValidator);
cl.HourNumbers = Q6;
function eI(n) {
    let {anim: e, hour: t, disabledTimeRangeValidator: i} = n;
    const {opacity: r, translate: s} = e
      , o = (0,
    Bp.useMemo)( () => fh.MINUTES.map(l => {
        var u;
        return {
            value: l,
            enabled: (u = i == null ? void 0 : i.validateMinute(t, parseInt(l, 10))) !== null && u !== void 0 ? u : !0
        }
    }
    ), [i, t]);
    return (0,
    Ac.jsx)(Cc.animated.div, {
        style: {
            opacity: r
        },
        css: Tc.numbersWrapperStyle,
        className: "react-timekeeper__clock-minutes",
        children: o.map( (l, u) => {
            let {value: f, enabled: d} = l;
            return (0,
            Ac.jsx)(Cc.animated.span, {
                css: (0,
                Tc.numbersStyle)({
                    enabled: d
                }),
                "data-testid": "number_minute",
                style: {
                    transform: s.to(h => (0,
                    R1.transform)(u + 1, h))
                },
                children: f
            }, f)
        }
        )
    })
}
const tI = (0,
Bp.memo)(eI, (n, e) => n.disabledTimeRangeValidator === e.disabledTimeRangeValidator && n.hour === e.hour);
cl.MinuteNumbers = tI;
var zp = {};
Object.defineProperty(zp, "__esModule", {
    value: !0
});
zp.default = void 0;
var nI = Ur
  , D2 = ot;
const iI = (0,
nI.css)("display:inline-block;border-radius:200px;background:var(--clock-bg, white);width:", D2.CLOCK_SIZE, "px;height:", D2.CLOCK_SIZE, "px;position:relative;cursor:pointer;touch-action:none;", "");
var rI = iI;
zp.default = rI;
Object.defineProperty(Tv, "__esModule", {
    value: !0
});
Tv.default = dI;
var U2 = N
  , sI = Wv
  , oI = Vp(jv)
  , F2 = cl
  , Ds = ot
  , $v = Ii
  , aI = Vp(zp)
  , lI = Vp(Zi)
  , cI = Vp(Ji)
  , nd = Ki;
function Vp(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function uI(n) {
    return (0,
    $v.isHourMode)(n) ? Ds.INITIAL_HOUR_TRANSFORM : Ds.INITIAL_MINUTE_TRANSFORM
}
function fI(n) {
    return (0,
    $v.isMinuteMode)(n) ? Ds.INITIAL_HOUR_TRANSFORM : Ds.INITIAL_MINUTE_TRANSFORM
}
function dI(n) {
    let {clockEl: e} = n;
    const t = (0,
    U2.useRef)(!0)
      , {hour24Mode: i} = (0,
    lI.default)()
      , {mode: r, time: s, meridiem: o, disabledTimeRangeValidator: l} = (0,
    cI.default)()
      , u = (0,
    sI.useTransition)(r, {
        unique: !0,
        from: !t.current && {
            opacity: 0,
            translate: fI(r),
            translateInner: Ds.INNER_NUMBER_POSITIONING.exit
        },
        enter: {
            opacity: 1,
            translate: (0,
            Ds.getOuterNumberPosition)(r),
            translateInner: Ds.INNER_NUMBER_POSITIONING.enter
        },
        leave: {
            opacity: 0,
            translate: uI(r),
            translateInner: Ds.INNER_NUMBER_POSITIONING.exit
        }
    });
    return (0,
    U2.useEffect)( () => {
        t.current = !1
    }
    , []),
    (0,
    nd.jsxs)("div", {
        className: "react-timekeeper__clock",
        css: aI.default,
        ref: e,
        children: [u( (f, d) => (0,
        $v.isMinuteMode)(d) ? (0,
        nd.jsx)(F2.MinuteNumbers, {
            anim: f,
            disabledTimeRangeValidator: l,
            hour: s.hour
        }) : (0,
        nd.jsx)(F2.HourNumbers, {
            anim: f,
            mode: d,
            hour24Mode: i,
            disabledTimeRangeValidator: l,
            meridiem: o
        })), (0,
        nd.jsx)(oI.default, {
            time: s,
            mode: r
        })]
    })
}
var qv = {}
  , fl = {};
Object.defineProperty(fl, "__esModule", {
    value: !0
});
fl.meridiemWrapper = fl.meridiem = void 0;
var hI = Ur;
const pI = "#898989"
  , mI = "#E1EFF6"
  , gI = "#898989"
  , Q0 = 38
  , vI = {
    name: "11zmfun",
    styles: "text-align:left;padding:0 30px;margin-top:-16px;position:relative;z-index:10"
};
fl.meridiemWrapper = vI;
const xI = `
	float: right;
`
  , _I = `
	background: var(--meridiem-selected-bg-color, `.concat(mI, `);
	color: var(--meridiem-selected-text-color, `).concat(gI, `);
`)
  , yI = n => {
    let {isRight: e, isSelected: t} = n;
    return (0,
    hI.css)("background:var(--meridiem-bg-color, white);font-size:14px;color:var(--meridiem-text-color, ", pI, ");display:inline-block;padding:0;cursor:pointer;border-radius:99px;width:", Q0, "px;height:", Q0, "px;text-align:center;line-height:", Q0, "px;transition:0.15s ease-out;", e && xI, " ", t && _I, ";", "")
}
;
fl.meridiem = yI;
Object.defineProperty(qv, "__esModule", {
    value: !0
});
qv.default = wI;
var k2 = N
  , eg = fl
  , SI = MI(Ji)
  , B2 = ot
  , tg = Ki;
function MI(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function wI() {
    const {time: n, updateMeridiem: e} = (0,
    SI.default)()
      , t = (0,
    k2.useCallback)( () => {
        e(B2.MERIDIEM.am)
    }
    , [e])
      , i = (0,
    k2.useCallback)( () => {
        e(B2.MERIDIEM.pm)
    }
    , [e])
      , r = n.hour >= 12;
    return (0,
    tg.jsxs)("div", {
        css: eg.meridiemWrapper,
        children: [(0,
        tg.jsx)("button", {
            type: "button",
            css: (0,
            eg.meridiem)({
                isSelected: !r
            }),
            "data-testid": "meridiem_am",
            className: "react-timekeeper-button-reset react-timekeeper__meridiem-toggle ".concat(r ? "" : "react-timekeeper__meridiem--active"),
            onClick: t,
            children: "AM"
        }), (0,
        tg.jsx)("button", {
            type: "button",
            css: (0,
            eg.meridiem)({
                isRight: !0,
                isSelected: r
            }),
            "data-testid": "meridiem_pm",
            className: "react-timekeeper-button-reset react-timekeeper__meridiem-toggle ".concat(r ? "react-timekeeper__meridiem--active" : ""),
            onClick: i,
            children: "PM"
        })]
    })
}
var Hp = {}
  , Iu = {};
Object.defineProperty(Iu, "__esModule", {
    value: !0
});
Iu.CLOCK_WRAPPER_BACKGROUND = void 0;
const bI = "#f4f4f4";
Iu.CLOCK_WRAPPER_BACKGROUND = bI;
Object.defineProperty(Hp, "__esModule", {
    value: !0
});
Hp.default = void 0;
var EI = Ur
  , CI = Iu;
const TI = (0,
EI.css)("text-align:center;padding:18px 0 14px;background:var(--clock-wrapper-bg, ", CI.CLOCK_WRAPPER_BACKGROUND, ");", "");
var AI = TI;
Hp.default = AI;
var Yv = {};
Object.defineProperty(Yv, "__esModule", {
    value: !0
});
Yv.default = PI;
var Dn = N
  , lo = ot
  , z2 = Cu
  , id = cs;
const {atan2: RI} = Math;
function PI(n, e) {
    const t = (0,
    Dn.useRef)(null)
      , i = (0,
    Dn.useRef)(null)
      , r = (0,
    Dn.useRef)(0)
      , s = (0,
    Dn.useRef)( () => {}
    )
      , o = (0,
    Dn.useRef)(e);
    (0,
    Dn.useEffect)( () => {
        o.current = e
    }
    , [e]);
    const l = (0,
    Dn.useCallback)( (S, _, v) => {
        const M = r.current < 2
          , w = S - lo.CLOCK_RADIUS
          , E = -_ + lo.CLOCK_RADIUS
          , O = RI(E, w);
        let R = 90 - (0,
        id.deg)(O);
        if (R < 0 && (R = 360 + R),
        !(0,
        id.isWithinRadius)(w, E, lo.CLOCK_RADIUS) && M)
            return !1;
        const A = (0,
        id.isWithinRadius)(w, E, lo.INNER_NUMBER_RADIUS);
        o.current(R, {
            canAutoChangeMode: v,
            wasTapped: M,
            isInnerClick: A
        })
    }
    , [])
      , u = (0,
    Dn.useCallback)(S => {
        if (!n.current)
            return;
        n.current.style.cursor = "";
        const {offsetX: _, offsetY: v} = i.current(S.clientX, S.clientY);
        l(_, v, !0)
    }
    , [l, n])
      , f = (0,
    Dn.useCallback)(S => {
        const _ = S.targetTouches[0] || S.changedTouches[0];
        if (_ && i.current) {
            const {offsetX: v, offsetY: M} = i.current(_.clientX, _.clientY);
            l(v, M, !0)
        }
    }
    , [l])
      , d = (0,
    Dn.useCallback)(S => {
        if (i.current) {
            const {offsetX: _, offsetY: v} = i.current(S.clientX, S.clientY);
            l(_, v, !1)
        }
        return r.current++,
        r.current === 1 && n.current && (n.current.style.cursor = "-webkit-grabbing",
        n.current.style.cursor = "grabbing"),
        S.preventDefault(),
        !1
    }
    , [l, n])
      , h = (0,
    Dn.useCallback)(S => {
        if (i.current) {
            const _ = S.targetTouches[0]
              , {offsetX: v, offsetY: M} = i.current(_.clientX, _.clientY);
            l(v, M, !1)
        }
        return r.current++,
        S.preventDefault(),
        !1
    }
    , [l])
      , m = (0,
    Dn.useCallback)(S => {
        if (s.current(),
        S == null || n.current == null)
            return;
        _(S) ? u(S) : v(S) && f(S);
        function _(M) {
            return M.type === "mouseup"
        }
        function v(M) {
            return M.type === "touchcancel" || M.type === "touchend"
        }
    }
    , [u, f, n])
      , g = (0,
    Dn.useCallback)(S => {
        if (r.current = 0,
        n.current) {
            i.current = (0,
            z2.calcOffset)(n.current);
            const {offsetX: _, offsetY: v} = i.current(S.clientX, S.clientY)
              , M = _ - lo.CLOCK_RADIUS
              , w = v - lo.CLOCK_RADIUS;
            if (!(0,
            id.isWithinRadius)(M, w, lo.CLOCK_RADIUS))
                return
        }
        document.addEventListener("mousemove", d, !1),
        document.addEventListener("mouseup", m, !1),
        t.current && t.current.addEventListener("mouseleave", m, !1),
        d(S)
    }
    , [n, d, m])
      , x = (0,
    Dn.useCallback)(S => {
        S.preventDefault(),
        r.current = 0,
        document.addEventListener("touchmove", h, !1),
        document.addEventListener("touchend", m, !1),
        document.addEventListener("touchcancel", m, !1),
        n.current && (i.current = (0,
        z2.calcOffset)(n.current))
    }
    , [n, m, h]);
    return (0,
    Dn.useEffect)( () => {
        const S = n.current
          , _ = "touchstart";
        return S && S.addEventListener(_, x, !1),
        () => {
            S && S.removeEventListener(_, x, !1)
        }
    }
    , [n, x]),
    (0,
    Dn.useEffect)( () => {
        s.current = () => {
            document.removeEventListener("mousemove", d, !1),
            document.removeEventListener("mouseup", m, !1),
            t.current && t.current.removeEventListener("mouseleave", m, !1),
            document.removeEventListener("touchmove", h, !1),
            document.removeEventListener("touchend", m, !1),
            document.removeEventListener("touchcancel", m, !1)
        }
    }
    , [d, m, h]),
    (0,
    Dn.useEffect)( () => s.current, []),
    {
        bind: {
            onMouseDown: g,
            ref: t
        }
    }
}
Object.defineProperty(Cv, "__esModule", {
    value: !0
});
Cv.default = FI;
var V2 = N
  , II = wl(Zi)
  , LI = wl(Tv)
  , NI = wl(qv)
  , OI = wl(Hp)
  , DI = wl(Yv)
  , H2 = ot
  , G2 = Ii
  , UI = wl(Ji)
  , ng = Ki;
function wl(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function FI() {
    const n = (0,
    II.default)()
      , e = (0,
    V2.useRef)(null)
      , {mode: t, updateTimeValue: i} = (0,
    UI.default)()
      , r = (0,
    V2.useCallback)( (o, l) => {
        let {canAutoChangeMode: u=!1, wasTapped: f=!1, isInnerClick: d=!1} = l;
        const h = H2.CLOCK_VALUES[t].increments;
        let m = 1;
        (0,
        G2.isMinuteMode)(t) && (f || n.forceCoarseMinutes) && (m = n.coarseMinutes);
        const g = o / 360 * h;
        let x = Math.round(g / m) * m;
        (0,
        G2.isHourMode)(t) && (x = x % 12),
        t === H2.MODE.HOURS_24 && n.hour24Mode && (d || (x += 12),
        x === 12 ? x = 0 : x === 0 && (x = 12)),
        i(x, {
            type: "clock",
            canAutoChangeMode: u
        })
    }
    , [n.forceCoarseMinutes, n.coarseMinutes, n.hour24Mode, t, i])
      , {bind: s} = (0,
    DI.default)(e, r);
    return (0,
    ng.jsxs)("div", {
        ...s,
        className: "react-timekeeper__clock-wrapper",
        css: OI.default,
        "data-testid": "clock-wrapper",
        children: [(0,
        ng.jsx)(LI.default, {
            clockEl: e
        }), !n.hour24Mode && (0,
        ng.jsx)(NI.default, {})]
    })
}
var Zv = {}
  , zs = {};
Object.defineProperty(zs, "__esModule", {
    value: !0
});
zs.default = zs.DONE_BUTTON_COLOR = zs.DONE_BUTTON_BORDER_COLOR = void 0;
var kI = Ur
  , BI = Iu;
const Cw = "#686868";
zs.DONE_BUTTON_COLOR = Cw;
const Tw = "#CCC";
zs.DONE_BUTTON_BORDER_COLOR = Tw;
const zI = (0,
kI.css)("background:var(--done-bg-color, ", BI.CLOCK_WRAPPER_BACKGROUND, ");display:block;color:var(--done-text-color, ", Cw, ");text-transform:uppercase;border-top:var(--done-border-top, 1px solid ", Tw, ");text-align:center;cursor:pointer;padding:16px 0;font-size:var(--done-font-size, 13px);letter-spacing:0.5px;line-height:normal;font-weight:var(--done-font-weight, 500);", "");
var VI = zI;
zs.default = VI;
Object.defineProperty(Zv, "__esModule", {
    value: !0
});
Zv.default = XI;
var HI = Kv(Zi)
  , GI = Kv(zs)
  , WI = Kv(Ji)
  , jI = Ki;
function Kv(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function XI() {
    const {onDoneClick: n, doneButton: e} = (0,
    HI.default)()
      , {getComposedTime: t} = (0,
    WI.default)();
    return e ? e(t()) : n ? (0,
    jI.jsx)("span", {
        css: GI.default,
        onClick: i => n(t(), i),
        className: "react-timekeeper__done-button",
        "data-testid": "done-button",
        children: "Done"
    }) : null
}
Object.defineProperty(ov, "__esModule", {
    value: !0
});
ov.default = JI;
var W2 = Ur
  , $I = Lu(wp)
  , qI = Lu(bp)
  , YI = Lu(vv)
  , ZI = Lu(Cv)
  , KI = Lu(Zv)
  , co = Ki;
function Lu(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function JI() {
    return (0,
    co.jsxs)(co.Fragment, {
        children: [(0,
        co.jsx)(W2.Global, {
            styles: (0,
            W2.css)($I.default, "", "")
        }), (0,
        co.jsxs)("div", {
            className: "react-timekeeper",
            css: qI.default,
            children: [(0,
            co.jsx)(YI.default, {}), (0,
            co.jsx)(ZI.default, {}), (0,
            co.jsx)(KI.default, {})]
        })]
    })
}
Object.defineProperty(sv, "__esModule", {
    value: !0
});
sv.default = i8;
var QI = n8(ov)
  , e8 = Zi
  , t8 = Ji
  , ig = Ki;
function n8(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function i8(n) {
    let {time: e, onChange: t, coarseMinutes: i, forceCoarseMinutes: r, switchToMinuteOnHourSelect: s, switchToMinuteOnHourDropdownSelect: o, closeOnMinuteSelect: l, hour24Mode: u, onDoneClick: f, doneButton: d, disabledTimeRange: h} = n;
    return (0,
    ig.jsx)(e8.ConfigProvider, {
        coarseMinutes: i,
        forceCoarseMinutes: r,
        switchToMinuteOnHourSelect: s,
        switchToMinuteOnHourDropdownSelect: o,
        closeOnMinuteSelect: l,
        hour24Mode: u,
        onDoneClick: f,
        doneButton: d,
        children: (0,
        ig.jsx)(t8.StateProvider, {
            onChange: t,
            time: e,
            disabledTimeRange: h,
            children: (0,
            ig.jsx)(QI.default, {})
        })
    })
}
var Aw = {};
Object.defineProperty(Aw, "__esModule", {
    value: !0
});
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    Object.defineProperty(n, "TimeInput", {
        enumerable: !0,
        get: function() {
            return t.TimeInput
        }
    }),
    Object.defineProperty(n, "TimeOutput", {
        enumerable: !0,
        get: function() {
            return t.TimeOutput
        }
    }),
    n.default = void 0;
    var e = i(sv)
      , t = Aw;
    function i(s) {
        return s && s.__esModule ? s : {
            default: s
        }
    }
    var r = e.default;
    n.default = r
}
)(BT);
const Rw = () => {
    const {t: n} = hn()
      , e = n("Hey! Join My DAO.");
    return N.useCallback( () => {
        var i;
        location.href = `https://t.me/share/url?text=${e}&${new URLSearchParams({
            url: ((i = de.profile) == null ? void 0 : i.dao_link) || ""
        }).toString()}`
    }
    , [e])
}
  , j2 = Pi( () => {
    var r, s, o, l, u, f, d, h, m, g, x, S, _, v, M, w, E, O, R, A, F, I, P, D, W, X, G, q, K, oe, z, ee, Q, ce, be, Ue, se, ue, Te, Me, Ye, Qe, ze, ke, k, pe, ye, Pe, fe, $e, Le, Be, H, L, te, _e, ge, ve;
    const n = dr();
    wu();
    const e = Rw()
      , t = N.useCallback( () => {
        a3.getDaoDaoLeave().then( () => {
            r1.success(i("You left the DAO")),
            de.updateProfile().then( () => {
                n("/")
            }
            )
        }
        )
    }
    , [n]);
    N.useCallback(async Ke => {
        var He, ft;
        if (!Ke)
            return;
        let we = new Date;
        we.setHours(parseInt(((He = Ke.split(":")) == null ? void 0 : He[0]) || "0") || 0),
        we.setMinutes(parseInt(((ft = Ke.split(":")) == null ? void 0 : ft[1]) || "0") || 0),
        we.setSeconds(0),
        we = new Date(we.getTime() + new Date().getTimezoneOffset() * 60 * 1e3),
        de.setGlobalLoading(!0),
        `${we.getHours().toString().padStart(2, "0")}${we.getMinutes().toString().padStart(2, "0")}`,
        r1.success(i("Mega Farm time updated successfully")),
        await de.refreshDao(),
        de.setGlobalLoading(!1)
    }
    , []);
    const {t: i} = hn();
    return T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "absolute left-0 right-0 bottom-0 z-40 rounded-t-xl flex flex-col justify-end items-stretch pt-4 pb-6 transition-all duration-300 overflow-hidden",
            style: {
                background: "#111111"
            },
            children: [T.jsx("div", {
                className: "text-xl text-white sora-bold mb-2 mr-6 ml-6",
                children: i("DAO Settings")
            }), T.jsx("div", {
                className: "w-full flex flex-row justify-between items-center mb-2 pr-6 pl-6",
                children: T.jsxs("div", {
                    className: "text-sm flex flex-row text-white  items-center",
                    children: [T.jsx("div", {
                        children: i("DAO Profit:")
                    }), T.jsx("div", {
                        className: "coin-logo w-7 h-7 ml-1 mr-1"
                    }), T.jsxs("div", {
                        children: [de.daoProfit, " $DAO"]
                    })]
                })
            }), T.jsxs("div", {
                className: "flex flex-col justify-center flex-1 w-full items-center pb-2 pt-7",
                children: [T.jsxs("div", {
                    className: "flex-row justify-center flex pt-1",
                    children: [T.jsxs("div", {
                        className: `w-24 h-24 ${(s = (r = de.daoUsers) == null ? void 0 : r[0]) != null && s.id ? "circle-blue" : "circle-gray"} flex justify-center items-center`,
                        children: [(l = (o = de.daoUsers) == null ? void 0 : o[0]) != null && l.id ? T.jsx(Co, {
                            className: "h-16 w-16 text-2xl",
                            url: ((f = (u = de.daoUsers) == null ? void 0 : u[0]) == null ? void 0 : f.photo_url) || void 0,
                            fullName: ((h = (d = de.daoUsers) == null ? void 0 : d[0]) == null ? void 0 : h.full_name) || void 0
                        }) : T.jsx("div", {
                            className: "h-16 w-16 rounded-full flex justify-center items-center  z-50",
                            style: {
                                background: "#262626"
                            },
                            onClick: e,
                            children: T.jsxs("svg", {
                                width: "54",
                                height: "54",
                                viewBox: "0 0 54 54",
                                fill: "none",
                                xmlns: "http://www.w3.org/2000/svg",
                                children: [T.jsx("path", {
                                    opacity: "0.2",
                                    d: "M47.25 27C47.25 31.0051 46.0624 34.9202 43.8373 38.2503C41.6122 41.5804 38.4496 44.1759 34.7494 45.7086C31.0491 47.2412 26.9775 47.6423 23.0494 46.8609C19.1213 46.0796 15.5131 44.1509 12.6811 41.3189C9.84908 38.4869 7.92046 34.8787 7.13911 30.9506C6.35776 27.0225 6.75877 22.9509 8.29145 19.2507C9.82412 15.5505 12.4196 12.3878 15.7497 10.1627C19.0798 7.93764 22.9949 6.75 27 6.75C32.3706 6.75 37.5213 8.88348 41.3189 12.6811C45.1165 16.4787 47.25 21.6294 47.25 27Z",
                                    fill: "white"
                                }), T.jsx("path", {
                                    d: "M27 5.0625C22.6612 5.0625 18.4198 6.34911 14.8122 8.75964C11.2046 11.1702 8.3928 14.5963 6.7324 18.6049C5.07201 22.6134 4.63757 27.0243 5.48403 31.2798C6.3305 35.5353 8.41984 39.4441 11.4879 42.5122C14.5559 45.5802 18.4648 47.6695 22.7202 48.516C26.9757 49.3624 31.3866 48.928 35.3951 47.2676C39.4037 45.6072 42.8299 42.7954 45.2404 39.1878C47.6509 35.5802 48.9375 31.3388 48.9375 27C48.9314 21.1837 46.6181 15.6074 42.5054 11.4946C38.3926 7.38188 32.8163 5.06864 27 5.0625ZM27 45.5625C23.3287 45.5625 19.7398 44.4738 16.6872 42.4342C13.6347 40.3945 11.2554 37.4954 9.8505 34.1036C8.44554 30.7117 8.07794 26.9794 8.79418 23.3786C9.51042 19.7779 11.2783 16.4703 13.8743 13.8743C16.4704 11.2783 19.7779 9.51041 23.3786 8.79417C26.9794 8.07794 30.7117 8.44553 34.1036 9.85049C37.4954 11.2554 40.3945 13.6346 42.4342 16.6872C44.4738 19.7398 45.5625 23.3287 45.5625 27C45.5569 31.9214 43.5994 36.6396 40.1195 40.1195C36.6396 43.5994 31.9214 45.5569 27 45.5625ZM37.125 27C37.125 27.4476 36.9472 27.8768 36.6308 28.1932C36.3143 28.5097 35.8851 28.6875 35.4375 28.6875H28.6875V35.4375C28.6875 35.8851 28.5097 36.3143 28.1933 36.6307C27.8768 36.9472 27.4476 37.125 27 37.125C26.5525 37.125 26.1232 36.9472 25.8068 36.6307C25.4903 36.3143 25.3125 35.8851 25.3125 35.4375V28.6875H18.5625C18.115 28.6875 17.6857 28.5097 17.3693 28.1932C17.0528 27.8768 16.875 27.4476 16.875 27C16.875 26.5524 17.0528 26.1232 17.3693 25.8068C17.6857 25.4903 18.115 25.3125 18.5625 25.3125H25.3125V18.5625C25.3125 18.1149 25.4903 17.6857 25.8068 17.3693C26.1232 17.0528 26.5525 16.875 27 16.875C27.4476 16.875 27.8768 17.0528 28.1933 17.3693C28.5097 17.6857 28.6875 18.1149 28.6875 18.5625V25.3125H35.4375C35.8851 25.3125 36.3143 25.4903 36.6308 25.8068C36.9472 26.1232 37.125 26.5524 37.125 27Z",
                                    fill: "white"
                                })]
                            })
                        }), (g = (m = de.daoUsers) == null ? void 0 : m[0]) != null && g.full_name ? T.jsx("div", {
                            className: "-top-8 text-white absolute text-center",
                            children: T.jsxs("div", {
                                className: "bg-[#1B1B1B] pt-2 pb-2 pl-4 pr-4 rounded-md text-[12px] text-nowrap",
                                children: [(S = (x = de.daoUsers) == null ? void 0 : x[0]) != null && S.is_owner ? "👑 " : "", (v = (_ = de.daoUsers) == null ? void 0 : _[0]) == null ? void 0 : v.full_name]
                            })
                        }) : null]
                    }), T.jsxs("div", {
                        className: `w-24 h-24 ${(w = (M = de.daoUsers) == null ? void 0 : M[1]) != null && w.id ? "circle-blue" : "circle-gray"} flex justify-center items-center`,
                        children: [(O = (E = de.daoUsers) == null ? void 0 : E[1]) != null && O.id ? T.jsx(Co, {
                            className: "h-16 w-16 text-2xl",
                            url: ((A = (R = de.daoUsers) == null ? void 0 : R[1]) == null ? void 0 : A.photo_url) || void 0,
                            fullName: ((I = (F = de.daoUsers) == null ? void 0 : F[1]) == null ? void 0 : I.full_name) || void 0
                        }) : T.jsx("div", {
                            className: "h-16 w-16 rounded-full flex justify-center items-center z-50",
                            style: {
                                background: "#262626"
                            },
                            onClick: e,
                            children: T.jsxs("svg", {
                                width: "54",
                                height: "54",
                                viewBox: "0 0 54 54",
                                fill: "none",
                                xmlns: "http://www.w3.org/2000/svg",
                                children: [T.jsx("path", {
                                    opacity: "0.2",
                                    d: "M47.25 27C47.25 31.0051 46.0624 34.9202 43.8373 38.2503C41.6122 41.5804 38.4496 44.1759 34.7494 45.7086C31.0491 47.2412 26.9775 47.6423 23.0494 46.8609C19.1213 46.0796 15.5131 44.1509 12.6811 41.3189C9.84908 38.4869 7.92046 34.8787 7.13911 30.9506C6.35776 27.0225 6.75877 22.9509 8.29145 19.2507C9.82412 15.5505 12.4196 12.3878 15.7497 10.1627C19.0798 7.93764 22.9949 6.75 27 6.75C32.3706 6.75 37.5213 8.88348 41.3189 12.6811C45.1165 16.4787 47.25 21.6294 47.25 27Z",
                                    fill: "white"
                                }), T.jsx("path", {
                                    d: "M27 5.0625C22.6612 5.0625 18.4198 6.34911 14.8122 8.75964C11.2046 11.1702 8.3928 14.5963 6.7324 18.6049C5.07201 22.6134 4.63757 27.0243 5.48403 31.2798C6.3305 35.5353 8.41984 39.4441 11.4879 42.5122C14.5559 45.5802 18.4648 47.6695 22.7202 48.516C26.9757 49.3624 31.3866 48.928 35.3951 47.2676C39.4037 45.6072 42.8299 42.7954 45.2404 39.1878C47.6509 35.5802 48.9375 31.3388 48.9375 27C48.9314 21.1837 46.6181 15.6074 42.5054 11.4946C38.3926 7.38188 32.8163 5.06864 27 5.0625ZM27 45.5625C23.3287 45.5625 19.7398 44.4738 16.6872 42.4342C13.6347 40.3945 11.2554 37.4954 9.8505 34.1036C8.44554 30.7117 8.07794 26.9794 8.79418 23.3786C9.51042 19.7779 11.2783 16.4703 13.8743 13.8743C16.4704 11.2783 19.7779 9.51041 23.3786 8.79417C26.9794 8.07794 30.7117 8.44553 34.1036 9.85049C37.4954 11.2554 40.3945 13.6346 42.4342 16.6872C44.4738 19.7398 45.5625 23.3287 45.5625 27C45.5569 31.9214 43.5994 36.6396 40.1195 40.1195C36.6396 43.5994 31.9214 45.5569 27 45.5625ZM37.125 27C37.125 27.4476 36.9472 27.8768 36.6308 28.1932C36.3143 28.5097 35.8851 28.6875 35.4375 28.6875H28.6875V35.4375C28.6875 35.8851 28.5097 36.3143 28.1933 36.6307C27.8768 36.9472 27.4476 37.125 27 37.125C26.5525 37.125 26.1232 36.9472 25.8068 36.6307C25.4903 36.3143 25.3125 35.8851 25.3125 35.4375V28.6875H18.5625C18.115 28.6875 17.6857 28.5097 17.3693 28.1932C17.0528 27.8768 16.875 27.4476 16.875 27C16.875 26.5524 17.0528 26.1232 17.3693 25.8068C17.6857 25.4903 18.115 25.3125 18.5625 25.3125H25.3125V18.5625C25.3125 18.1149 25.4903 17.6857 25.8068 17.3693C26.1232 17.0528 26.5525 16.875 27 16.875C27.4476 16.875 27.8768 17.0528 28.1933 17.3693C28.5097 17.6857 28.6875 18.1149 28.6875 18.5625V25.3125H35.4375C35.8851 25.3125 36.3143 25.4903 36.6308 25.8068C36.9472 26.1232 37.125 26.5524 37.125 27Z",
                                    fill: "white"
                                })]
                            })
                        }), (D = (P = de.daoUsers) == null ? void 0 : P[1]) != null && D.full_name ? T.jsx("div", {
                            className: "-top-8 text-white absolute text-center",
                            children: T.jsxs("div", {
                                className: "bg-[#1B1B1B] pt-2 pb-2 pl-4 pr-4 rounded-md text-[12px] text-nowrap",
                                children: [(X = (W = de.daoUsers) == null ? void 0 : W[1]) != null && X.is_owner ? "👑 " : "", (q = (G = de.daoUsers) == null ? void 0 : G[1]) == null ? void 0 : q.full_name]
                            })
                        }) : null]
                    })]
                }), T.jsx("div", {
                    className: "flex flex-col justify-center w-full items-center "
                })]
            }), T.jsxs("div", {
                className: "flex flex-col justify-center flex-1 w-full items-center pb-12 pt-2",
                children: [T.jsxs("div", {
                    className: "flex-row justify-center flex pt-1",
                    children: [T.jsxs("div", {
                        className: `w-24 h-24 ${(oe = (K = de.daoUsers) == null ? void 0 : K[2]) != null && oe.id ? "circle-blue" : "circle-gray"} flex justify-center items-center`,
                        children: [(ee = (z = de.daoUsers) == null ? void 0 : z[2]) != null && ee.id ? T.jsx(Co, {
                            className: "h-16 w-16 text-2xl",
                            url: ((ce = (Q = de.daoUsers) == null ? void 0 : Q[2]) == null ? void 0 : ce.photo_url) || void 0,
                            fullName: ((Ue = (be = de.daoUsers) == null ? void 0 : be[2]) == null ? void 0 : Ue.full_name) || void 0
                        }) : T.jsx("div", {
                            className: "h-16 w-16 rounded-full flex justify-center items-center  z-50",
                            style: {
                                background: "#262626"
                            },
                            onClick: e,
                            children: T.jsxs("svg", {
                                width: "54",
                                height: "54",
                                viewBox: "0 0 54 54",
                                fill: "none",
                                xmlns: "http://www.w3.org/2000/svg",
                                children: [T.jsx("path", {
                                    opacity: "0.2",
                                    d: "M47.25 27C47.25 31.0051 46.0624 34.9202 43.8373 38.2503C41.6122 41.5804 38.4496 44.1759 34.7494 45.7086C31.0491 47.2412 26.9775 47.6423 23.0494 46.8609C19.1213 46.0796 15.5131 44.1509 12.6811 41.3189C9.84908 38.4869 7.92046 34.8787 7.13911 30.9506C6.35776 27.0225 6.75877 22.9509 8.29145 19.2507C9.82412 15.5505 12.4196 12.3878 15.7497 10.1627C19.0798 7.93764 22.9949 6.75 27 6.75C32.3706 6.75 37.5213 8.88348 41.3189 12.6811C45.1165 16.4787 47.25 21.6294 47.25 27Z",
                                    fill: "white"
                                }), T.jsx("path", {
                                    d: "M27 5.0625C22.6612 5.0625 18.4198 6.34911 14.8122 8.75964C11.2046 11.1702 8.3928 14.5963 6.7324 18.6049C5.07201 22.6134 4.63757 27.0243 5.48403 31.2798C6.3305 35.5353 8.41984 39.4441 11.4879 42.5122C14.5559 45.5802 18.4648 47.6695 22.7202 48.516C26.9757 49.3624 31.3866 48.928 35.3951 47.2676C39.4037 45.6072 42.8299 42.7954 45.2404 39.1878C47.6509 35.5802 48.9375 31.3388 48.9375 27C48.9314 21.1837 46.6181 15.6074 42.5054 11.4946C38.3926 7.38188 32.8163 5.06864 27 5.0625ZM27 45.5625C23.3287 45.5625 19.7398 44.4738 16.6872 42.4342C13.6347 40.3945 11.2554 37.4954 9.8505 34.1036C8.44554 30.7117 8.07794 26.9794 8.79418 23.3786C9.51042 19.7779 11.2783 16.4703 13.8743 13.8743C16.4704 11.2783 19.7779 9.51041 23.3786 8.79417C26.9794 8.07794 30.7117 8.44553 34.1036 9.85049C37.4954 11.2554 40.3945 13.6346 42.4342 16.6872C44.4738 19.7398 45.5625 23.3287 45.5625 27C45.5569 31.9214 43.5994 36.6396 40.1195 40.1195C36.6396 43.5994 31.9214 45.5569 27 45.5625ZM37.125 27C37.125 27.4476 36.9472 27.8768 36.6308 28.1932C36.3143 28.5097 35.8851 28.6875 35.4375 28.6875H28.6875V35.4375C28.6875 35.8851 28.5097 36.3143 28.1933 36.6307C27.8768 36.9472 27.4476 37.125 27 37.125C26.5525 37.125 26.1232 36.9472 25.8068 36.6307C25.4903 36.3143 25.3125 35.8851 25.3125 35.4375V28.6875H18.5625C18.115 28.6875 17.6857 28.5097 17.3693 28.1932C17.0528 27.8768 16.875 27.4476 16.875 27C16.875 26.5524 17.0528 26.1232 17.3693 25.8068C17.6857 25.4903 18.115 25.3125 18.5625 25.3125H25.3125V18.5625C25.3125 18.1149 25.4903 17.6857 25.8068 17.3693C26.1232 17.0528 26.5525 16.875 27 16.875C27.4476 16.875 27.8768 17.0528 28.1933 17.3693C28.5097 17.6857 28.6875 18.1149 28.6875 18.5625V25.3125H35.4375C35.8851 25.3125 36.3143 25.4903 36.6308 25.8068C36.9472 26.1232 37.125 26.5524 37.125 27Z",
                                    fill: "white"
                                })]
                            })
                        }), (ue = (se = de.daoUsers) == null ? void 0 : se[2]) != null && ue.full_name ? T.jsx("div", {
                            className: "-top-8 text-white absolute text-center",
                            children: T.jsxs("div", {
                                className: "bg-[#1B1B1B] pt-2 pb-2 pl-4 pr-4 rounded-md text-[12px] text-nowrap",
                                children: [(Me = (Te = de.daoUsers) == null ? void 0 : Te[2]) != null && Me.is_owner ? "👑 " : "", (Qe = (Ye = de.daoUsers) == null ? void 0 : Ye[2]) == null ? void 0 : Qe.full_name]
                            })
                        }) : null]
                    }), T.jsxs("div", {
                        className: "w-24 h-24 circle-blue flex justify-center items-center",
                        children: [T.jsx(Co, {
                            className: "h-16 w-16 text-2xl",
                            url: (ze = de.profile) == null ? void 0 : ze.photo_url,
                            fullName: ((ke = de.profile) == null ? void 0 : ke.full_name) || void 0
                        }), T.jsx("div", {
                            className: "-bottom-10 text-white absolute text-center",
                            children: T.jsx("div", {
                                className: "bg-[#1B1B1B] pt-2 pb-2 pl-4 pr-4 rounded-md text-[12px] text-nowrap",
                                children: de.isDaoOwner ? `👑 ${i("You’re the owner")}` : i("You")
                            })
                        })]
                    }), T.jsxs("div", {
                        className: `w-24 h-24 ${(pe = (k = de.daoUsers) == null ? void 0 : k[3]) != null && pe.id ? "circle-blue" : "circle-gray"} flex justify-center items-center`,
                        children: [(Pe = (ye = de.daoUsers) == null ? void 0 : ye[3]) != null && Pe.id ? T.jsx(Co, {
                            className: "h-16 w-16 text-2xl",
                            url: (($e = (fe = de.daoUsers) == null ? void 0 : fe[3]) == null ? void 0 : $e.photo_url) || void 0,
                            fullName: ((Be = (Le = de.daoUsers) == null ? void 0 : Le[3]) == null ? void 0 : Be.full_name) || void 0
                        }) : T.jsx("div", {
                            className: "h-16 w-16 rounded-full flex justify-center items-center z-50",
                            style: {
                                background: "#262626"
                            },
                            onClick: e,
                            children: T.jsxs("svg", {
                                width: "54",
                                height: "54",
                                viewBox: "0 0 54 54",
                                fill: "none",
                                xmlns: "http://www.w3.org/2000/svg",
                                children: [T.jsx("path", {
                                    opacity: "0.2",
                                    d: "M47.25 27C47.25 31.0051 46.0624 34.9202 43.8373 38.2503C41.6122 41.5804 38.4496 44.1759 34.7494 45.7086C31.0491 47.2412 26.9775 47.6423 23.0494 46.8609C19.1213 46.0796 15.5131 44.1509 12.6811 41.3189C9.84908 38.4869 7.92046 34.8787 7.13911 30.9506C6.35776 27.0225 6.75877 22.9509 8.29145 19.2507C9.82412 15.5505 12.4196 12.3878 15.7497 10.1627C19.0798 7.93764 22.9949 6.75 27 6.75C32.3706 6.75 37.5213 8.88348 41.3189 12.6811C45.1165 16.4787 47.25 21.6294 47.25 27Z",
                                    fill: "white"
                                }), T.jsx("path", {
                                    d: "M27 5.0625C22.6612 5.0625 18.4198 6.34911 14.8122 8.75964C11.2046 11.1702 8.3928 14.5963 6.7324 18.6049C5.07201 22.6134 4.63757 27.0243 5.48403 31.2798C6.3305 35.5353 8.41984 39.4441 11.4879 42.5122C14.5559 45.5802 18.4648 47.6695 22.7202 48.516C26.9757 49.3624 31.3866 48.928 35.3951 47.2676C39.4037 45.6072 42.8299 42.7954 45.2404 39.1878C47.6509 35.5802 48.9375 31.3388 48.9375 27C48.9314 21.1837 46.6181 15.6074 42.5054 11.4946C38.3926 7.38188 32.8163 5.06864 27 5.0625ZM27 45.5625C23.3287 45.5625 19.7398 44.4738 16.6872 42.4342C13.6347 40.3945 11.2554 37.4954 9.8505 34.1036C8.44554 30.7117 8.07794 26.9794 8.79418 23.3786C9.51042 19.7779 11.2783 16.4703 13.8743 13.8743C16.4704 11.2783 19.7779 9.51041 23.3786 8.79417C26.9794 8.07794 30.7117 8.44553 34.1036 9.85049C37.4954 11.2554 40.3945 13.6346 42.4342 16.6872C44.4738 19.7398 45.5625 23.3287 45.5625 27C45.5569 31.9214 43.5994 36.6396 40.1195 40.1195C36.6396 43.5994 31.9214 45.5569 27 45.5625ZM37.125 27C37.125 27.4476 36.9472 27.8768 36.6308 28.1932C36.3143 28.5097 35.8851 28.6875 35.4375 28.6875H28.6875V35.4375C28.6875 35.8851 28.5097 36.3143 28.1933 36.6307C27.8768 36.9472 27.4476 37.125 27 37.125C26.5525 37.125 26.1232 36.9472 25.8068 36.6307C25.4903 36.3143 25.3125 35.8851 25.3125 35.4375V28.6875H18.5625C18.115 28.6875 17.6857 28.5097 17.3693 28.1932C17.0528 27.8768 16.875 27.4476 16.875 27C16.875 26.5524 17.0528 26.1232 17.3693 25.8068C17.6857 25.4903 18.115 25.3125 18.5625 25.3125H25.3125V18.5625C25.3125 18.1149 25.4903 17.6857 25.8068 17.3693C26.1232 17.0528 26.5525 16.875 27 16.875C27.4476 16.875 27.8768 17.0528 28.1933 17.3693C28.5097 17.6857 28.6875 18.1149 28.6875 18.5625V25.3125H35.4375C35.8851 25.3125 36.3143 25.4903 36.6308 25.8068C36.9472 26.1232 37.125 26.5524 37.125 27Z",
                                    fill: "white"
                                })]
                            })
                        }), (L = (H = de.daoUsers) == null ? void 0 : H[3]) != null && L.full_name ? T.jsx("div", {
                            className: "-top-8 text-white absolute text-center",
                            children: T.jsxs("div", {
                                className: "bg-[#1B1B1B] pt-2 pb-2 pl-4 pr-4 rounded-md text-[12px] text-nowrap",
                                children: [(_e = (te = de.daoUsers) == null ? void 0 : te[3]) != null && _e.is_owner ? "👑 " : "", (ve = (ge = de.daoUsers) == null ? void 0 : ge[3]) == null ? void 0 : ve.full_name]
                            })
                        }) : null]
                    })]
                }), T.jsx("div", {
                    className: "flex flex-col justify-center w-full items-center "
                })]
            }), T.jsx("button", {
                className: "text-white px-4 py-2 rounded-lg sora-bold text-base mr-6 ml-6 mt-2",
                style: {
                    background: "#FF005C"
                },
                onClick: t,
                children: i("Leave the DAO")
            }), T.jsx("div", {
                className: "h-5"
            }), T.jsx("div", {
                className: "h-16"
            })]
        })
    })
}
)
  , rg = ({navigateTo: n}) => {
    const [e,t] = N.useState(!1)
      , [i,r] = N.useState(!1);
    N.useEffect( () => {
        setTimeout( () => t(!0), 50)
    }
    , []);
    const s = dr()
      , o = N.useCallback( (d, h) => {
        console.log("closeModal", d, h),
        t(!1),
        setTimeout( () => {
            d ? d() : s(n || -1),
            r(!1)
        }
        , 300)
    }
    , [s, n])
      , l = N.useCallback( () => {
        i || (r(!0),
        o())
    }
    , [i, o])
      , u = N.useRef({
        onClickCloseModal: o
    })
      , f = Wo();
    return N.useEffect( () => (f.pathname === "/modal/newdao" && r(!0),
    f.pathname === "/modal/tutorial" && r(!0),
    () => {
        r(!1)
    }
    ), [f.pathname]),
    T.jsxs(T.Fragment, {
        children: [T.jsx("div", {
            className: "absolute left-0 right-0 bottom-0 transition-all duration-300 z-40",
            style: e ? {} : {
                transform: "translateY(100vh)"
            },
            children: T.jsx(jo, {
                context: u.current
            })
        }), T.jsx("div", {
            className: "absolute left-0 right-0 bottom-0 top-0 bg-black bg-opacity-50 z-30 transition-opacity duration-300 backdrop-blur",
            style: e ? {} : {
                opacity: 0
            },
            onClick: l
        })]
    })
}
  , r8 = () => {
    const {onClickCloseModal: n} = wu()
      , e = dr()
      , t = N.useCallback( () => {
        localStorage.setItem("tutorialScreen", "false"),
        de.setTutorialScreen(!1),
        n( () => {
            e("/")
        }
        )
    }
    , [e, n])
      , {t: i} = hn();
    return T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "absolute left-0 right-0 bottom-0 z-40 rounded-t-xl flex flex-col justify-between items-stretch text-center pt-4 pb-6 min-h-[50vh]",
            style: {
                background: "#111111"
            },
            children: [T.jsxs("div", {
                children: [T.jsx("div", {
                    className: "text-xl text-white sora-bold mb-2",
                    children: i("Welcome at TONxDAO!")
                }), T.jsxs("div", {
                    className: "text-lg  pl-6 pr-6 text-left",
                    style: {
                        color: "#C7C7C7"
                    },
                    children: [T.jsx("br", {}), T.jsx("span", {
                        className: "sora-bold",
                        children: "1. Start Vibrating"
                    }), T.jsx("br", {}), T.jsx("span", {
                        className: "sora-bold",
                        children: "2. Add Friends"
                    }), T.jsx("br", {}), T.jsx("span", {
                        className: "sora-bold",
                        children: "3. Build your network to boost earnings!"
                    }), T.jsx("br", {}), T.jsx("span", {
                        className: "sora-bold",
                        children: "4. Earn Together"
                    }), T.jsx("br", {}), T.jsx("span", {
                        className: "sora-bold",
                        children: "Vibrate with friends for higher rewards."
                    }), T.jsx("br", {})]
                })]
            }), T.jsx("button", {
                className: "text-white px-4 py-2 rounded-lg sora-bold text-base mr-6 ml-6 mt-8",
                style: {
                    background: "#4200FF"
                },
                onClick: t,
                children: i("Next")
            })]
        })
    })
}
  , s8 = () => {
    const {t: n} = hn();
    return T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "absolute left-0 right-0 bottom-0 z-40 rounded-t-xl flex flex-col justify-end items-stretch pt-4 pb-6 transition-all duration-300 overflow-hidden",
            style: {
                background: "#111111"
            },
            children: [T.jsx("div", {
                className: "text-xl text-white sora-bold mb-2 pl-6 pr-6",
                children: n("What is Mega Farm?")
            }), T.jsxs("div", {
                className: "text-lg  pl-6 pr-6 ",
                style: {
                    color: "#C7C7C7"
                },
                children: [T.jsx("br", {}), n("Mega Farm time: "), de.displayMegaFarmTime, T.jsx("br", {}), T.jsx("br", {}), n("How does it work?"), T.jsx("br", {}), T.jsx("br", {}), n("Vibrate at Mega Farm time!"), T.jsx("br", {}), T.jsx("br", {}), T.jsxs("span", {
                    className: "flex flex-row gap-2 items-center",
                    children: [T.jsx("div", {
                        className: "w-2 h-2 bg-white rounded-full"
                    }), T.jsxs("div", {
                        children: [n("Farm alone and"), " ", T.jsxs("span", {
                            className: "sora-bold",
                            children: [n("get"), " x2 $DAO"]
                        })]
                    })]
                }), T.jsxs("span", {
                    className: "flex flex-row gap-2 items-center",
                    children: [T.jsx("div", {
                        className: "w-2 h-2 bg-white rounded-full"
                    }), T.jsxs("div", {
                        children: [n("Farm with 1 friend &"), " ", T.jsxs("span", {
                            className: "sora-bold",
                            children: [n("get"), " x4 $DAO"]
                        })]
                    })]
                }), T.jsxs("span", {
                    className: "flex flex-row gap-2 items-center",
                    children: [T.jsx("div", {
                        className: "w-2 h-2 bg-white rounded-full"
                    }), T.jsxs("div", {
                        children: [n("Farm with 2 friends &"), " ", T.jsxs("span", {
                            className: "sora-bold",
                            children: [n("get"), " x6 $DAO"]
                        })]
                    })]
                })]
            }), T.jsx("div", {
                className: "h-[20vh] mx-6 my-6 rounded-2xl megafarm-bg-image"
            }), T.jsx("div", {
                className: "h-5"
            }), T.jsx("div", {
                className: "h-16"
            })]
        })
    })
}
  , o8 = () => {
    const {onClickCloseModal: n} = wu()
      , {t: e} = hn()
      , [t,i] = N.useState(!1)
      , r = N.useCallback( () => {
        de.setGlobalLoading(!0),
        i(!0),
        a3.postDaoNewDao().then( () => (r1.success(e("DAO created successfully")),
        de.updateProfile().then( () => {}
        ))).finally( () => {
            i(!1),
            de.setGlobalLoading(!1),
            n()
        }
        )
    }
    , [n]);
    return T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "absolute left-0 right-0 bottom-0 z-40 rounded-t-xl flex flex-col justify-end items-stretch text-center pt-4 pb-6",
            style: {
                background: "#111111"
            },
            children: [T.jsx("div", {
                className: "text-xl text-white sora-bold mt-2",
                children: e("Vibe with your friends and get more $DAO!")
            }), T.jsx("div", {
                className: "h-[45vh] max-h-[400px] my-6 rounded-2xl dao-bg-image"
            }), T.jsx("div", {
                className: "text-lg  pl-6 pr-6 ",
                style: {
                    color: "#C7C7C7"
                },
                children: e("Reach higher levels and get bigger bonuses with your DAO partners")
            }), T.jsx("button", {
                className: "text-white mt-4 px-4 py-3 rounded-lg sora-bold text-base mr-6 ml-6",
                style: {
                    background: "#4200FF"
                },
                onClick: r,
                disabled: t,
                children: e("Create a DAO")
            }), T.jsx("div", {
                className: "h-5"
            }), T.jsx("div", {
                className: "h-16"
            })]
        })
    })
}
;
class a8 {
    constructor() {
        Hn(this, "lastCountedFrame", 0);
        Hn(this, "lastEnergyRestoredFrame", 0);
        Hn(this, "lastSecond", 0);
        Hn(this, "touching", !1);
        Hn(this, "touch", !1);
        Hn(this, "startTouch", 0);
        Hn(this, "endTouch", 0);
        Hn(this, "touchTime", 0);
        gp(this)
    }
    setTouch(e) {
        this.touch = e,
        e ? this.startTouch = performance.now() : (this.endTouch = performance.now(),
        this.startTouch = 0)
    }
    setTouchTime(e) {
        this.touchTime = e
    }
    setLastEnergyRestoredFrame(e) {
        this.lastEnergyRestoredFrame = e
    }
}
const Et = new a8;
Pi( () => {
    const {t: n} = hn()
      , {particlesCount: e, nextLevelScore: t, prevLevelScore: i} = de
      , r = (e - i) / (t - i) * 100;
    return T.jsxs(T.Fragment, {
        children: [T.jsx("div", {
            className: "w-full border-[#171717] h-2 bg-[#171717] rounded-2xl relative mt-2 mb-2 overflow-hidden border box-content",
            children: T.jsx("div", {
                className: "h-full top-0 left-0 right-0 rounded-2xl",
                style: {
                    width: `${r}%`,
                    background: "#4200FF"
                }
            })
        }), T.jsxs("div", {
            className: "w-full flex flex-row justify-between albert-sans-semi-bold text-xs",
            style: {
                color: "#A3A3A3"
            },
            children: [T.jsxs("div", {
                children: [n("Level"), " ", `${de.currentLevel}`]
            }), T.jsxs("div", {
                children: [n("Level"), " ", `${de.nextLevel}`]
            })]
        })]
    })
}
);
const l8 = Pi( () => {
    const {t: n} = hn()
      , {nextLevelScore: e, prevLevelScore: t} = de
      , [i,r] = N.useState(0);
    N.useEffect( () => on( () => [de.isDaoAvailable, de.daoProfit, de.particlesCount], ([o,l,u]) => {
        r(Number(o ? l : u))
    }
    , {
        fireImmediately: !0
    }), []);
    const s = (i - t) / (e - t) * 100;
    return T.jsxs(T.Fragment, {
        children: [T.jsx("div", {
            className: "w-full border-[#171717] h-2 bg-[#171717] rounded-2xl relative mt-2 mb-2 overflow-hidden border box-content",
            children: T.jsx("div", {
                className: "h-full top-0 left-0 right-0 rounded-2xl",
                style: {
                    width: `${s}%`,
                    background: "#4200FF"
                }
            })
        }), T.jsxs("div", {
            className: "w-full flex flex-row justify-between albert-sans-semi-bold text-xs",
            style: {
                color: "#A3A3A3"
            },
            children: [T.jsxs("div", {
                children: [de.currentLevel === 1 ? n("Level") : n("DAO Level"), " ", `${de.currentLevel}`]
            }), T.jsxs("div", {
                children: [de.currentLevel === 1 ? n("Level") : n("DAO Level"), " ", `${de.nextLevel}`]
            })]
        })]
    })
}
)
  , c8 = Pi( () => {
    var r;
    const {t: n} = hn()
      , {daoProfit: e} = de
      , t = ss({
        count: e,
        from: {
            count: 0
        },
        config: {
            duration: 1e3
        }
    })
      , i = dr();
    return T.jsx(T.Fragment, {
        children: ((r = de.profile) == null ? void 0 : r.dao_id) && T.jsxs("div", {
            className: "w-full flex flex-row justify-between items-center mb-2",
            children: [T.jsxs("div", {
                className: "text-sm flex flex-row text-white sora-bold items-center",
                children: [T.jsx("div", {
                    children: n("DAO Profit:")
                }), T.jsx("div", {
                    className: "coin-logo w-7 h-7 ml-1 mr-1"
                }), T.jsxs("div", {
                    children: [T.jsx(Th.span, {
                        style: {
                            fontFeatureSettings: "tnum",
                            fontVariantNumeric: "tabular-nums"
                        },
                        children: t.count.to(s => Math.floor(s))
                    }), " ", "$DAO"]
                })]
            }), T.jsx("div", {
                className: "w-8 h-8 rounded-full flex items-center justify-center",
                style: {
                    background: "#404040"
                },
                onClick: () => i("/modal/daosettings"),
                children: T.jsx("svg", {
                    width: "18",
                    height: "18",
                    viewBox: "0 0 18 18",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: T.jsx("path", {
                        fillRule: "evenodd",
                        clipRule: "evenodd",
                        d: "M6.79388 2.40149C7.35532 0.0888255 10.6444 0.0888293 11.2058 2.40149C11.3022 2.79857 11.7571 2.98701 12.1061 2.7744C14.1384 1.5361 16.4641 3.86179 15.2258 5.89409C15.0132 6.24303 15.2016 6.69797 15.5987 6.79437C17.9113 7.35581 17.9113 10.6448 15.5987 11.2063C15.2016 11.3027 15.0132 11.7576 15.2258 12.1066C16.4641 14.1389 14.1384 16.4646 12.1061 15.2263C11.7571 15.0136 11.3022 15.2021 11.2058 15.5992C10.6444 17.9118 7.35532 17.9118 6.79388 15.5992C6.69748 15.2021 6.24255 15.0136 5.8936 15.2263C3.86131 16.4646 1.53561 14.1389 2.77391 12.1066C2.98652 11.7576 2.79808 11.3027 2.401 11.2063C0.088341 10.6448 0.0883372 7.35581 2.401 6.79437C2.79808 6.69797 2.98652 6.24303 2.77391 5.89409C1.53561 3.86179 3.8613 1.5361 5.8936 2.7744C6.24255 2.98701 6.69748 2.79857 6.79388 2.40149ZM9.58617 2.79468C9.43694 2.17998 8.56273 2.17999 8.41351 2.79468C8.05082 4.28863 6.33922 4.9976 5.02638 4.19767C4.48621 3.86854 3.86805 4.4867 4.19718 5.02687C4.99711 6.33971 4.28814 8.05131 2.79419 8.41399C2.1795 8.56322 2.1795 9.43743 2.79419 9.58666C4.28814 9.94934 4.99711 11.6609 4.19718 12.9738C3.86805 13.514 4.48621 14.1321 5.02638 13.803C6.33922 13.0031 8.05082 13.712 8.41351 15.206C8.56273 15.8207 9.43694 15.8207 9.58617 15.206C9.94886 13.712 11.6605 13.0031 12.9733 13.803C13.5135 14.1321 14.1316 13.514 13.8025 12.9738C13.0026 11.6609 13.7115 9.94934 15.2055 9.58666C15.8202 9.43743 15.8202 8.56322 15.2055 8.41399C13.7115 8.05131 13.0026 6.33971 13.8025 5.02687C14.1316 4.4867 13.5135 3.86854 12.9733 4.19767C11.6605 4.9976 9.94886 4.28863 9.58617 2.79468ZM8.99984 7.33366C8.07936 7.33366 7.33317 8.07985 7.33317 9.00033C7.33317 9.9208 8.07936 10.667 8.99984 10.667C9.92031 10.667 10.6665 9.9208 10.6665 9.00033C10.6665 8.07985 9.92031 7.33366 8.99984 7.33366ZM5.6665 9.00033C5.6665 7.15938 7.15889 5.66699 8.99984 5.66699C10.8408 5.66699 12.3332 7.15938 12.3332 9.00033C12.3332 10.8413 10.8408 12.3337 8.99984 12.3337C7.15889 12.3337 5.6665 10.8413 5.6665 9.00033Z",
                        fill: "#A3A3A3"
                    })
                })
            })]
        })
    })
}
)
  , u8 = Pi( () => {
    const {t: n} = hn()
      , {particlesCount: e} = de
      , t = ss({
        count: e,
        from: {
            count: 0
        },
        config: {
            duration: 1e3
        }
    });
    return T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "w-full flex flex-row justify-between items-center",
            children: [T.jsx("div", {
                style: {
                    color: "#B9B2C4"
                },
                className: "text-base",
                children: n("Your progress:")
            }), T.jsxs("div", {
                className: "flex flex-row text-white font-bold text-base gap-2 sora-bold items-center",
                children: [T.jsx("div", {
                    className: "coin-logo w-6 h-6"
                }), T.jsx(Th.div, {
                    style: {
                        fontFeatureSettings: "tnum",
                        fontVariantNumeric: "tabular-nums"
                    },
                    children: t.count.to(i => Math.floor(i))
                }), "$DAO"]
            })]
        })
    })
}
)
  , f8 = () => {
    const {t: n} = hn()
      , [e,t] = N.useState(!1)
      , [i,r] = N.useState("");
    return N.useEffect( () => (r(n("Keep going to the next level! 🚀")),
    on( () => de.currentLevel === 1 && Et.touchTime > 0, s => {
        t(s)
    }
    )), [n]),
    e ? T.jsx("div", {
        className: "ml-auto mt-4 mr-auto border mb-5 flex flex-row items-center justify-center pl-4 pr-4 pt-2 pb-2 rounded-xl text-sm poppins-regular",
        style: {
            backgroundColor: "#262626",
            borderColor: "#2D2D2D",
            color: "#C7C7C7",
            fontFeatureSettings: "tnum",
            fontVariantNumeric: "tabular-nums"
        },
        dangerouslySetInnerHTML: {
            __html: i
        }
    }) : null
}
  , d8 = () => {
    console.log("GameTopHud");
    const [n,e] = N.useState(1);
    return N.useEffect( () => on( () => [de.daoUsersTouching, de.isMegaFarmNow, Et.touch], ([t,i,r]) => {
        e(r ? de.getDisplayMultiplier(de.isMegaFarmNow) : 0)
    }
    , {
        fireImmediately: !0
    }), []),
    T.jsxs("div", {
        className: "w-full flex flex-col justify-start items-center text-white pl-6 pr-6 pt-6 z-20",
        children: [T.jsxs("div", {
            className: "w-full flex-col items-start rounded-xl pl-4 pr-4 pt-4 pb-4 z-40",
            style: {
                background: "linear-gradient(90deg, rgba(38, 38, 38, 255) 0%, rgba(38, 38, 38, 0.5) 100%)"
            },
            children: [T.jsx(c8, {}), T.jsx(u8, {}), T.jsx(l8, {})]
        }), T.jsx(f8, {}), T.jsx("div", {
            className: "ml-auto mr-auto flex flex-row items-center justify-center sora-bold pl-4 pr-4 pt-2 pb-2 rounded-xl z-10 mt-2",
            style: {
                color: "#C7C7C7"
            },
            children: n > 1 ? T.jsxs("div", {
                className: "ml-auto mr-auto border gap-2 flex flex-row items-center justify-center sora-bold pl-4 pr-4 pt-2 pb-2 rounded-xl",
                style: {
                    backgroundColor: "#262626",
                    borderColor: "#2D2D2D",
                    color: "#C7C7C7",
                    fontFeatureSettings: "tnum",
                    fontVariantNumeric: "tabular-nums"
                },
                children: [T.jsx("span", {
                    className: "text-2xl",
                    children: "😎"
                }), " x ", n]
            }) : null
        })]
    })
}
  , xn = [["#9c9c9c", "#e9e9e9", "#999999"], ["#9c43fe", "#4cc2e9", "#101499"], ["#0013e8", "#e9d44c", "#991020"], ["#fe4365", "#fc9d9a", "#f9cdad"], ["#c3ff99", "#353535", "#ff6b6b"], ["#ff9e9d", "#8a9b0f", "#f8ca00"], ["#a8e6cf", "#dcedc1", "#ffd3b6"], ["#00b8a9", "#f8f3d4", "#f6416c"], ["#ffbe0b", "#fb5607", "#ff006e"], ["#8338ec", "#3a86ff", "#5390d9"], ["#d8e2dc", "#ffe5d9", "#ffcad4"], ["#22577a", "#38a3a5", "#57cc99"], ["#ff9f1c", "#ffbf69", "#cbf3f0"]]
  , Ha = {
    galactic_night: xn[1],
    solar_flare: xn[2],
    stellar_journey: xn[3],
    nebula_dream: xn[4],
    black_hole: xn[5],
    supernova: xn[6],
    interstellar: xn[7],
    cosmic_dawn: xn[8],
    orions_belt: xn[9],
    milky_way: xn[10]
}
  , h8 = () => {
    const [n,e] = N.useState(de.energy)
      , [t,i] = N.useState(de.maxEnergy);
    N.useEffect( () => on( () => de.energy, u => {
        e(u)
    }
    ), []),
    N.useEffect( () => on( () => de.maxEnergy, u => {
        i(u)
    }
    ), []);
    const r = n / t * 100
      , [s,o] = N.useState(null)
      , l = s ? Ha[s] : xn[0];
    return N.useEffect( () => on( () => {
        var u;
        return (u = de.profile) == null ? void 0 : u.hero
    }
    , u => {
        o(u || "galactic_night")
    }
    , {
        fireImmediately: !0
    }), []),
    T.jsx("div", {
        className: "w-full flex flex-col justify-end items-center text-white text-lg mb-5 pl-6 pr-6",
        children: T.jsx("div", {
            className: "w-full h-3 rounded-md overflow-hidden relative flex border-2 items-center justify-center box-content",
            style: {
                backgroundColor: "#1B1B1B",
                borderColor: "#1B1B1B"
            },
            children: T.jsx("div", {
                className: "overflow-hidden relative flex flex-1 w-full h-full",
                children: T.jsx("div", {
                    style: {
                        width: `${r}%`,
                        height: "100%",
                        background: `linear-gradient(90deg, ${l[0]} 0%, ${l[2]} 100%)`
                    },
                    className: "absolute left-0 top-0 bottom-0 rounded-md"
                })
            })
        })
    })
}
;
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Gp = "166"
  , p8 = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , m8 = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , Pw = 0
  , P1 = 1
  , Iw = 2
  , g8 = 3
  , Lw = 0
  , Wp = 1
  , Rc = 2
  , sr = 3
  , Dr = 0
  , ri = 1
  , lr = 2
  , is = 0
  , Oo = 1
  , Jc = 2
  , I1 = 3
  , L1 = 4
  , Nw = 5
  , Ls = 100
  , Ow = 101
  , Dw = 102
  , Uw = 103
  , Fw = 104
  , kw = 200
  , Bw = 201
  , zw = 202
  , Vw = 203
  , Ah = 204
  , Rh = 205
  , Hw = 206
  , Gw = 207
  , Ww = 208
  , jw = 209
  , Xw = 210
  , $w = 211
  , qw = 212
  , Yw = 213
  , Zw = 214
  , Kw = 0
  , Jw = 1
  , Qw = 2
  , Qc = 3
  , eb = 4
  , tb = 5
  , nb = 6
  , ib = 7
  , Nu = 0
  , rb = 1
  , sb = 2
  , Pr = 0
  , ob = 1
  , ab = 2
  , lb = 3
  , Jv = 4
  , cb = 5
  , ub = 6
  , fb = 7
  , N1 = "attached"
  , db = "detached"
  , jp = 300
  , os = 301
  , Gs = 302
  , eu = 303
  , tu = 304
  , bl = 306
  , nu = 1e3
  , Xi = 1001
  , iu = 1002
  , Ln = 1003
  , Qv = 1004
  , v8 = 1004
  , ja = 1005
  , x8 = 1005
  , ln = 1006
  , Pc = 1007
  , _8 = 1007
  , Cr = 1008
  , y8 = 1008
  , fr = 1009
  , ex = 1010
  , tx = 1011
  , dl = 1012
  , Xp = 1013
  , as = 1014
  , ii = 1015
  , Xo = 1016
  , $p = 1017
  , qp = 1018
  , zo = 1020
  , nx = 35902
  , ix = 1021
  , rx = 1022
  , qn = 1023
  , sx = 1024
  , ox = 1025
  , Do = 1026
  , Vo = 1027
  , Yp = 1028
  , Ou = 1029
  , ax = 1030
  , Zp = 1031
  , S8 = 1032
  , Kp = 1033
  , Ic = 33776
  , Lc = 33777
  , Nc = 33778
  , Oc = 33779
  , Ph = 35840
  , Ih = 35841
  , Lh = 35842
  , Nh = 35843
  , Oh = 36196
  , Dh = 37492
  , Uh = 37496
  , Fh = 37808
  , kh = 37809
  , Bh = 37810
  , zh = 37811
  , Vh = 37812
  , Hh = 37813
  , Gh = 37814
  , Wh = 37815
  , jh = 37816
  , Xh = 37817
  , $h = 37818
  , qh = 37819
  , Yh = 37820
  , Zh = 37821
  , Dc = 36492
  , Kh = 36494
  , Jh = 36495
  , lx = 36283
  , Qh = 36284
  , ep = 36285
  , tp = 36286
  , hb = 2200
  , pb = 2201
  , mb = 2202
  , ru = 2300
  , np = 2301
  , dh = 2302
  , Ao = 2400
  , Ro = 2401
  , su = 2402
  , Jp = 2500
  , cx = 2501
  , M8 = 0
  , w8 = 1
  , b8 = 2
  , gb = 3200
  , vb = 3201
  , $s = 0
  , xb = 1
  , es = ""
  , Hi = "srgb"
  , us = "srgb-linear"
  , Qp = "display-p3"
  , Du = "display-p3-linear"
  , ou = "linear"
  , $t = "srgb"
  , au = "rec709"
  , lu = "p3"
  , E8 = 0
  , wo = 7680
  , C8 = 7681
  , T8 = 7682
  , A8 = 7683
  , R8 = 34055
  , P8 = 34056
  , I8 = 5386
  , L8 = 512
  , N8 = 513
  , O8 = 514
  , D8 = 515
  , U8 = 516
  , F8 = 517
  , k8 = 518
  , O1 = 519
  , _b = 512
  , yb = 513
  , Sb = 514
  , ux = 515
  , Mb = 516
  , wb = 517
  , bb = 518
  , Eb = 519
  , cu = 35044
  , B8 = 35048
  , z8 = 35040
  , V8 = 35045
  , H8 = 35049
  , G8 = 35041
  , W8 = 35046
  , j8 = 35050
  , X8 = 35042
  , $8 = "100"
  , D1 = "300 es"
  , Tr = 2e3
  , uu = 2001;
class fs {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const Gn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let X2 = 1234567;
const Uo = Math.PI / 180
  , hl = 180 / Math.PI;
function Ai() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (Gn[n & 255] + Gn[n >> 8 & 255] + Gn[n >> 16 & 255] + Gn[n >> 24 & 255] + "-" + Gn[e & 255] + Gn[e >> 8 & 255] + "-" + Gn[e >> 16 & 15 | 64] + Gn[e >> 24 & 255] + "-" + Gn[t & 63 | 128] + Gn[t >> 8 & 255] + "-" + Gn[t >> 16 & 255] + Gn[t >> 24 & 255] + Gn[i & 255] + Gn[i >> 8 & 255] + Gn[i >> 16 & 255] + Gn[i >> 24 & 255]).toLowerCase()
}
function an(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function fx(n, e) {
    return (n % e + e) % e
}
function q8(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}
function Y8(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function Uc(n, e, t) {
    return (1 - t) * n + t * e
}
function Z8(n, e, t, i) {
    return Uc(n, e, 1 - Math.exp(-t * i))
}
function K8(n, e=1) {
    return e - Math.abs(fx(n, e * 2) - e)
}
function J8(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function Q8(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function e7(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function t7(n, e) {
    return n + Math.random() * (e - n)
}
function n7(n) {
    return n * (.5 - Math.random())
}
function i7(n) {
    n !== void 0 && (X2 = n);
    let e = X2 += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function r7(n) {
    return n * Uo
}
function s7(n) {
    return n * hl
}
function o7(n) {
    return (n & n - 1) === 0 && n !== 0
}
function a7(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function l7(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function c7(n, e, t, i, r) {
    const s = Math.cos
      , o = Math.sin
      , l = s(t / 2)
      , u = o(t / 2)
      , f = s((e + i) / 2)
      , d = o((e + i) / 2)
      , h = s((e - i) / 2)
      , m = o((e - i) / 2)
      , g = s((i - e) / 2)
      , x = o((i - e) / 2);
    switch (r) {
    case "XYX":
        n.set(l * d, u * h, u * m, l * f);
        break;
    case "YZY":
        n.set(u * m, l * d, u * h, l * f);
        break;
    case "ZXZ":
        n.set(u * h, u * m, l * d, l * f);
        break;
    case "XZX":
        n.set(l * d, u * x, u * g, l * f);
        break;
    case "YXY":
        n.set(u * g, l * d, u * x, l * f);
        break;
    case "ZYZ":
        n.set(u * x, u * g, l * d, l * f);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}
function ti(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function _t(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const Cb = {
    DEG2RAD: Uo,
    RAD2DEG: hl,
    generateUUID: Ai,
    clamp: an,
    euclideanModulo: fx,
    mapLinear: q8,
    inverseLerp: Y8,
    lerp: Uc,
    damp: Z8,
    pingpong: K8,
    smoothstep: J8,
    smootherstep: Q8,
    randInt: e7,
    randFloat: t7,
    randFloatSpread: n7,
    seededRandom: i7,
    degToRad: r7,
    radToDeg: s7,
    isPowerOfTwo: o7,
    ceilPowerOfTwo: a7,
    floorPowerOfTwo: l7,
    setQuaternionFromProperEuler: c7,
    normalize: _t,
    denormalize: ti
};
class he {
    constructor(e=0, t=0) {
        he.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(an(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class xt {
    constructor(e, t, i, r, s, o, l, u, f) {
        xt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, l, u, f)
    }
    set(e, t, i, r, s, o, l, u, f) {
        const d = this.elements;
        return d[0] = e,
        d[1] = r,
        d[2] = l,
        d[3] = t,
        d[4] = s,
        d[5] = u,
        d[6] = i,
        d[7] = o,
        d[8] = f,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , l = i[3]
          , u = i[6]
          , f = i[1]
          , d = i[4]
          , h = i[7]
          , m = i[2]
          , g = i[5]
          , x = i[8]
          , S = r[0]
          , _ = r[3]
          , v = r[6]
          , M = r[1]
          , w = r[4]
          , E = r[7]
          , O = r[2]
          , R = r[5]
          , A = r[8];
        return s[0] = o * S + l * M + u * O,
        s[3] = o * _ + l * w + u * R,
        s[6] = o * v + l * E + u * A,
        s[1] = f * S + d * M + h * O,
        s[4] = f * _ + d * w + h * R,
        s[7] = f * v + d * E + h * A,
        s[2] = m * S + g * M + x * O,
        s[5] = m * _ + g * w + x * R,
        s[8] = m * v + g * E + x * A,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , l = e[5]
          , u = e[6]
          , f = e[7]
          , d = e[8];
        return t * o * d - t * l * f - i * s * d + i * l * u + r * s * f - r * o * u
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , l = e[5]
          , u = e[6]
          , f = e[7]
          , d = e[8]
          , h = d * o - l * f
          , m = l * u - d * s
          , g = f * s - o * u
          , x = t * h + i * m + r * g;
        if (x === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / x;
        return e[0] = h * S,
        e[1] = (r * f - d * i) * S,
        e[2] = (l * i - r * o) * S,
        e[3] = m * S,
        e[4] = (d * t - r * u) * S,
        e[5] = (r * s - l * t) * S,
        e[6] = g * S,
        e[7] = (i * u - f * t) * S,
        e[8] = (o * t - i * s) * S,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, l) {
        const u = Math.cos(s)
          , f = Math.sin(s);
        return this.set(i * u, i * f, -i * (u * o + f * l) + o + e, -r * f, r * u, -r * (-f * o + u * l) + l + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(sg.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(sg.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(sg.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const sg = new xt;
function Tb(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
const u7 = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function Xa(n, e) {
    return new u7[n](e)
}
function fu(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function Ab() {
    const n = fu("canvas");
    return n.style.display = "block",
    n
}
const $2 = {};
function dx(n) {
    n in $2 || ($2[n] = !0,
    console.warn(n))
}
function f7(n, e, t) {
    return new Promise(function(i, r) {
        function s() {
            switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case n.WAIT_FAILED:
                r();
                break;
            case n.TIMEOUT_EXPIRED:
                setTimeout(s, t);
                break;
            default:
                i()
            }
        }
        setTimeout(s, t)
    }
    )
}
const q2 = new xt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , Y2 = new xt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , rd = {
    [us]: {
        transfer: ou,
        primaries: au,
        toReference: n => n,
        fromReference: n => n
    },
    [Hi]: {
        transfer: $t,
        primaries: au,
        toReference: n => n.convertSRGBToLinear(),
        fromReference: n => n.convertLinearToSRGB()
    },
    [Du]: {
        transfer: ou,
        primaries: lu,
        toReference: n => n.applyMatrix3(Y2),
        fromReference: n => n.applyMatrix3(q2)
    },
    [Qp]: {
        transfer: $t,
        primaries: lu,
        toReference: n => n.convertSRGBToLinear().applyMatrix3(Y2),
        fromReference: n => n.applyMatrix3(q2).convertLinearToSRGB()
    }
}
  , d7 = new Set([us, Du])
  , kt = {
    enabled: !0,
    _workingColorSpace: us,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(n) {
        if (!d7.has(n))
            throw new Error(`Unsupported working color space, "${n}".`);
        this._workingColorSpace = n
    },
    convert: function(n, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return n;
        const i = rd[e].toReference
          , r = rd[t].fromReference;
        return r(i(n))
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this._workingColorSpace)
    },
    getPrimaries: function(n) {
        return rd[n].primaries
    },
    getTransfer: function(n) {
        return n === es ? ou : rd[n].transfer
    }
};
function nl(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function og(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let _a;
class Rb {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            _a === void 0 && (_a = fu("canvas")),
            _a.width = e.width,
            _a.height = e.height;
            const i = _a.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = _a
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = fu("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = nl(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(nl(t[i] / 255) * 255) : t[i] = nl(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let h7 = 0;
class Po {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: h7++
        }),
        this.uuid = Ai(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, l = r.length; o < l; o++)
                    r[o].isDataTexture ? s.push(ag(r[o].image)) : s.push(ag(r[o]))
            } else
                s = ag(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function ag(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? Rb.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let p7 = 0;
class en extends fs {
    constructor(e=en.DEFAULT_IMAGE, t=en.DEFAULT_MAPPING, i=Xi, r=Xi, s=ln, o=Cr, l=qn, u=fr, f=en.DEFAULT_ANISOTROPY, d=es) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: p7++
        }),
        this.uuid = Ai(),
        this.name = "",
        this.source = new Po(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = f,
        this.format = l,
        this.internalFormat = null,
        this.type = u,
        this.offset = new he(0,0),
        this.repeat = new he(1,1),
        this.center = new he(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new xt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = d,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== jp)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case nu:
                e.x = e.x - Math.floor(e.x);
                break;
            case Xi:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case iu:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case nu:
                e.y = e.y - Math.floor(e.y);
                break;
            case Xi:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case iu:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
en.DEFAULT_IMAGE = null;
en.DEFAULT_MAPPING = jp;
en.DEFAULT_ANISOTROPY = 1;
class Bt {
    constructor(e=0, t=0, i=0, r=1) {
        Bt.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const u = e.elements
          , f = u[0]
          , d = u[4]
          , h = u[8]
          , m = u[1]
          , g = u[5]
          , x = u[9]
          , S = u[2]
          , _ = u[6]
          , v = u[10];
        if (Math.abs(d - m) < .01 && Math.abs(h - S) < .01 && Math.abs(x - _) < .01) {
            if (Math.abs(d + m) < .1 && Math.abs(h + S) < .1 && Math.abs(x + _) < .1 && Math.abs(f + g + v - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const w = (f + 1) / 2
              , E = (g + 1) / 2
              , O = (v + 1) / 2
              , R = (d + m) / 4
              , A = (h + S) / 4
              , F = (x + _) / 4;
            return w > E && w > O ? w < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(w),
            r = R / i,
            s = A / i) : E > O ? E < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(E),
            i = R / r,
            s = F / r) : O < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(O),
            i = A / s,
            r = F / s),
            this.set(i, r, s, t),
            this
        }
        let M = Math.sqrt((_ - x) * (_ - x) + (h - S) * (h - S) + (m - d) * (m - d));
        return Math.abs(M) < .001 && (M = 1),
        this.x = (_ - x) / M,
        this.y = (h - S) / M,
        this.z = (m - d) / M,
        this.w = Math.acos((f + g + v - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class Pb extends fs {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Bt(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Bt(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: ln,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, i);
        const s = new en(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);
        s.flipY = !1,
        s.generateMipmaps = i.generateMipmaps,
        s.internalFormat = i.internalFormat,
        this.textures = [];
        const o = i.count;
        for (let l = 0; l < o; l++)
            this.textures[l] = s.clone(),
            this.textures[l].isRenderTargetTexture = !0;
        this.depthBuffer = i.depthBuffer,
        this.stencilBuffer = i.stencilBuffer,
        this.resolveDepthBuffer = i.resolveDepthBuffer,
        this.resolveStencilBuffer = i.resolveStencilBuffer,
        this.depthTexture = i.depthTexture,
        this.samples = i.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, i=1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e,
            this.height = t,
            this.depth = i;
            for (let r = 0, s = this.textures.length; r < s; r++)
                this.textures[r].image.width = e,
                this.textures[r].image.height = t,
                this.textures[r].image.depth = i;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let i = 0, r = e.textures.length; i < r; i++)
            this.textures[i] = e.textures[i].clone(),
            this.textures[i].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Po(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class qi extends Pb {
    constructor(e=1, t=1, i={}) {
        super(e, t, i),
        this.isWebGLRenderTarget = !0
    }
}
class em extends en {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = Ln,
        this.minFilter = Ln,
        this.wrapR = Xi,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class m7 extends qi {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = i,
        this.texture = new em(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class hx extends en {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = Ln,
        this.minFilter = Ln,
        this.wrapR = Xi,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class g7 extends qi {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGL3DRenderTarget = !0,
        this.depth = i,
        this.texture = new hx(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class mi {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, l) {
        let u = i[r + 0]
          , f = i[r + 1]
          , d = i[r + 2]
          , h = i[r + 3];
        const m = s[o + 0]
          , g = s[o + 1]
          , x = s[o + 2]
          , S = s[o + 3];
        if (l === 0) {
            e[t + 0] = u,
            e[t + 1] = f,
            e[t + 2] = d,
            e[t + 3] = h;
            return
        }
        if (l === 1) {
            e[t + 0] = m,
            e[t + 1] = g,
            e[t + 2] = x,
            e[t + 3] = S;
            return
        }
        if (h !== S || u !== m || f !== g || d !== x) {
            let _ = 1 - l;
            const v = u * m + f * g + d * x + h * S
              , M = v >= 0 ? 1 : -1
              , w = 1 - v * v;
            if (w > Number.EPSILON) {
                const O = Math.sqrt(w)
                  , R = Math.atan2(O, v * M);
                _ = Math.sin(_ * R) / O,
                l = Math.sin(l * R) / O
            }
            const E = l * M;
            if (u = u * _ + m * E,
            f = f * _ + g * E,
            d = d * _ + x * E,
            h = h * _ + S * E,
            _ === 1 - l) {
                const O = 1 / Math.sqrt(u * u + f * f + d * d + h * h);
                u *= O,
                f *= O,
                d *= O,
                h *= O
            }
        }
        e[t] = u,
        e[t + 1] = f,
        e[t + 2] = d,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const l = i[r]
          , u = i[r + 1]
          , f = i[r + 2]
          , d = i[r + 3]
          , h = s[o]
          , m = s[o + 1]
          , g = s[o + 2]
          , x = s[o + 3];
        return e[t] = l * x + d * h + u * g - f * m,
        e[t + 1] = u * x + d * m + f * h - l * g,
        e[t + 2] = f * x + d * g + l * m - u * h,
        e[t + 3] = d * x - l * h - u * m - f * g,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , l = Math.cos
          , u = Math.sin
          , f = l(i / 2)
          , d = l(r / 2)
          , h = l(s / 2)
          , m = u(i / 2)
          , g = u(r / 2)
          , x = u(s / 2);
        switch (o) {
        case "XYZ":
            this._x = m * d * h + f * g * x,
            this._y = f * g * h - m * d * x,
            this._z = f * d * x + m * g * h,
            this._w = f * d * h - m * g * x;
            break;
        case "YXZ":
            this._x = m * d * h + f * g * x,
            this._y = f * g * h - m * d * x,
            this._z = f * d * x - m * g * h,
            this._w = f * d * h + m * g * x;
            break;
        case "ZXY":
            this._x = m * d * h - f * g * x,
            this._y = f * g * h + m * d * x,
            this._z = f * d * x + m * g * h,
            this._w = f * d * h - m * g * x;
            break;
        case "ZYX":
            this._x = m * d * h - f * g * x,
            this._y = f * g * h + m * d * x,
            this._z = f * d * x - m * g * h,
            this._w = f * d * h + m * g * x;
            break;
        case "YZX":
            this._x = m * d * h + f * g * x,
            this._y = f * g * h + m * d * x,
            this._z = f * d * x - m * g * h,
            this._w = f * d * h - m * g * x;
            break;
        case "XZY":
            this._x = m * d * h - f * g * x,
            this._y = f * g * h - m * d * x,
            this._z = f * d * x + m * g * h,
            this._w = f * d * h + m * g * x;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , l = t[5]
          , u = t[9]
          , f = t[2]
          , d = t[6]
          , h = t[10]
          , m = i + l + h;
        if (m > 0) {
            const g = .5 / Math.sqrt(m + 1);
            this._w = .25 / g,
            this._x = (d - u) * g,
            this._y = (s - f) * g,
            this._z = (o - r) * g
        } else if (i > l && i > h) {
            const g = 2 * Math.sqrt(1 + i - l - h);
            this._w = (d - u) / g,
            this._x = .25 * g,
            this._y = (r + o) / g,
            this._z = (s + f) / g
        } else if (l > h) {
            const g = 2 * Math.sqrt(1 + l - i - h);
            this._w = (s - f) / g,
            this._x = (r + o) / g,
            this._y = .25 * g,
            this._z = (u + d) / g
        } else {
            const g = 2 * Math.sqrt(1 + h - i - l);
            this._w = (o - r) / g,
            this._x = (s + f) / g,
            this._y = (u + d) / g,
            this._z = .25 * g
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(an(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , l = t._x
          , u = t._y
          , f = t._z
          , d = t._w;
        return this._x = i * d + o * l + r * f - s * u,
        this._y = r * d + o * u + s * l - i * f,
        this._z = s * d + o * f + i * u - r * l,
        this._w = o * d - i * l - r * u - s * f,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let l = o * e._w + i * e._x + r * e._y + s * e._z;
        if (l < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        l = -l) : this.copy(e),
        l >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const u = 1 - l * l;
        if (u <= Number.EPSILON) {
            const g = 1 - t;
            return this._w = g * o + t * this._w,
            this._x = g * i + t * this._x,
            this._y = g * r + t * this._y,
            this._z = g * s + t * this._z,
            this.normalize(),
            this
        }
        const f = Math.sqrt(u)
          , d = Math.atan2(f, l)
          , h = Math.sin((1 - t) * d) / f
          , m = Math.sin(t * d) / f;
        return this._w = o * h + this._w * m,
        this._x = i * h + this._x * m,
        this._y = r * h + this._y * m,
        this._z = s * h + this._z * m,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , i = Math.random()
          , r = Math.sqrt(1 - i)
          , s = Math.sqrt(i);
        return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class B {
    constructor(e=0, t=0, i=0) {
        B.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(Z2.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(Z2.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , l = e.z
          , u = e.w
          , f = 2 * (o * r - l * i)
          , d = 2 * (l * t - s * r)
          , h = 2 * (s * i - o * t);
        return this.x = t + u * f + o * h - l * d,
        this.y = i + u * d + l * f - s * h,
        this.z = r + u * h + s * d - o * f,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , l = t.y
          , u = t.z;
        return this.x = r * u - s * l,
        this.y = s * o - i * u,
        this.z = i * l - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return lg.copy(this).projectOnVector(e),
        this.sub(lg)
    }
    reflect(e) {
        return this.sub(lg.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(an(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , i = Math.sqrt(1 - t * t);
        return this.x = i * Math.cos(e),
        this.y = t,
        this.z = i * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const lg = new B
  , Z2 = new mi;
class si {
    constructor(e=new B(1 / 0,1 / 0,1 / 0), t=new B(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(nr.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(nr.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = nr.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const s = i.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, l = s.count; o < l; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, nr) : nr.fromBufferAttribute(s, o),
                    nr.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(nr);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                sd.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(),
                sd.copy(i.boundingBox)),
                sd.applyMatrix4(e.matrixWorld),
                this.union(sd)
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, nr),
        nr.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(rc),
        od.subVectors(this.max, rc),
        ya.subVectors(e.a, rc),
        Sa.subVectors(e.b, rc),
        Ma.subVectors(e.c, rc),
        ws.subVectors(Sa, ya),
        bs.subVectors(Ma, Sa),
        uo.subVectors(ya, Ma);
        let t = [0, -ws.z, ws.y, 0, -bs.z, bs.y, 0, -uo.z, uo.y, ws.z, 0, -ws.x, bs.z, 0, -bs.x, uo.z, 0, -uo.x, -ws.y, ws.x, 0, -bs.y, bs.x, 0, -uo.y, uo.x, 0];
        return !cg(t, ya, Sa, Ma, od) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !cg(t, ya, Sa, Ma, od)) ? !1 : (ad.crossVectors(ws, bs),
        t = [ad.x, ad.y, ad.z],
        cg(t, ya, Sa, Ma, od))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, nr).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(nr).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : ($r[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        $r[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        $r[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        $r[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        $r[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        $r[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        $r[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        $r[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints($r),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const $r = [new B, new B, new B, new B, new B, new B, new B, new B]
  , nr = new B
  , sd = new si
  , ya = new B
  , Sa = new B
  , Ma = new B
  , ws = new B
  , bs = new B
  , uo = new B
  , rc = new B
  , od = new B
  , ad = new B
  , fo = new B;
function cg(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        fo.fromArray(n, s);
        const l = r.x * Math.abs(fo.x) + r.y * Math.abs(fo.y) + r.z * Math.abs(fo.z)
          , u = e.dot(fo)
          , f = t.dot(fo)
          , d = i.dot(fo);
        if (Math.max(-Math.max(u, f, d), Math.min(u, f, d)) > l)
            return !1
    }
    return !0
}
const v7 = new si
  , sc = new B
  , ug = new B;
class Yn {
    constructor(e=new B, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : v7.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        sc.subVectors(e, this.center);
        const t = sc.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(sc, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (ug.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(sc.copy(e.center).add(ug)),
        this.expandByPoint(sc.copy(e.center).sub(ug))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const qr = new B
  , fg = new B
  , ld = new B
  , Es = new B
  , dg = new B
  , cd = new B
  , hg = new B;
class El {
    constructor(e=new B, t=new B(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, qr)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = qr.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (qr.copy(this.origin).addScaledVector(this.direction, t),
        qr.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        fg.copy(e).add(t).multiplyScalar(.5),
        ld.copy(t).sub(e).normalize(),
        Es.copy(this.origin).sub(fg);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(ld)
          , l = Es.dot(this.direction)
          , u = -Es.dot(ld)
          , f = Es.lengthSq()
          , d = Math.abs(1 - o * o);
        let h, m, g, x;
        if (d > 0)
            if (h = o * u - l,
            m = o * l - u,
            x = s * d,
            h >= 0)
                if (m >= -x)
                    if (m <= x) {
                        const S = 1 / d;
                        h *= S,
                        m *= S,
                        g = h * (h + o * m + 2 * l) + m * (o * h + m + 2 * u) + f
                    } else
                        m = s,
                        h = Math.max(0, -(o * m + l)),
                        g = -h * h + m * (m + 2 * u) + f;
                else
                    m = -s,
                    h = Math.max(0, -(o * m + l)),
                    g = -h * h + m * (m + 2 * u) + f;
            else
                m <= -x ? (h = Math.max(0, -(-o * s + l)),
                m = h > 0 ? -s : Math.min(Math.max(-s, -u), s),
                g = -h * h + m * (m + 2 * u) + f) : m <= x ? (h = 0,
                m = Math.min(Math.max(-s, -u), s),
                g = m * (m + 2 * u) + f) : (h = Math.max(0, -(o * s + l)),
                m = h > 0 ? s : Math.min(Math.max(-s, -u), s),
                g = -h * h + m * (m + 2 * u) + f);
        else
            m = o > 0 ? -s : s,
            h = Math.max(0, -(o * m + l)),
            g = -h * h + m * (m + 2 * u) + f;
        return i && i.copy(this.origin).addScaledVector(this.direction, h),
        r && r.copy(fg).addScaledVector(ld, m),
        g
    }
    intersectSphere(e, t) {
        qr.subVectors(e.center, this.origin);
        const i = qr.dot(this.direction)
          , r = qr.dot(qr) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , l = i - o
          , u = i + o;
        return u < 0 ? null : l < 0 ? this.at(u, t) : this.at(l, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, l, u;
        const f = 1 / this.direction.x
          , d = 1 / this.direction.y
          , h = 1 / this.direction.z
          , m = this.origin;
        return f >= 0 ? (i = (e.min.x - m.x) * f,
        r = (e.max.x - m.x) * f) : (i = (e.max.x - m.x) * f,
        r = (e.min.x - m.x) * f),
        d >= 0 ? (s = (e.min.y - m.y) * d,
        o = (e.max.y - m.y) * d) : (s = (e.max.y - m.y) * d,
        o = (e.min.y - m.y) * d),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        h >= 0 ? (l = (e.min.z - m.z) * h,
        u = (e.max.z - m.z) * h) : (l = (e.max.z - m.z) * h,
        u = (e.min.z - m.z) * h),
        i > u || l > r) || ((l > i || i !== i) && (i = l),
        (u < r || r !== r) && (r = u),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, qr) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        dg.subVectors(t, e),
        cd.subVectors(i, e),
        hg.crossVectors(dg, cd);
        let o = this.direction.dot(hg), l;
        if (o > 0) {
            if (r)
                return null;
            l = 1
        } else if (o < 0)
            l = -1,
            o = -o;
        else
            return null;
        Es.subVectors(this.origin, e);
        const u = l * this.direction.dot(cd.crossVectors(Es, cd));
        if (u < 0)
            return null;
        const f = l * this.direction.dot(dg.cross(Es));
        if (f < 0 || u + f > o)
            return null;
        const d = -l * Es.dot(hg);
        return d < 0 ? null : this.at(d / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class ct {
    constructor(e, t, i, r, s, o, l, u, f, d, h, m, g, x, S, _) {
        ct.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, l, u, f, d, h, m, g, x, S, _)
    }
    set(e, t, i, r, s, o, l, u, f, d, h, m, g, x, S, _) {
        const v = this.elements;
        return v[0] = e,
        v[4] = t,
        v[8] = i,
        v[12] = r,
        v[1] = s,
        v[5] = o,
        v[9] = l,
        v[13] = u,
        v[2] = f,
        v[6] = d,
        v[10] = h,
        v[14] = m,
        v[3] = g,
        v[7] = x,
        v[11] = S,
        v[15] = _,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new ct().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / wa.setFromMatrixColumn(e, 0).length()
          , s = 1 / wa.setFromMatrixColumn(e, 1).length()
          , o = 1 / wa.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , l = Math.sin(i)
          , u = Math.cos(r)
          , f = Math.sin(r)
          , d = Math.cos(s)
          , h = Math.sin(s);
        if (e.order === "XYZ") {
            const m = o * d
              , g = o * h
              , x = l * d
              , S = l * h;
            t[0] = u * d,
            t[4] = -u * h,
            t[8] = f,
            t[1] = g + x * f,
            t[5] = m - S * f,
            t[9] = -l * u,
            t[2] = S - m * f,
            t[6] = x + g * f,
            t[10] = o * u
        } else if (e.order === "YXZ") {
            const m = u * d
              , g = u * h
              , x = f * d
              , S = f * h;
            t[0] = m + S * l,
            t[4] = x * l - g,
            t[8] = o * f,
            t[1] = o * h,
            t[5] = o * d,
            t[9] = -l,
            t[2] = g * l - x,
            t[6] = S + m * l,
            t[10] = o * u
        } else if (e.order === "ZXY") {
            const m = u * d
              , g = u * h
              , x = f * d
              , S = f * h;
            t[0] = m - S * l,
            t[4] = -o * h,
            t[8] = x + g * l,
            t[1] = g + x * l,
            t[5] = o * d,
            t[9] = S - m * l,
            t[2] = -o * f,
            t[6] = l,
            t[10] = o * u
        } else if (e.order === "ZYX") {
            const m = o * d
              , g = o * h
              , x = l * d
              , S = l * h;
            t[0] = u * d,
            t[4] = x * f - g,
            t[8] = m * f + S,
            t[1] = u * h,
            t[5] = S * f + m,
            t[9] = g * f - x,
            t[2] = -f,
            t[6] = l * u,
            t[10] = o * u
        } else if (e.order === "YZX") {
            const m = o * u
              , g = o * f
              , x = l * u
              , S = l * f;
            t[0] = u * d,
            t[4] = S - m * h,
            t[8] = x * h + g,
            t[1] = h,
            t[5] = o * d,
            t[9] = -l * d,
            t[2] = -f * d,
            t[6] = g * h + x,
            t[10] = m - S * h
        } else if (e.order === "XZY") {
            const m = o * u
              , g = o * f
              , x = l * u
              , S = l * f;
            t[0] = u * d,
            t[4] = -h,
            t[8] = f * d,
            t[1] = m * h + S,
            t[5] = o * d,
            t[9] = g * h - x,
            t[2] = x * h - g,
            t[6] = l * d,
            t[10] = S * h + m
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(x7, e, _7)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return bi.subVectors(e, t),
        bi.lengthSq() === 0 && (bi.z = 1),
        bi.normalize(),
        Cs.crossVectors(i, bi),
        Cs.lengthSq() === 0 && (Math.abs(i.z) === 1 ? bi.x += 1e-4 : bi.z += 1e-4,
        bi.normalize(),
        Cs.crossVectors(i, bi)),
        Cs.normalize(),
        ud.crossVectors(bi, Cs),
        r[0] = Cs.x,
        r[4] = ud.x,
        r[8] = bi.x,
        r[1] = Cs.y,
        r[5] = ud.y,
        r[9] = bi.y,
        r[2] = Cs.z,
        r[6] = ud.z,
        r[10] = bi.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , l = i[4]
          , u = i[8]
          , f = i[12]
          , d = i[1]
          , h = i[5]
          , m = i[9]
          , g = i[13]
          , x = i[2]
          , S = i[6]
          , _ = i[10]
          , v = i[14]
          , M = i[3]
          , w = i[7]
          , E = i[11]
          , O = i[15]
          , R = r[0]
          , A = r[4]
          , F = r[8]
          , I = r[12]
          , P = r[1]
          , D = r[5]
          , W = r[9]
          , X = r[13]
          , G = r[2]
          , q = r[6]
          , K = r[10]
          , oe = r[14]
          , z = r[3]
          , ee = r[7]
          , Q = r[11]
          , ce = r[15];
        return s[0] = o * R + l * P + u * G + f * z,
        s[4] = o * A + l * D + u * q + f * ee,
        s[8] = o * F + l * W + u * K + f * Q,
        s[12] = o * I + l * X + u * oe + f * ce,
        s[1] = d * R + h * P + m * G + g * z,
        s[5] = d * A + h * D + m * q + g * ee,
        s[9] = d * F + h * W + m * K + g * Q,
        s[13] = d * I + h * X + m * oe + g * ce,
        s[2] = x * R + S * P + _ * G + v * z,
        s[6] = x * A + S * D + _ * q + v * ee,
        s[10] = x * F + S * W + _ * K + v * Q,
        s[14] = x * I + S * X + _ * oe + v * ce,
        s[3] = M * R + w * P + E * G + O * z,
        s[7] = M * A + w * D + E * q + O * ee,
        s[11] = M * F + w * W + E * K + O * Q,
        s[15] = M * I + w * X + E * oe + O * ce,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , l = e[5]
          , u = e[9]
          , f = e[13]
          , d = e[2]
          , h = e[6]
          , m = e[10]
          , g = e[14]
          , x = e[3]
          , S = e[7]
          , _ = e[11]
          , v = e[15];
        return x * (+s * u * h - r * f * h - s * l * m + i * f * m + r * l * g - i * u * g) + S * (+t * u * g - t * f * m + s * o * m - r * o * g + r * f * d - s * u * d) + _ * (+t * f * h - t * l * g - s * o * h + i * o * g + s * l * d - i * f * d) + v * (-r * l * d - t * u * h + t * l * m + r * o * h - i * o * m + i * u * d)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , l = e[5]
          , u = e[6]
          , f = e[7]
          , d = e[8]
          , h = e[9]
          , m = e[10]
          , g = e[11]
          , x = e[12]
          , S = e[13]
          , _ = e[14]
          , v = e[15]
          , M = h * _ * f - S * m * f + S * u * g - l * _ * g - h * u * v + l * m * v
          , w = x * m * f - d * _ * f - x * u * g + o * _ * g + d * u * v - o * m * v
          , E = d * S * f - x * h * f + x * l * g - o * S * g - d * l * v + o * h * v
          , O = x * h * u - d * S * u - x * l * m + o * S * m + d * l * _ - o * h * _
          , R = t * M + i * w + r * E + s * O;
        if (R === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const A = 1 / R;
        return e[0] = M * A,
        e[1] = (S * m * s - h * _ * s - S * r * g + i * _ * g + h * r * v - i * m * v) * A,
        e[2] = (l * _ * s - S * u * s + S * r * f - i * _ * f - l * r * v + i * u * v) * A,
        e[3] = (h * u * s - l * m * s - h * r * f + i * m * f + l * r * g - i * u * g) * A,
        e[4] = w * A,
        e[5] = (d * _ * s - x * m * s + x * r * g - t * _ * g - d * r * v + t * m * v) * A,
        e[6] = (x * u * s - o * _ * s - x * r * f + t * _ * f + o * r * v - t * u * v) * A,
        e[7] = (o * m * s - d * u * s + d * r * f - t * m * f - o * r * g + t * u * g) * A,
        e[8] = E * A,
        e[9] = (x * h * s - d * S * s - x * i * g + t * S * g + d * i * v - t * h * v) * A,
        e[10] = (o * S * s - x * l * s + x * i * f - t * S * f - o * i * v + t * l * v) * A,
        e[11] = (d * l * s - o * h * s - d * i * f + t * h * f + o * i * g - t * l * g) * A,
        e[12] = O * A,
        e[13] = (d * S * r - x * h * r + x * i * m - t * S * m - d * i * _ + t * h * _) * A,
        e[14] = (x * l * r - o * S * r - x * i * u + t * S * u + o * i * _ - t * l * _) * A,
        e[15] = (o * h * r - d * l * r + d * i * u - t * h * u - o * i * m + t * l * m) * A,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , l = e.y
          , u = e.z
          , f = s * o
          , d = s * l;
        return this.set(f * o + i, f * l - r * u, f * u + r * l, 0, f * l + r * u, d * l + i, d * u - r * o, 0, f * u - r * l, d * u + r * o, s * u * u + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , l = t._z
          , u = t._w
          , f = s + s
          , d = o + o
          , h = l + l
          , m = s * f
          , g = s * d
          , x = s * h
          , S = o * d
          , _ = o * h
          , v = l * h
          , M = u * f
          , w = u * d
          , E = u * h
          , O = i.x
          , R = i.y
          , A = i.z;
        return r[0] = (1 - (S + v)) * O,
        r[1] = (g + E) * O,
        r[2] = (x - w) * O,
        r[3] = 0,
        r[4] = (g - E) * R,
        r[5] = (1 - (m + v)) * R,
        r[6] = (_ + M) * R,
        r[7] = 0,
        r[8] = (x + w) * A,
        r[9] = (_ - M) * A,
        r[10] = (1 - (m + S)) * A,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = wa.set(r[0], r[1], r[2]).length();
        const o = wa.set(r[4], r[5], r[6]).length()
          , l = wa.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        ir.copy(this);
        const f = 1 / s
          , d = 1 / o
          , h = 1 / l;
        return ir.elements[0] *= f,
        ir.elements[1] *= f,
        ir.elements[2] *= f,
        ir.elements[4] *= d,
        ir.elements[5] *= d,
        ir.elements[6] *= d,
        ir.elements[8] *= h,
        ir.elements[9] *= h,
        ir.elements[10] *= h,
        t.setFromRotationMatrix(ir),
        i.x = s,
        i.y = o,
        i.z = l,
        this
    }
    makePerspective(e, t, i, r, s, o, l=Tr) {
        const u = this.elements
          , f = 2 * s / (t - e)
          , d = 2 * s / (i - r)
          , h = (t + e) / (t - e)
          , m = (i + r) / (i - r);
        let g, x;
        if (l === Tr)
            g = -(o + s) / (o - s),
            x = -2 * o * s / (o - s);
        else if (l === uu)
            g = -o / (o - s),
            x = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
        return u[0] = f,
        u[4] = 0,
        u[8] = h,
        u[12] = 0,
        u[1] = 0,
        u[5] = d,
        u[9] = m,
        u[13] = 0,
        u[2] = 0,
        u[6] = 0,
        u[10] = g,
        u[14] = x,
        u[3] = 0,
        u[7] = 0,
        u[11] = -1,
        u[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o, l=Tr) {
        const u = this.elements
          , f = 1 / (t - e)
          , d = 1 / (i - r)
          , h = 1 / (o - s)
          , m = (t + e) * f
          , g = (i + r) * d;
        let x, S;
        if (l === Tr)
            x = (o + s) * h,
            S = -2 * h;
        else if (l === uu)
            x = s * h,
            S = -1 * h;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
        return u[0] = 2 * f,
        u[4] = 0,
        u[8] = 0,
        u[12] = -m,
        u[1] = 0,
        u[5] = 2 * d,
        u[9] = 0,
        u[13] = -g,
        u[2] = 0,
        u[6] = 0,
        u[10] = S,
        u[14] = -x,
        u[3] = 0,
        u[7] = 0,
        u[11] = 0,
        u[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const wa = new B
  , ir = new ct
  , x7 = new B(0,0,0)
  , _7 = new B(1,1,1)
  , Cs = new B
  , ud = new B
  , bi = new B
  , K2 = new ct
  , J2 = new mi;
class Ri {
    constructor(e=0, t=0, i=0, r=Ri.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , l = r[8]
          , u = r[1]
          , f = r[5]
          , d = r[9]
          , h = r[2]
          , m = r[6]
          , g = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(an(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, g),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(m, f),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-an(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(l, g),
            this._z = Math.atan2(u, f)) : (this._y = Math.atan2(-h, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(an(m, -1, 1)),
            Math.abs(m) < .9999999 ? (this._y = Math.atan2(-h, g),
            this._z = Math.atan2(-o, f)) : (this._y = 0,
            this._z = Math.atan2(u, s));
            break;
        case "ZYX":
            this._y = Math.asin(-an(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(m, g),
            this._z = Math.atan2(u, s)) : (this._x = 0,
            this._z = Math.atan2(-o, f));
            break;
        case "YZX":
            this._z = Math.asin(an(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(-d, f),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(l, g));
            break;
        case "XZY":
            this._z = Math.asin(-an(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(m, f),
            this._y = Math.atan2(l, s)) : (this._x = Math.atan2(-d, g),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return K2.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(K2, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return J2.setFromEuler(this),
        this.setFromQuaternion(J2, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Ri.DEFAULT_ORDER = "XYZ";
class Fo {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let y7 = 0;
const Q2 = new B
  , ba = new mi
  , Yr = new ct
  , fd = new B
  , oc = new B
  , S7 = new B
  , M7 = new mi
  , eS = new B(1,0,0)
  , tS = new B(0,1,0)
  , nS = new B(0,0,1)
  , iS = {
    type: "added"
}
  , w7 = {
    type: "removed"
}
  , Ea = {
    type: "childadded",
    child: null
}
  , pg = {
    type: "childremoved",
    child: null
};
class It extends fs {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: y7++
        }),
        this.uuid = Ai(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = It.DEFAULT_UP.clone();
        const e = new B
          , t = new Ri
          , i = new mi
          , r = new B(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new ct
            },
            normalMatrix: {
                value: new xt
            }
        }),
        this.matrix = new ct,
        this.matrixWorld = new ct,
        this.matrixAutoUpdate = It.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = It.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Fo,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return ba.setFromAxisAngle(e, t),
        this.quaternion.multiply(ba),
        this
    }
    rotateOnWorldAxis(e, t) {
        return ba.setFromAxisAngle(e, t),
        this.quaternion.premultiply(ba),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(eS, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(tS, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(nS, e)
    }
    translateOnAxis(e, t) {
        return Q2.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Q2.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(eS, e)
    }
    translateY(e) {
        return this.translateOnAxis(tS, e)
    }
    translateZ(e) {
        return this.translateOnAxis(nS, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Yr.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? fd.copy(e) : fd.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        oc.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Yr.lookAt(oc, fd, this.up) : Yr.lookAt(fd, oc, this.up),
        this.quaternion.setFromRotationMatrix(Yr),
        r && (Yr.extractRotation(r.matrixWorld),
        ba.setFromRotationMatrix(Yr),
        this.quaternion.premultiply(ba.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(iS),
        Ea.child = e,
        this.dispatchEvent(Ea),
        Ea.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(w7),
        pg.child = e,
        this.dispatchEvent(pg),
        pg.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Yr.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Yr.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Yr),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(iS),
        Ea.child = e,
        this.dispatchEvent(Ea),
        Ea.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, i=[]) {
        this[e] === t && i.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++)
            r[s].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(oc, e, S7),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(oc, M7, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++)
                r[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (r.type = "BatchedMesh",
        r.perObjectFrustumCulled = this.perObjectFrustumCulled,
        r.sortObjects = this.sortObjects,
        r.drawRanges = this._drawRanges,
        r.reservedRanges = this._reservedRanges,
        r.visibility = this._visibility,
        r.active = this._active,
        r.bounds = this._bounds.map(l => ({
            boxInitialized: l.boxInitialized,
            boxMin: l.box.min.toArray(),
            boxMax: l.box.max.toArray(),
            sphereInitialized: l.sphereInitialized,
            sphereRadius: l.sphere.radius,
            sphereCenter: l.sphere.center.toArray()
        })),
        r.maxInstanceCount = this._maxInstanceCount,
        r.maxVertexCount = this._maxVertexCount,
        r.maxIndexCount = this._maxIndexCount,
        r.geometryInitialized = this._geometryInitialized,
        r.geometryCount = this._geometryCount,
        r.matricesTexture = this._matricesTexture.toJSON(e),
        this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius
        }),
        this.boundingBox !== null && (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray()
        }));
        function s(l, u) {
            return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)),
            u.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const l = this.geometry.parameters;
            if (l !== void 0 && l.shapes !== void 0) {
                const u = l.shapes;
                if (Array.isArray(u))
                    for (let f = 0, d = u.length; f < d; f++) {
                        const h = u[f];
                        s(e.shapes, h)
                    }
                else
                    s(e.shapes, u)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const l = [];
                for (let u = 0, f = this.material.length; u < f; u++)
                    l.push(s(e.materials, this.material[u]));
                r.material = l
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let l = 0; l < this.children.length; l++)
                r.children.push(this.children[l].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let l = 0; l < this.animations.length; l++) {
                const u = this.animations[l];
                r.animations.push(s(e.animations, u))
            }
        }
        if (t) {
            const l = o(e.geometries)
              , u = o(e.materials)
              , f = o(e.textures)
              , d = o(e.images)
              , h = o(e.shapes)
              , m = o(e.skeletons)
              , g = o(e.animations)
              , x = o(e.nodes);
            l.length > 0 && (i.geometries = l),
            u.length > 0 && (i.materials = u),
            f.length > 0 && (i.textures = f),
            d.length > 0 && (i.images = d),
            h.length > 0 && (i.shapes = h),
            m.length > 0 && (i.skeletons = m),
            g.length > 0 && (i.animations = g),
            x.length > 0 && (i.nodes = x)
        }
        return i.object = r,
        i;
        function o(l) {
            const u = [];
            for (const f in l) {
                const d = l[f];
                delete d.metadata,
                u.push(d)
            }
            return u
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
It.DEFAULT_UP = new B(0,1,0);
It.DEFAULT_MATRIX_AUTO_UPDATE = !0;
It.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const rr = new B
  , Zr = new B
  , mg = new B
  , Kr = new B
  , Ca = new B
  , Ta = new B
  , rS = new B
  , gg = new B
  , vg = new B
  , xg = new B;
class Ci {
    constructor(e=new B, t=new B, i=new B) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        rr.subVectors(e, t),
        r.cross(rr);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        rr.subVectors(r, t),
        Zr.subVectors(i, t),
        mg.subVectors(e, t);
        const o = rr.dot(rr)
          , l = rr.dot(Zr)
          , u = rr.dot(mg)
          , f = Zr.dot(Zr)
          , d = Zr.dot(mg)
          , h = o * f - l * l;
        if (h === 0)
            return s.set(0, 0, 0),
            null;
        const m = 1 / h
          , g = (f * u - l * d) * m
          , x = (o * d - l * u) * m;
        return s.set(1 - g - x, x, g)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, Kr) === null ? !1 : Kr.x >= 0 && Kr.y >= 0 && Kr.x + Kr.y <= 1
    }
    static getInterpolation(e, t, i, r, s, o, l, u) {
        return this.getBarycoord(e, t, i, r, Kr) === null ? (u.x = 0,
        u.y = 0,
        "z"in u && (u.z = 0),
        "w"in u && (u.w = 0),
        null) : (u.setScalar(0),
        u.addScaledVector(s, Kr.x),
        u.addScaledVector(o, Kr.y),
        u.addScaledVector(l, Kr.z),
        u)
    }
    static isFrontFacing(e, t, i, r) {
        return rr.subVectors(i, t),
        Zr.subVectors(e, t),
        rr.cross(Zr).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return rr.subVectors(this.c, this.b),
        Zr.subVectors(this.a, this.b),
        rr.cross(Zr).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Ci.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Ci.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, i, r, s) {
        return Ci.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return Ci.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Ci.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, l;
        Ca.subVectors(r, i),
        Ta.subVectors(s, i),
        gg.subVectors(e, i);
        const u = Ca.dot(gg)
          , f = Ta.dot(gg);
        if (u <= 0 && f <= 0)
            return t.copy(i);
        vg.subVectors(e, r);
        const d = Ca.dot(vg)
          , h = Ta.dot(vg);
        if (d >= 0 && h <= d)
            return t.copy(r);
        const m = u * h - d * f;
        if (m <= 0 && u >= 0 && d <= 0)
            return o = u / (u - d),
            t.copy(i).addScaledVector(Ca, o);
        xg.subVectors(e, s);
        const g = Ca.dot(xg)
          , x = Ta.dot(xg);
        if (x >= 0 && g <= x)
            return t.copy(s);
        const S = g * f - u * x;
        if (S <= 0 && f >= 0 && x <= 0)
            return l = f / (f - x),
            t.copy(i).addScaledVector(Ta, l);
        const _ = d * x - g * h;
        if (_ <= 0 && h - d >= 0 && g - x >= 0)
            return rS.subVectors(s, r),
            l = (h - d) / (h - d + (g - x)),
            t.copy(r).addScaledVector(rS, l);
        const v = 1 / (_ + S + m);
        return o = S * v,
        l = m * v,
        t.copy(i).addScaledVector(Ca, o).addScaledVector(Ta, l)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Ib = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Ts = {
    h: 0,
    s: 0,
    l: 0
}
  , dd = {
    h: 0,
    s: 0,
    l: 0
};
function _g(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Oe {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else
            this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Hi) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        kt.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=kt.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        kt.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=kt.workingColorSpace) {
        if (e = fx(e, 1),
        t = an(t, 0, 1),
        i = an(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = _g(o, s, e + 1 / 3),
            this.g = _g(o, s, e),
            this.b = _g(o, s, e - 1 / 3)
        }
        return kt.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=Hi) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , l = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                    return i(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                    return i(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                    return i(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Hi) {
        const i = Ib[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = nl(e.r),
        this.g = nl(e.g),
        this.b = nl(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = og(e.r),
        this.g = og(e.g),
        this.b = og(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Hi) {
        return kt.fromWorkingColorSpace(Wn.copy(this), e),
        Math.round(an(Wn.r * 255, 0, 255)) * 65536 + Math.round(an(Wn.g * 255, 0, 255)) * 256 + Math.round(an(Wn.b * 255, 0, 255))
    }
    getHexString(e=Hi) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=kt.workingColorSpace) {
        kt.fromWorkingColorSpace(Wn.copy(this), t);
        const i = Wn.r
          , r = Wn.g
          , s = Wn.b
          , o = Math.max(i, r, s)
          , l = Math.min(i, r, s);
        let u, f;
        const d = (l + o) / 2;
        if (l === o)
            u = 0,
            f = 0;
        else {
            const h = o - l;
            switch (f = d <= .5 ? h / (o + l) : h / (2 - o - l),
            o) {
            case i:
                u = (r - s) / h + (r < s ? 6 : 0);
                break;
            case r:
                u = (s - i) / h + 2;
                break;
            case s:
                u = (i - r) / h + 4;
                break
            }
            u /= 6
        }
        return e.h = u,
        e.s = f,
        e.l = d,
        e
    }
    getRGB(e, t=kt.workingColorSpace) {
        return kt.fromWorkingColorSpace(Wn.copy(this), t),
        e.r = Wn.r,
        e.g = Wn.g,
        e.b = Wn.b,
        e
    }
    getStyle(e=Hi) {
        kt.fromWorkingColorSpace(Wn.copy(this), e);
        const t = Wn.r
          , i = Wn.g
          , r = Wn.b;
        return e !== Hi ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Ts),
        this.setHSL(Ts.h + e, Ts.s + t, Ts.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Ts),
        e.getHSL(dd);
        const i = Uc(Ts.h, dd.h, t)
          , r = Uc(Ts.s, dd.s, t)
          , s = Uc(Ts.l, dd.l, t);
        return this.setHSL(i, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * r,
        this.g = s[1] * t + s[4] * i + s[7] * r,
        this.b = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Wn = new Oe;
Oe.NAMES = Ib;
let b7 = 0;
class Fn extends fs {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: b7++
        }),
        this.uuid = Ai(),
        this.name = "",
        this.type = "Material",
        this.blending = Oo,
        this.side = Dr,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = Ah,
        this.blendDst = Rh,
        this.blendEquation = Ls,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Oe(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Qc,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = O1,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = wo,
        this.stencilZFail = wo,
        this.stencilZPass = wo,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (i.dispersion = this.dispersion),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Oo && (i.blending = this.blending),
        this.side !== Dr && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        this.blendSrc !== Ah && (i.blendSrc = this.blendSrc),
        this.blendDst !== Rh && (i.blendDst = this.blendDst),
        this.blendEquation !== Ls && (i.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
        this.depthFunc !== Qc && (i.depthFunc = this.depthFunc),
        this.depthTest === !1 && (i.depthTest = this.depthTest),
        this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== O1 && (i.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== wo && (i.stencilFail = this.stencilFail),
        this.stencilZFail !== wo && (i.stencilZFail = this.stencilZFail),
        this.stencilZPass !== wo && (i.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const l in s) {
                const u = s[l];
                delete u.metadata,
                o.push(u)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
    onBeforeRender() {
        console.warn("Material: onBeforeRender() has been removed.")
    }
}
class qs extends Fn {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.combine = Nu,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const ts = E7();
function E7() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let u = 0; u < 256; ++u) {
        const f = u - 127;
        f < -27 ? (i[u] = 0,
        i[u | 256] = 32768,
        r[u] = 24,
        r[u | 256] = 24) : f < -14 ? (i[u] = 1024 >> -f - 14,
        i[u | 256] = 1024 >> -f - 14 | 32768,
        r[u] = -f - 1,
        r[u | 256] = -f - 1) : f <= 15 ? (i[u] = f + 15 << 10,
        i[u | 256] = f + 15 << 10 | 32768,
        r[u] = 13,
        r[u | 256] = 13) : f < 128 ? (i[u] = 31744,
        i[u | 256] = 64512,
        r[u] = 24,
        r[u | 256] = 24) : (i[u] = 31744,
        i[u | 256] = 64512,
        r[u] = 13,
        r[u | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , l = new Uint32Array(64);
    for (let u = 1; u < 1024; ++u) {
        let f = u << 13
          , d = 0;
        for (; !(f & 8388608); )
            f <<= 1,
            d -= 8388608;
        f &= -8388609,
        d += 947912704,
        s[u] = f | d
    }
    for (let u = 1024; u < 2048; ++u)
        s[u] = 939524096 + (u - 1024 << 13);
    for (let u = 1; u < 31; ++u)
        o[u] = u << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let u = 33; u < 63; ++u)
        o[u] = 2147483648 + (u - 32 << 23);
    o[63] = 3347054592;
    for (let u = 1; u < 64; ++u)
        u !== 32 && (l[u] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: l
    }
}
function fi(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = an(n, -65504, 65504),
    ts.floatView[0] = n;
    const e = ts.uint32View[0]
      , t = e >> 23 & 511;
    return ts.baseTable[t] + ((e & 8388607) >> ts.shiftTable[t])
}
function yc(n) {
    const e = n >> 10;
    return ts.uint32View[0] = ts.mantissaTable[ts.offsetTable[e] + (n & 1023)] + ts.exponentTable[e],
    ts.floatView[0]
}
const C7 = {
    toHalfFloat: fi,
    fromHalfFloat: yc
}
  , vn = new B
  , hd = new he;
class Vt {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = cu,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = ii,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return dx("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                hd.fromBufferAttribute(this, t),
                hd.applyMatrix3(e),
                this.setXY(t, hd.x, hd.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                vn.fromBufferAttribute(this, t),
                vn.applyMatrix3(e),
                this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vn.fromBufferAttribute(this, t),
            vn.applyMatrix4(e),
            this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vn.fromBufferAttribute(this, t),
            vn.applyNormalMatrix(e),
            this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vn.fromBufferAttribute(this, t),
            vn.transformDirection(e),
            this.setXYZ(t, vn.x, vn.y, vn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = ti(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = _t(i, this.array)),
        this.array[e * this.itemSize + t] = i,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array),
        r = _t(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array),
        r = _t(r, this.array),
        s = _t(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== cu && (e.usage = this.usage),
        e
    }
}
class T7 extends Vt {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i)
    }
}
class A7 extends Vt {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i)
    }
}
class R7 extends Vt {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i)
    }
}
class P7 extends Vt {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i)
    }
}
class px extends Vt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class I7 extends Vt {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i)
    }
}
class mx extends Vt {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class L7 extends Vt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i),
        this.isFloat16BufferAttribute = !0
    }
    getX(e) {
        let t = yc(this.array[e * this.itemSize]);
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize] = fi(t),
        this
    }
    getY(e) {
        let t = yc(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize + 1] = fi(t),
        this
    }
    getZ(e) {
        let t = yc(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize + 2] = fi(t),
        this
    }
    getW(e) {
        let t = yc(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.array[e * this.itemSize + 3] = fi(t),
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array)),
        this.array[e + 0] = fi(t),
        this.array[e + 1] = fi(i),
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array),
        r = _t(r, this.array)),
        this.array[e + 0] = fi(t),
        this.array[e + 1] = fi(i),
        this.array[e + 2] = fi(r),
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array),
        r = _t(r, this.array),
        s = _t(s, this.array)),
        this.array[e + 0] = fi(t),
        this.array[e + 1] = fi(i),
        this.array[e + 2] = fi(r),
        this.array[e + 3] = fi(s),
        this
    }
}
class Je extends Vt {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let N7 = 0;
const Vi = new ct
  , yg = new It
  , Aa = new B
  , Ei = new si
  , ac = new si
  , In = new B;
class St extends fs {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: N7++
        }),
        this.uuid = Ai(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (Tb(e) ? mx : px)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new xt().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return Vi.makeRotationFromQuaternion(e),
        this.applyMatrix4(Vi),
        this
    }
    rotateX(e) {
        return Vi.makeRotationX(e),
        this.applyMatrix4(Vi),
        this
    }
    rotateY(e) {
        return Vi.makeRotationY(e),
        this.applyMatrix4(Vi),
        this
    }
    rotateZ(e) {
        return Vi.makeRotationZ(e),
        this.applyMatrix4(Vi),
        this
    }
    translate(e, t, i) {
        return Vi.makeTranslation(e, t, i),
        this.applyMatrix4(Vi),
        this
    }
    scale(e, t, i) {
        return Vi.makeScale(e, t, i),
        this.applyMatrix4(Vi),
        this
    }
    lookAt(e) {
        return yg.lookAt(e),
        yg.updateMatrix(),
        this.applyMatrix4(yg.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Aa).negate(),
        this.translate(Aa.x, Aa.y, Aa.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new Je(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new si);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new B(-1 / 0,-1 / 0,-1 / 0), new B(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Ei.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (In.addVectors(this.boundingBox.min, Ei.min),
                    this.boundingBox.expandByPoint(In),
                    In.addVectors(this.boundingBox.max, Ei.max),
                    this.boundingBox.expandByPoint(In)) : (this.boundingBox.expandByPoint(Ei.min),
                    this.boundingBox.expandByPoint(Ei.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Yn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new B, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Ei.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const l = t[s];
                    ac.setFromBufferAttribute(l),
                    this.morphTargetsRelative ? (In.addVectors(Ei.min, ac.min),
                    Ei.expandByPoint(In),
                    In.addVectors(Ei.max, ac.max),
                    Ei.expandByPoint(In)) : (Ei.expandByPoint(ac.min),
                    Ei.expandByPoint(ac.max))
                }
            Ei.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                In.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(In));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const l = t[s]
                      , u = this.morphTargetsRelative;
                    for (let f = 0, d = l.count; f < d; f++)
                        In.fromBufferAttribute(l, f),
                        u && (Aa.fromBufferAttribute(e, f),
                        In.add(Aa)),
                        r = Math.max(r, i.distanceToSquared(In))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = t.position
          , r = t.normal
          , s = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Vt(new Float32Array(4 * i.count),4));
        const o = this.getAttribute("tangent")
          , l = []
          , u = [];
        for (let F = 0; F < i.count; F++)
            l[F] = new B,
            u[F] = new B;
        const f = new B
          , d = new B
          , h = new B
          , m = new he
          , g = new he
          , x = new he
          , S = new B
          , _ = new B;
        function v(F, I, P) {
            f.fromBufferAttribute(i, F),
            d.fromBufferAttribute(i, I),
            h.fromBufferAttribute(i, P),
            m.fromBufferAttribute(s, F),
            g.fromBufferAttribute(s, I),
            x.fromBufferAttribute(s, P),
            d.sub(f),
            h.sub(f),
            g.sub(m),
            x.sub(m);
            const D = 1 / (g.x * x.y - x.x * g.y);
            isFinite(D) && (S.copy(d).multiplyScalar(x.y).addScaledVector(h, -g.y).multiplyScalar(D),
            _.copy(h).multiplyScalar(g.x).addScaledVector(d, -x.x).multiplyScalar(D),
            l[F].add(S),
            l[I].add(S),
            l[P].add(S),
            u[F].add(_),
            u[I].add(_),
            u[P].add(_))
        }
        let M = this.groups;
        M.length === 0 && (M = [{
            start: 0,
            count: e.count
        }]);
        for (let F = 0, I = M.length; F < I; ++F) {
            const P = M[F]
              , D = P.start
              , W = P.count;
            for (let X = D, G = D + W; X < G; X += 3)
                v(e.getX(X + 0), e.getX(X + 1), e.getX(X + 2))
        }
        const w = new B
          , E = new B
          , O = new B
          , R = new B;
        function A(F) {
            O.fromBufferAttribute(r, F),
            R.copy(O);
            const I = l[F];
            w.copy(I),
            w.sub(O.multiplyScalar(O.dot(I))).normalize(),
            E.crossVectors(R, I);
            const D = E.dot(u[F]) < 0 ? -1 : 1;
            o.setXYZW(F, w.x, w.y, w.z, D)
        }
        for (let F = 0, I = M.length; F < I; ++F) {
            const P = M[F]
              , D = P.start
              , W = P.count;
            for (let X = D, G = D + W; X < G; X += 3)
                A(e.getX(X + 0)),
                A(e.getX(X + 1)),
                A(e.getX(X + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new Vt(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let m = 0, g = i.count; m < g; m++)
                    i.setXYZ(m, 0, 0, 0);
            const r = new B
              , s = new B
              , o = new B
              , l = new B
              , u = new B
              , f = new B
              , d = new B
              , h = new B;
            if (e)
                for (let m = 0, g = e.count; m < g; m += 3) {
                    const x = e.getX(m + 0)
                      , S = e.getX(m + 1)
                      , _ = e.getX(m + 2);
                    r.fromBufferAttribute(t, x),
                    s.fromBufferAttribute(t, S),
                    o.fromBufferAttribute(t, _),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    l.fromBufferAttribute(i, x),
                    u.fromBufferAttribute(i, S),
                    f.fromBufferAttribute(i, _),
                    l.add(d),
                    u.add(d),
                    f.add(d),
                    i.setXYZ(x, l.x, l.y, l.z),
                    i.setXYZ(S, u.x, u.y, u.z),
                    i.setXYZ(_, f.x, f.y, f.z)
                }
            else
                for (let m = 0, g = t.count; m < g; m += 3)
                    r.fromBufferAttribute(t, m + 0),
                    s.fromBufferAttribute(t, m + 1),
                    o.fromBufferAttribute(t, m + 2),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    i.setXYZ(m + 0, d.x, d.y, d.z),
                    i.setXYZ(m + 1, d.x, d.y, d.z),
                    i.setXYZ(m + 2, d.x, d.y, d.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            In.fromBufferAttribute(e, t),
            In.normalize(),
            e.setXYZ(t, In.x, In.y, In.z)
    }
    toNonIndexed() {
        function e(l, u) {
            const f = l.array
              , d = l.itemSize
              , h = l.normalized
              , m = new f.constructor(u.length * d);
            let g = 0
              , x = 0;
            for (let S = 0, _ = u.length; S < _; S++) {
                l.isInterleavedBufferAttribute ? g = u[S] * l.data.stride + l.offset : g = u[S] * d;
                for (let v = 0; v < d; v++)
                    m[x++] = f[g++]
            }
            return new Vt(m,d,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new St
          , i = this.index.array
          , r = this.attributes;
        for (const l in r) {
            const u = r[l]
              , f = e(u, i);
            t.setAttribute(l, f)
        }
        const s = this.morphAttributes;
        for (const l in s) {
            const u = []
              , f = s[l];
            for (let d = 0, h = f.length; d < h; d++) {
                const m = f[d]
                  , g = e(m, i);
                u.push(g)
            }
            t.morphAttributes[l] = u
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let l = 0, u = o.length; l < u; l++) {
            const f = o[l];
            t.addGroup(f.start, f.count, f.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const u = this.parameters;
            for (const f in u)
                u[f] !== void 0 && (e[f] = u[f]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const u in i) {
            const f = i[u];
            e.data.attributes[u] = f.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const u in this.morphAttributes) {
            const f = this.morphAttributes[u]
              , d = [];
            for (let h = 0, m = f.length; h < m; h++) {
                const g = f[h];
                d.push(g.toJSON(e.data))
            }
            d.length > 0 && (r[u] = d,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const l = this.boundingSphere;
        return l !== null && (e.data.boundingSphere = {
            center: l.center.toArray(),
            radius: l.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const f in r) {
            const d = r[f];
            this.setAttribute(f, d.clone(t))
        }
        const s = e.morphAttributes;
        for (const f in s) {
            const d = []
              , h = s[f];
            for (let m = 0, g = h.length; m < g; m++)
                d.push(h[m].clone(t));
            this.morphAttributes[f] = d
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let f = 0, d = o.length; f < d; f++) {
            const h = o[f];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const l = e.boundingBox;
        l !== null && (this.boundingBox = l.clone());
        const u = e.boundingSphere;
        return u !== null && (this.boundingSphere = u.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const sS = new ct
  , ho = new El
  , pd = new Yn
  , oS = new B
  , Ra = new B
  , Pa = new B
  , Ia = new B
  , Sg = new B
  , md = new B
  , gd = new he
  , vd = new he
  , xd = new he
  , aS = new B
  , lS = new B
  , cS = new B
  , _d = new B
  , yd = new B;
class Sn extends It {
    constructor(e=new St, t=new qs) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const l = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[l] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const l = this.morphTargetInfluences;
        if (s && l) {
            md.set(0, 0, 0);
            for (let u = 0, f = s.length; u < f; u++) {
                const d = l[u]
                  , h = s[u];
                d !== 0 && (Sg.fromBufferAttribute(h, e),
                o ? md.addScaledVector(Sg, d) : md.addScaledVector(Sg.sub(t), d))
            }
            t.add(md)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        pd.copy(i.boundingSphere),
        pd.applyMatrix4(s),
        ho.copy(e.ray).recast(e.near),
        !(pd.containsPoint(ho.origin) === !1 && (ho.intersectSphere(pd, oS) === null || ho.origin.distanceToSquared(oS) > (e.far - e.near) ** 2)) && (sS.copy(s).invert(),
        ho.copy(e.ray).applyMatrix4(sS),
        !(i.boundingBox !== null && ho.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, ho)))
    }
    _computeIntersections(e, t, i) {
        let r;
        const s = this.geometry
          , o = this.material
          , l = s.index
          , u = s.attributes.position
          , f = s.attributes.uv
          , d = s.attributes.uv1
          , h = s.attributes.normal
          , m = s.groups
          , g = s.drawRange;
        if (l !== null)
            if (Array.isArray(o))
                for (let x = 0, S = m.length; x < S; x++) {
                    const _ = m[x]
                      , v = o[_.materialIndex]
                      , M = Math.max(_.start, g.start)
                      , w = Math.min(l.count, Math.min(_.start + _.count, g.start + g.count));
                    for (let E = M, O = w; E < O; E += 3) {
                        const R = l.getX(E)
                          , A = l.getX(E + 1)
                          , F = l.getX(E + 2);
                        r = Sd(this, v, e, i, f, d, h, R, A, F),
                        r && (r.faceIndex = Math.floor(E / 3),
                        r.face.materialIndex = _.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const x = Math.max(0, g.start)
                  , S = Math.min(l.count, g.start + g.count);
                for (let _ = x, v = S; _ < v; _ += 3) {
                    const M = l.getX(_)
                      , w = l.getX(_ + 1)
                      , E = l.getX(_ + 2);
                    r = Sd(this, o, e, i, f, d, h, M, w, E),
                    r && (r.faceIndex = Math.floor(_ / 3),
                    t.push(r))
                }
            }
        else if (u !== void 0)
            if (Array.isArray(o))
                for (let x = 0, S = m.length; x < S; x++) {
                    const _ = m[x]
                      , v = o[_.materialIndex]
                      , M = Math.max(_.start, g.start)
                      , w = Math.min(u.count, Math.min(_.start + _.count, g.start + g.count));
                    for (let E = M, O = w; E < O; E += 3) {
                        const R = E
                          , A = E + 1
                          , F = E + 2;
                        r = Sd(this, v, e, i, f, d, h, R, A, F),
                        r && (r.faceIndex = Math.floor(E / 3),
                        r.face.materialIndex = _.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const x = Math.max(0, g.start)
                  , S = Math.min(u.count, g.start + g.count);
                for (let _ = x, v = S; _ < v; _ += 3) {
                    const M = _
                      , w = _ + 1
                      , E = _ + 2;
                    r = Sd(this, o, e, i, f, d, h, M, w, E),
                    r && (r.faceIndex = Math.floor(_ / 3),
                    t.push(r))
                }
            }
    }
}
function O7(n, e, t, i, r, s, o, l) {
    let u;
    if (e.side === ri ? u = i.intersectTriangle(o, s, r, !0, l) : u = i.intersectTriangle(r, s, o, e.side === Dr, l),
    u === null)
        return null;
    yd.copy(l),
    yd.applyMatrix4(n.matrixWorld);
    const f = t.ray.origin.distanceTo(yd);
    return f < t.near || f > t.far ? null : {
        distance: f,
        point: yd.clone(),
        object: n
    }
}
function Sd(n, e, t, i, r, s, o, l, u, f) {
    n.getVertexPosition(l, Ra),
    n.getVertexPosition(u, Pa),
    n.getVertexPosition(f, Ia);
    const d = O7(n, e, t, i, Ra, Pa, Ia, _d);
    if (d) {
        r && (gd.fromBufferAttribute(r, l),
        vd.fromBufferAttribute(r, u),
        xd.fromBufferAttribute(r, f),
        d.uv = Ci.getInterpolation(_d, Ra, Pa, Ia, gd, vd, xd, new he)),
        s && (gd.fromBufferAttribute(s, l),
        vd.fromBufferAttribute(s, u),
        xd.fromBufferAttribute(s, f),
        d.uv1 = Ci.getInterpolation(_d, Ra, Pa, Ia, gd, vd, xd, new he)),
        o && (aS.fromBufferAttribute(o, l),
        lS.fromBufferAttribute(o, u),
        cS.fromBufferAttribute(o, f),
        d.normal = Ci.getInterpolation(_d, Ra, Pa, Ia, aS, lS, cS, new B),
        d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
        const h = {
            a: l,
            b: u,
            c: f,
            normal: new B,
            materialIndex: 0
        };
        Ci.getNormal(Ra, Pa, Ia, h.normal),
        d.face = h
    }
    return d
}
class $o extends St {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const l = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const u = []
          , f = []
          , d = []
          , h = [];
        let m = 0
          , g = 0;
        x("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        x("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        x("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        x("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        x("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        x("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(u),
        this.setAttribute("position", new Je(f,3)),
        this.setAttribute("normal", new Je(d,3)),
        this.setAttribute("uv", new Je(h,2));
        function x(S, _, v, M, w, E, O, R, A, F, I) {
            const P = E / A
              , D = O / F
              , W = E / 2
              , X = O / 2
              , G = R / 2
              , q = A + 1
              , K = F + 1;
            let oe = 0
              , z = 0;
            const ee = new B;
            for (let Q = 0; Q < K; Q++) {
                const ce = Q * D - X;
                for (let be = 0; be < q; be++) {
                    const Ue = be * P - W;
                    ee[S] = Ue * M,
                    ee[_] = ce * w,
                    ee[v] = G,
                    f.push(ee.x, ee.y, ee.z),
                    ee[S] = 0,
                    ee[_] = 0,
                    ee[v] = R > 0 ? 1 : -1,
                    d.push(ee.x, ee.y, ee.z),
                    h.push(be / A),
                    h.push(1 - Q / F),
                    oe += 1
                }
            }
            for (let Q = 0; Q < F; Q++)
                for (let ce = 0; ce < A; ce++) {
                    const be = m + ce + q * Q
                      , Ue = m + ce + q * (Q + 1)
                      , se = m + (ce + 1) + q * (Q + 1)
                      , ue = m + (ce + 1) + q * Q;
                    u.push(be, Ue, ue),
                    u.push(Ue, se, ue),
                    z += 6
                }
            l.addGroup(g, z, I),
            g += z,
            m += oe
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new $o(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function pl(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function Qn(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = pl(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function D7(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function Lb(n) {
    const e = n.getRenderTarget();
    return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : kt.workingColorSpace
}
const gx = {
    clone: pl,
    merge: Qn
};
var U7 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , F7 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Yi extends Fn {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = U7,
        this.fragmentShader = F7,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = pl(e.uniforms),
        this.uniformsGroups = D7(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class Uu extends It {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new ct,
        this.projectionMatrix = new ct,
        this.projectionMatrixInverse = new ct,
        this.coordinateSystem = Tr
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const As = new B
  , uS = new he
  , fS = new he;
let yn = class extends Uu {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = hl * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Uo * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return hl * 2 * Math.atan(Math.tan(Uo * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, i) {
        As.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(As.x, As.y).multiplyScalar(-e / As.z),
        As.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        i.set(As.x, As.y).multiplyScalar(-e / As.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, uS, fS),
        t.subVectors(fS, uS)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Uo * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const u = o.fullWidth
              , f = o.fullHeight;
            s += o.offsetX * r / u,
            t -= o.offsetY * i / f,
            r *= o.width / u,
            i *= o.height / f
        }
        const l = this.filmOffset;
        l !== 0 && (s += e * l / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
;
const La = -90
  , Na = 1;
class vx extends It {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new yn(La,Na,e,t);
        r.layers = this.layers,
        this.add(r);
        const s = new yn(La,Na,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new yn(La,Na,e,t);
        o.layers = this.layers,
        this.add(o);
        const l = new yn(La,Na,e,t);
        l.layers = this.layers,
        this.add(l);
        const u = new yn(La,Na,e,t);
        u.layers = this.layers,
        this.add(u);
        const f = new yn(La,Na,e,t);
        f.layers = this.layers,
        this.add(f)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [i,r,s,o,l,u] = t;
        for (const f of t)
            this.remove(f);
        if (e === Tr)
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, 1),
            u.up.set(0, 1, 0),
            u.lookAt(0, 0, -1);
        else if (e === uu)
            i.up.set(0, -1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, 1),
            u.up.set(0, -1, 0),
            u.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const f of t)
            this.add(f),
            f.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: i, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,l,u,f,d] = this.children
          , h = e.getRenderTarget()
          , m = e.getActiveCubeFace()
          , g = e.getActiveMipmapLevel()
          , x = e.xr.enabled;
        e.xr.enabled = !1;
        const S = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0, r),
        e.render(t, s),
        e.setRenderTarget(i, 1, r),
        e.render(t, o),
        e.setRenderTarget(i, 2, r),
        e.render(t, l),
        e.setRenderTarget(i, 3, r),
        e.render(t, u),
        e.setRenderTarget(i, 4, r),
        e.render(t, f),
        i.texture.generateMipmaps = S,
        e.setRenderTarget(i, 5, r),
        e.render(t, d),
        e.setRenderTarget(h, m, g),
        e.xr.enabled = x,
        i.texture.needsPMREMUpdate = !0
    }
}
class Fu extends en {
    constructor(e, t, i, r, s, o, l, u, f, d) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : os,
        super(e, t, i, r, s, o, l, u, f, d),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class xx extends qi {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        this.texture = new Fu(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : ln
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new $o(5,5,5)
          , s = new Yi({
            name: "CubemapFromEquirect",
            uniforms: pl(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: ri,
            blending: is
        });
        s.uniforms.tEquirect.value = t;
        const o = new Sn(r,s)
          , l = t.minFilter;
        return t.minFilter === Cr && (t.minFilter = ln),
        new vx(1,10,this).update(e, o),
        t.minFilter = l,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const Mg = new B
  , k7 = new B
  , B7 = new xt;
class Is {
    constructor(e=new B(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = Mg.subVectors(i, t).cross(k7.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(Mg)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || B7.getNormalMatrix(e)
          , r = this.coplanarPoint(Mg).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const po = new Yn
  , Md = new B;
class ku {
    constructor(e=new Is, t=new Is, i=new Is, r=new Is, s=new Is, o=new Is) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const l = this.planes;
        return l[0].copy(e),
        l[1].copy(t),
        l[2].copy(i),
        l[3].copy(r),
        l[4].copy(s),
        l[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t=Tr) {
        const i = this.planes
          , r = e.elements
          , s = r[0]
          , o = r[1]
          , l = r[2]
          , u = r[3]
          , f = r[4]
          , d = r[5]
          , h = r[6]
          , m = r[7]
          , g = r[8]
          , x = r[9]
          , S = r[10]
          , _ = r[11]
          , v = r[12]
          , M = r[13]
          , w = r[14]
          , E = r[15];
        if (i[0].setComponents(u - s, m - f, _ - g, E - v).normalize(),
        i[1].setComponents(u + s, m + f, _ + g, E + v).normalize(),
        i[2].setComponents(u + o, m + d, _ + x, E + M).normalize(),
        i[3].setComponents(u - o, m - d, _ - x, E - M).normalize(),
        i[4].setComponents(u - l, m - h, _ - S, E - w).normalize(),
        t === Tr)
            i[5].setComponents(u + l, m + h, _ + S, E + w).normalize();
        else if (t === uu)
            i[5].setComponents(l, h, S, w).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            po.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            po.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(po)
    }
    intersectsSprite(e) {
        return po.center.set(0, 0, 0),
        po.radius = .7071067811865476,
        po.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(po)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (Md.x = r.normal.x > 0 ? e.max.x : e.min.x,
            Md.y = r.normal.y > 0 ? e.max.y : e.min.y,
            Md.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(Md) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function Nb() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function z7(n) {
    const e = new WeakMap;
    function t(l, u) {
        const f = l.array
          , d = l.usage
          , h = f.byteLength
          , m = n.createBuffer();
        n.bindBuffer(u, m),
        n.bufferData(u, f, d),
        l.onUploadCallback();
        let g;
        if (f instanceof Float32Array)
            g = n.FLOAT;
        else if (f instanceof Uint16Array)
            l.isFloat16BufferAttribute ? g = n.HALF_FLOAT : g = n.UNSIGNED_SHORT;
        else if (f instanceof Int16Array)
            g = n.SHORT;
        else if (f instanceof Uint32Array)
            g = n.UNSIGNED_INT;
        else if (f instanceof Int32Array)
            g = n.INT;
        else if (f instanceof Int8Array)
            g = n.BYTE;
        else if (f instanceof Uint8Array)
            g = n.UNSIGNED_BYTE;
        else if (f instanceof Uint8ClampedArray)
            g = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
        return {
            buffer: m,
            type: g,
            bytesPerElement: f.BYTES_PER_ELEMENT,
            version: l.version,
            size: h
        }
    }
    function i(l, u, f) {
        const d = u.array
          , h = u._updateRange
          , m = u.updateRanges;
        if (n.bindBuffer(f, l),
        h.count === -1 && m.length === 0 && n.bufferSubData(f, 0, d),
        m.length !== 0) {
            for (let g = 0, x = m.length; g < x; g++) {
                const S = m[g];
                n.bufferSubData(f, S.start * d.BYTES_PER_ELEMENT, d, S.start, S.count)
            }
            u.clearUpdateRanges()
        }
        h.count !== -1 && (n.bufferSubData(f, h.offset * d.BYTES_PER_ELEMENT, d, h.offset, h.count),
        h.count = -1),
        u.onUploadCallback()
    }
    function r(l) {
        return l.isInterleavedBufferAttribute && (l = l.data),
        e.get(l)
    }
    function s(l) {
        l.isInterleavedBufferAttribute && (l = l.data);
        const u = e.get(l);
        u && (n.deleteBuffer(u.buffer),
        e.delete(l))
    }
    function o(l, u) {
        if (l.isGLBufferAttribute) {
            const d = e.get(l);
            (!d || d.version < l.version) && e.set(l, {
                buffer: l.buffer,
                type: l.type,
                bytesPerElement: l.elementSize,
                version: l.version
            });
            return
        }
        l.isInterleavedBufferAttribute && (l = l.data);
        const f = e.get(l);
        if (f === void 0)
            e.set(l, t(l, u));
        else if (f.version < l.version) {
            if (f.size !== l.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(f.buffer, l, u),
            f.version = l.version
        }
    }
    return {
        get: r,
        remove: s,
        update: o
    }
}
class Cl extends St {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , l = Math.floor(i)
          , u = Math.floor(r)
          , f = l + 1
          , d = u + 1
          , h = e / l
          , m = t / u
          , g = []
          , x = []
          , S = []
          , _ = [];
        for (let v = 0; v < d; v++) {
            const M = v * m - o;
            for (let w = 0; w < f; w++) {
                const E = w * h - s;
                x.push(E, -M, 0),
                S.push(0, 0, 1),
                _.push(w / l),
                _.push(1 - v / u)
            }
        }
        for (let v = 0; v < u; v++)
            for (let M = 0; M < l; M++) {
                const w = M + f * v
                  , E = M + f * (v + 1)
                  , O = M + 1 + f * (v + 1)
                  , R = M + 1 + f * v;
                g.push(w, E, R),
                g.push(E, O, R)
            }
        this.setIndex(g),
        this.setAttribute("position", new Je(x,3)),
        this.setAttribute("normal", new Je(S,3)),
        this.setAttribute("uv", new Je(_,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Cl(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var V7 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , H7 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , G7 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , W7 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , j7 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , X7 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , $7 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , q7 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , Y7 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , Z7 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , K7 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , J7 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , Q7 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , eL = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , tL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , nL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , iL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , rL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , sL = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , oL = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , aL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , lL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , cL = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , uL = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , fL = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , dL = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , hL = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , pL = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , mL = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , gL = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , vL = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , xL = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`
  , _L = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , yL = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , SL = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , ML = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , wL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , bL = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , EL = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , CL = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , TL = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , AL = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , RL = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , PL = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , IL = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , LL = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , NL = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , OL = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , DL = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , UL = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , FL = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , kL = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , BL = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , zL = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , VL = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , HL = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , GL = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , WL = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , jL = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , XL = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , $L = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , qL = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , YL = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , ZL = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , KL = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , JL = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , QL = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , eN = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , tN = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , nN = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , iN = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , rN = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , sN = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , oN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , aN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , lN = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , cN = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , uN = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , fN = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , dN = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , hN = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , pN = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , mN = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , gN = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , vN = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , xN = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , _N = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , yN = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , SN = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , MN = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , wN = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , bN = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , EN = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , CN = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , TN = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , AN = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , RN = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , PN = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , IN = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , LN = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , NN = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , ON = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , DN = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , UN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , FN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , kN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , BN = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const zN = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , VN = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , HN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , GN = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , WN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , jN = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , XN = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , $N = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , qN = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , YN = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , ZN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , KN = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , JN = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , QN = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , e9 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , t9 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , n9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , i9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , r9 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , s9 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , o9 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , a9 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , l9 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , c9 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , u9 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , f9 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , d9 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , h9 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , p9 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , m9 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , g9 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , v9 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , x9 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , _9 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , yt = {
    alphahash_fragment: V7,
    alphahash_pars_fragment: H7,
    alphamap_fragment: G7,
    alphamap_pars_fragment: W7,
    alphatest_fragment: j7,
    alphatest_pars_fragment: X7,
    aomap_fragment: $7,
    aomap_pars_fragment: q7,
    batching_pars_vertex: Y7,
    batching_vertex: Z7,
    begin_vertex: K7,
    beginnormal_vertex: J7,
    bsdfs: Q7,
    iridescence_fragment: eL,
    bumpmap_pars_fragment: tL,
    clipping_planes_fragment: nL,
    clipping_planes_pars_fragment: iL,
    clipping_planes_pars_vertex: rL,
    clipping_planes_vertex: sL,
    color_fragment: oL,
    color_pars_fragment: aL,
    color_pars_vertex: lL,
    color_vertex: cL,
    common: uL,
    cube_uv_reflection_fragment: fL,
    defaultnormal_vertex: dL,
    displacementmap_pars_vertex: hL,
    displacementmap_vertex: pL,
    emissivemap_fragment: mL,
    emissivemap_pars_fragment: gL,
    colorspace_fragment: vL,
    colorspace_pars_fragment: xL,
    envmap_fragment: _L,
    envmap_common_pars_fragment: yL,
    envmap_pars_fragment: SL,
    envmap_pars_vertex: ML,
    envmap_physical_pars_fragment: NL,
    envmap_vertex: wL,
    fog_vertex: bL,
    fog_pars_vertex: EL,
    fog_fragment: CL,
    fog_pars_fragment: TL,
    gradientmap_pars_fragment: AL,
    lightmap_pars_fragment: RL,
    lights_lambert_fragment: PL,
    lights_lambert_pars_fragment: IL,
    lights_pars_begin: LL,
    lights_toon_fragment: OL,
    lights_toon_pars_fragment: DL,
    lights_phong_fragment: UL,
    lights_phong_pars_fragment: FL,
    lights_physical_fragment: kL,
    lights_physical_pars_fragment: BL,
    lights_fragment_begin: zL,
    lights_fragment_maps: VL,
    lights_fragment_end: HL,
    logdepthbuf_fragment: GL,
    logdepthbuf_pars_fragment: WL,
    logdepthbuf_pars_vertex: jL,
    logdepthbuf_vertex: XL,
    map_fragment: $L,
    map_pars_fragment: qL,
    map_particle_fragment: YL,
    map_particle_pars_fragment: ZL,
    metalnessmap_fragment: KL,
    metalnessmap_pars_fragment: JL,
    morphinstance_vertex: QL,
    morphcolor_vertex: eN,
    morphnormal_vertex: tN,
    morphtarget_pars_vertex: nN,
    morphtarget_vertex: iN,
    normal_fragment_begin: rN,
    normal_fragment_maps: sN,
    normal_pars_fragment: oN,
    normal_pars_vertex: aN,
    normal_vertex: lN,
    normalmap_pars_fragment: cN,
    clearcoat_normal_fragment_begin: uN,
    clearcoat_normal_fragment_maps: fN,
    clearcoat_pars_fragment: dN,
    iridescence_pars_fragment: hN,
    opaque_fragment: pN,
    packing: mN,
    premultiplied_alpha_fragment: gN,
    project_vertex: vN,
    dithering_fragment: xN,
    dithering_pars_fragment: _N,
    roughnessmap_fragment: yN,
    roughnessmap_pars_fragment: SN,
    shadowmap_pars_fragment: MN,
    shadowmap_pars_vertex: wN,
    shadowmap_vertex: bN,
    shadowmask_pars_fragment: EN,
    skinbase_vertex: CN,
    skinning_pars_vertex: TN,
    skinning_vertex: AN,
    skinnormal_vertex: RN,
    specularmap_fragment: PN,
    specularmap_pars_fragment: IN,
    tonemapping_fragment: LN,
    tonemapping_pars_fragment: NN,
    transmission_fragment: ON,
    transmission_pars_fragment: DN,
    uv_pars_fragment: UN,
    uv_pars_vertex: FN,
    uv_vertex: kN,
    worldpos_vertex: BN,
    background_vert: zN,
    background_frag: VN,
    backgroundCube_vert: HN,
    backgroundCube_frag: GN,
    cube_vert: WN,
    cube_frag: jN,
    depth_vert: XN,
    depth_frag: $N,
    distanceRGBA_vert: qN,
    distanceRGBA_frag: YN,
    equirect_vert: ZN,
    equirect_frag: KN,
    linedashed_vert: JN,
    linedashed_frag: QN,
    meshbasic_vert: e9,
    meshbasic_frag: t9,
    meshlambert_vert: n9,
    meshlambert_frag: i9,
    meshmatcap_vert: r9,
    meshmatcap_frag: s9,
    meshnormal_vert: o9,
    meshnormal_frag: a9,
    meshphong_vert: l9,
    meshphong_frag: c9,
    meshphysical_vert: u9,
    meshphysical_frag: f9,
    meshtoon_vert: d9,
    meshtoon_frag: h9,
    points_vert: p9,
    points_frag: m9,
    shadow_vert: g9,
    shadow_frag: v9,
    sprite_vert: x9,
    sprite_frag: _9
}
  , De = {
    common: {
        diffuse: {
            value: new Oe(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new xt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new xt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new xt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new xt
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new xt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new xt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new xt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new xt
        },
        normalScale: {
            value: new he(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new xt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new xt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new xt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new xt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Oe(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Oe(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new xt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new xt
        }
    },
    sprite: {
        diffuse: {
            value: new Oe(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new he(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new xt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new xt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , ar = {
    basic: {
        uniforms: Qn([De.common, De.specularmap, De.envmap, De.aomap, De.lightmap, De.fog]),
        vertexShader: yt.meshbasic_vert,
        fragmentShader: yt.meshbasic_frag
    },
    lambert: {
        uniforms: Qn([De.common, De.specularmap, De.envmap, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.fog, De.lights, {
            emissive: {
                value: new Oe(0)
            }
        }]),
        vertexShader: yt.meshlambert_vert,
        fragmentShader: yt.meshlambert_frag
    },
    phong: {
        uniforms: Qn([De.common, De.specularmap, De.envmap, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.fog, De.lights, {
            emissive: {
                value: new Oe(0)
            },
            specular: {
                value: new Oe(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: yt.meshphong_vert,
        fragmentShader: yt.meshphong_frag
    },
    standard: {
        uniforms: Qn([De.common, De.envmap, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.roughnessmap, De.metalnessmap, De.fog, De.lights, {
            emissive: {
                value: new Oe(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: yt.meshphysical_vert,
        fragmentShader: yt.meshphysical_frag
    },
    toon: {
        uniforms: Qn([De.common, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.gradientmap, De.fog, De.lights, {
            emissive: {
                value: new Oe(0)
            }
        }]),
        vertexShader: yt.meshtoon_vert,
        fragmentShader: yt.meshtoon_frag
    },
    matcap: {
        uniforms: Qn([De.common, De.bumpmap, De.normalmap, De.displacementmap, De.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: yt.meshmatcap_vert,
        fragmentShader: yt.meshmatcap_frag
    },
    points: {
        uniforms: Qn([De.points, De.fog]),
        vertexShader: yt.points_vert,
        fragmentShader: yt.points_frag
    },
    dashed: {
        uniforms: Qn([De.common, De.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: yt.linedashed_vert,
        fragmentShader: yt.linedashed_frag
    },
    depth: {
        uniforms: Qn([De.common, De.displacementmap]),
        vertexShader: yt.depth_vert,
        fragmentShader: yt.depth_frag
    },
    normal: {
        uniforms: Qn([De.common, De.bumpmap, De.normalmap, De.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: yt.meshnormal_vert,
        fragmentShader: yt.meshnormal_frag
    },
    sprite: {
        uniforms: Qn([De.sprite, De.fog]),
        vertexShader: yt.sprite_vert,
        fragmentShader: yt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new xt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: yt.background_vert,
        fragmentShader: yt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new xt
            }
        },
        vertexShader: yt.backgroundCube_vert,
        fragmentShader: yt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: yt.cube_vert,
        fragmentShader: yt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: yt.equirect_vert,
        fragmentShader: yt.equirect_frag
    },
    distanceRGBA: {
        uniforms: Qn([De.common, De.displacementmap, {
            referencePosition: {
                value: new B
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: yt.distanceRGBA_vert,
        fragmentShader: yt.distanceRGBA_frag
    },
    shadow: {
        uniforms: Qn([De.lights, De.fog, {
            color: {
                value: new Oe(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: yt.shadow_vert,
        fragmentShader: yt.shadow_frag
    }
};
ar.physical = {
    uniforms: Qn([ar.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new xt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new xt
        },
        clearcoatNormalScale: {
            value: new he(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new xt
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new xt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new xt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Oe(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new xt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new xt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new xt
        },
        transmissionSamplerSize: {
            value: new he
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new xt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Oe(0)
        },
        specularColor: {
            value: new Oe(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new xt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new xt
        },
        anisotropyVector: {
            value: new he
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new xt
        }
    }]),
    vertexShader: yt.meshphysical_vert,
    fragmentShader: yt.meshphysical_frag
};
const wd = {
    r: 0,
    b: 0,
    g: 0
}
  , mo = new Ri
  , y9 = new ct;
function S9(n, e, t, i, r, s, o) {
    const l = new Oe(0);
    let u = s === !0 ? 0 : 1, f, d, h = null, m = 0, g = null;
    function x(M) {
        let w = M.isScene === !0 ? M.background : null;
        return w && w.isTexture && (w = (M.backgroundBlurriness > 0 ? t : e).get(w)),
        w
    }
    function S(M) {
        let w = !1;
        const E = x(M);
        E === null ? v(l, u) : E && E.isColor && (v(E, 1),
        w = !0);
        const O = n.xr.getEnvironmentBlendMode();
        O === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : O === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
        (n.autoClear || w) && (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil))
    }
    function _(M, w) {
        const E = x(w);
        E && (E.isCubeTexture || E.mapping === bl) ? (d === void 0 && (d = new Sn(new $o(1,1,1),new Yi({
            name: "BackgroundCubeMaterial",
            uniforms: pl(ar.backgroundCube.uniforms),
            vertexShader: ar.backgroundCube.vertexShader,
            fragmentShader: ar.backgroundCube.fragmentShader,
            side: ri,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        d.geometry.deleteAttribute("normal"),
        d.geometry.deleteAttribute("uv"),
        d.onBeforeRender = function(O, R, A) {
            this.matrixWorld.copyPosition(A.matrixWorld)
        }
        ,
        Object.defineProperty(d.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(d)),
        mo.copy(w.backgroundRotation),
        mo.x *= -1,
        mo.y *= -1,
        mo.z *= -1,
        E.isCubeTexture && E.isRenderTargetTexture === !1 && (mo.y *= -1,
        mo.z *= -1),
        d.material.uniforms.envMap.value = E,
        d.material.uniforms.flipEnvMap.value = E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1,
        d.material.uniforms.backgroundBlurriness.value = w.backgroundBlurriness,
        d.material.uniforms.backgroundIntensity.value = w.backgroundIntensity,
        d.material.uniforms.backgroundRotation.value.setFromMatrix4(y9.makeRotationFromEuler(mo)),
        d.material.toneMapped = kt.getTransfer(E.colorSpace) !== $t,
        (h !== E || m !== E.version || g !== n.toneMapping) && (d.material.needsUpdate = !0,
        h = E,
        m = E.version,
        g = n.toneMapping),
        d.layers.enableAll(),
        M.unshift(d, d.geometry, d.material, 0, 0, null)) : E && E.isTexture && (f === void 0 && (f = new Sn(new Cl(2,2),new Yi({
            name: "BackgroundMaterial",
            uniforms: pl(ar.background.uniforms),
            vertexShader: ar.background.vertexShader,
            fragmentShader: ar.background.fragmentShader,
            side: Dr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        f.geometry.deleteAttribute("normal"),
        Object.defineProperty(f.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(f)),
        f.material.uniforms.t2D.value = E,
        f.material.uniforms.backgroundIntensity.value = w.backgroundIntensity,
        f.material.toneMapped = kt.getTransfer(E.colorSpace) !== $t,
        E.matrixAutoUpdate === !0 && E.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(E.matrix),
        (h !== E || m !== E.version || g !== n.toneMapping) && (f.material.needsUpdate = !0,
        h = E,
        m = E.version,
        g = n.toneMapping),
        f.layers.enableAll(),
        M.unshift(f, f.geometry, f.material, 0, 0, null))
    }
    function v(M, w) {
        M.getRGB(wd, Lb(n)),
        i.buffers.color.setClear(wd.r, wd.g, wd.b, w, o)
    }
    return {
        getClearColor: function() {
            return l
        },
        setClearColor: function(M, w=1) {
            l.set(M),
            u = w,
            v(l, u)
        },
        getClearAlpha: function() {
            return u
        },
        setClearAlpha: function(M) {
            u = M,
            v(l, u)
        },
        render: S,
        addToRenderList: _
    }
}
function M9(n, e) {
    const t = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , i = {}
      , r = m(null);
    let s = r
      , o = !1;
    function l(P, D, W, X, G) {
        let q = !1;
        const K = h(X, W, D);
        s !== K && (s = K,
        f(s.object)),
        q = g(P, X, W, G),
        q && x(P, X, W, G),
        G !== null && e.update(G, n.ELEMENT_ARRAY_BUFFER),
        (q || o) && (o = !1,
        E(P, D, W, X),
        G !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(G).buffer))
    }
    function u() {
        return n.createVertexArray()
    }
    function f(P) {
        return n.bindVertexArray(P)
    }
    function d(P) {
        return n.deleteVertexArray(P)
    }
    function h(P, D, W) {
        const X = W.wireframe === !0;
        let G = i[P.id];
        G === void 0 && (G = {},
        i[P.id] = G);
        let q = G[D.id];
        q === void 0 && (q = {},
        G[D.id] = q);
        let K = q[X];
        return K === void 0 && (K = m(u()),
        q[X] = K),
        K
    }
    function m(P) {
        const D = []
          , W = []
          , X = [];
        for (let G = 0; G < t; G++)
            D[G] = 0,
            W[G] = 0,
            X[G] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: D,
            enabledAttributes: W,
            attributeDivisors: X,
            object: P,
            attributes: {},
            index: null
        }
    }
    function g(P, D, W, X) {
        const G = s.attributes
          , q = D.attributes;
        let K = 0;
        const oe = W.getAttributes();
        for (const z in oe)
            if (oe[z].location >= 0) {
                const Q = G[z];
                let ce = q[z];
                if (ce === void 0 && (z === "instanceMatrix" && P.instanceMatrix && (ce = P.instanceMatrix),
                z === "instanceColor" && P.instanceColor && (ce = P.instanceColor)),
                Q === void 0 || Q.attribute !== ce || ce && Q.data !== ce.data)
                    return !0;
                K++
            }
        return s.attributesNum !== K || s.index !== X
    }
    function x(P, D, W, X) {
        const G = {}
          , q = D.attributes;
        let K = 0;
        const oe = W.getAttributes();
        for (const z in oe)
            if (oe[z].location >= 0) {
                let Q = q[z];
                Q === void 0 && (z === "instanceMatrix" && P.instanceMatrix && (Q = P.instanceMatrix),
                z === "instanceColor" && P.instanceColor && (Q = P.instanceColor));
                const ce = {};
                ce.attribute = Q,
                Q && Q.data && (ce.data = Q.data),
                G[z] = ce,
                K++
            }
        s.attributes = G,
        s.attributesNum = K,
        s.index = X
    }
    function S() {
        const P = s.newAttributes;
        for (let D = 0, W = P.length; D < W; D++)
            P[D] = 0
    }
    function _(P) {
        v(P, 0)
    }
    function v(P, D) {
        const W = s.newAttributes
          , X = s.enabledAttributes
          , G = s.attributeDivisors;
        W[P] = 1,
        X[P] === 0 && (n.enableVertexAttribArray(P),
        X[P] = 1),
        G[P] !== D && (n.vertexAttribDivisor(P, D),
        G[P] = D)
    }
    function M() {
        const P = s.newAttributes
          , D = s.enabledAttributes;
        for (let W = 0, X = D.length; W < X; W++)
            D[W] !== P[W] && (n.disableVertexAttribArray(W),
            D[W] = 0)
    }
    function w(P, D, W, X, G, q, K) {
        K === !0 ? n.vertexAttribIPointer(P, D, W, G, q) : n.vertexAttribPointer(P, D, W, X, G, q)
    }
    function E(P, D, W, X) {
        S();
        const G = X.attributes
          , q = W.getAttributes()
          , K = D.defaultAttributeValues;
        for (const oe in q) {
            const z = q[oe];
            if (z.location >= 0) {
                let ee = G[oe];
                if (ee === void 0 && (oe === "instanceMatrix" && P.instanceMatrix && (ee = P.instanceMatrix),
                oe === "instanceColor" && P.instanceColor && (ee = P.instanceColor)),
                ee !== void 0) {
                    const Q = ee.normalized
                      , ce = ee.itemSize
                      , be = e.get(ee);
                    if (be === void 0)
                        continue;
                    const Ue = be.buffer
                      , se = be.type
                      , ue = be.bytesPerElement
                      , Te = se === n.INT || se === n.UNSIGNED_INT || ee.gpuType === Xp;
                    if (ee.isInterleavedBufferAttribute) {
                        const Me = ee.data
                          , Ye = Me.stride
                          , Qe = ee.offset;
                        if (Me.isInstancedInterleavedBuffer) {
                            for (let ze = 0; ze < z.locationSize; ze++)
                                v(z.location + ze, Me.meshPerAttribute);
                            P.isInstancedMesh !== !0 && X._maxInstanceCount === void 0 && (X._maxInstanceCount = Me.meshPerAttribute * Me.count)
                        } else
                            for (let ze = 0; ze < z.locationSize; ze++)
                                _(z.location + ze);
                        n.bindBuffer(n.ARRAY_BUFFER, Ue);
                        for (let ze = 0; ze < z.locationSize; ze++)
                            w(z.location + ze, ce / z.locationSize, se, Q, Ye * ue, (Qe + ce / z.locationSize * ze) * ue, Te)
                    } else {
                        if (ee.isInstancedBufferAttribute) {
                            for (let Me = 0; Me < z.locationSize; Me++)
                                v(z.location + Me, ee.meshPerAttribute);
                            P.isInstancedMesh !== !0 && X._maxInstanceCount === void 0 && (X._maxInstanceCount = ee.meshPerAttribute * ee.count)
                        } else
                            for (let Me = 0; Me < z.locationSize; Me++)
                                _(z.location + Me);
                        n.bindBuffer(n.ARRAY_BUFFER, Ue);
                        for (let Me = 0; Me < z.locationSize; Me++)
                            w(z.location + Me, ce / z.locationSize, se, Q, ce * ue, ce / z.locationSize * Me * ue, Te)
                    }
                } else if (K !== void 0) {
                    const Q = K[oe];
                    if (Q !== void 0)
                        switch (Q.length) {
                        case 2:
                            n.vertexAttrib2fv(z.location, Q);
                            break;
                        case 3:
                            n.vertexAttrib3fv(z.location, Q);
                            break;
                        case 4:
                            n.vertexAttrib4fv(z.location, Q);
                            break;
                        default:
                            n.vertexAttrib1fv(z.location, Q)
                        }
                }
            }
        }
        M()
    }
    function O() {
        F();
        for (const P in i) {
            const D = i[P];
            for (const W in D) {
                const X = D[W];
                for (const G in X)
                    d(X[G].object),
                    delete X[G];
                delete D[W]
            }
            delete i[P]
        }
    }
    function R(P) {
        if (i[P.id] === void 0)
            return;
        const D = i[P.id];
        for (const W in D) {
            const X = D[W];
            for (const G in X)
                d(X[G].object),
                delete X[G];
            delete D[W]
        }
        delete i[P.id]
    }
    function A(P) {
        for (const D in i) {
            const W = i[D];
            if (W[P.id] === void 0)
                continue;
            const X = W[P.id];
            for (const G in X)
                d(X[G].object),
                delete X[G];
            delete W[P.id]
        }
    }
    function F() {
        I(),
        o = !0,
        s !== r && (s = r,
        f(s.object))
    }
    function I() {
        r.geometry = null,
        r.program = null,
        r.wireframe = !1
    }
    return {
        setup: l,
        reset: F,
        resetDefaultState: I,
        dispose: O,
        releaseStatesOfGeometry: R,
        releaseStatesOfProgram: A,
        initAttributes: S,
        enableAttribute: _,
        disableUnusedAttributes: M
    }
}
function w9(n, e, t) {
    let i;
    function r(f) {
        i = f
    }
    function s(f, d) {
        n.drawArrays(i, f, d),
        t.update(d, i, 1)
    }
    function o(f, d, h) {
        h !== 0 && (n.drawArraysInstanced(i, f, d, h),
        t.update(d, i, h))
    }
    function l(f, d, h) {
        if (h === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, f, 0, d, 0, h);
        let g = 0;
        for (let x = 0; x < h; x++)
            g += d[x];
        t.update(g, i, 1)
    }
    function u(f, d, h, m) {
        if (h === 0)
            return;
        const g = e.get("WEBGL_multi_draw");
        if (g === null)
            for (let x = 0; x < f.length; x++)
                o(f[x], d[x], m[x]);
        else {
            g.multiDrawArraysInstancedWEBGL(i, f, 0, d, 0, m, 0, h);
            let x = 0;
            for (let S = 0; S < h; S++)
                x += d[S];
            for (let S = 0; S < m.length; S++)
                t.update(x, i, m[S])
        }
    }
    this.setMode = r,
    this.render = s,
    this.renderInstances = o,
    this.renderMultiDraw = l,
    this.renderMultiDrawInstances = u
}
function b9(n, e, t, i) {
    let r;
    function s() {
        if (r !== void 0)
            return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const R = e.get("EXT_texture_filter_anisotropic");
            r = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            r = 0;
        return r
    }
    function o(R) {
        return !(R !== qn && i.convert(R) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function l(R) {
        const A = R === Xo && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(R !== fr && i.convert(R) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && R !== ii && !A)
    }
    function u(R) {
        if (R === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            R = "mediump"
        }
        return R === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let f = t.precision !== void 0 ? t.precision : "highp";
    const d = u(f);
    d !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", d, "instead."),
    f = d);
    const h = t.logarithmicDepthBuffer === !0
      , m = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , g = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , x = n.getParameter(n.MAX_TEXTURE_SIZE)
      , S = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , _ = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , v = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , M = n.getParameter(n.MAX_VARYING_VECTORS)
      , w = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , E = g > 0
      , O = n.getParameter(n.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: u,
        textureFormatReadable: o,
        textureTypeReadable: l,
        precision: f,
        logarithmicDepthBuffer: h,
        maxTextures: m,
        maxVertexTextures: g,
        maxTextureSize: x,
        maxCubemapSize: S,
        maxAttributes: _,
        maxVertexUniforms: v,
        maxVaryings: M,
        maxFragmentUniforms: w,
        vertexTextures: E,
        maxSamples: O
    }
}
function E9(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new Is
      , l = new xt
      , u = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = u,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, m) {
        const g = h.length !== 0 || m || i !== 0 || r;
        return r = m,
        i = h.length,
        g
    }
    ,
    this.beginShadows = function() {
        s = !0,
        d(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(h, m) {
        t = d(h, m, 0)
    }
    ,
    this.setState = function(h, m, g) {
        const x = h.clippingPlanes
          , S = h.clipIntersection
          , _ = h.clipShadows
          , v = n.get(h);
        if (!r || x === null || x.length === 0 || s && !_)
            s ? d(null) : f();
        else {
            const M = s ? 0 : i
              , w = M * 4;
            let E = v.clippingState || null;
            u.value = E,
            E = d(x, m, w, g);
            for (let O = 0; O !== w; ++O)
                E[O] = t[O];
            v.clippingState = E,
            this.numIntersection = S ? this.numPlanes : 0,
            this.numPlanes += M
        }
    }
    ;
    function f() {
        u.value !== t && (u.value = t,
        u.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function d(h, m, g, x) {
        const S = h !== null ? h.length : 0;
        let _ = null;
        if (S !== 0) {
            if (_ = u.value,
            x !== !0 || _ === null) {
                const v = g + S * 4
                  , M = m.matrixWorldInverse;
                l.getNormalMatrix(M),
                (_ === null || _.length < v) && (_ = new Float32Array(v));
                for (let w = 0, E = g; w !== S; ++w,
                E += 4)
                    o.copy(h[w]).applyMatrix4(M, l),
                    o.normal.toArray(_, E),
                    _[E + 3] = o.constant
            }
            u.value = _,
            u.needsUpdate = !0
        }
        return e.numPlanes = S,
        e.numIntersection = 0,
        _
    }
}
function C9(n) {
    let e = new WeakMap;
    function t(o, l) {
        return l === eu ? o.mapping = os : l === tu && (o.mapping = Gs),
        o
    }
    function i(o) {
        if (o && o.isTexture) {
            const l = o.mapping;
            if (l === eu || l === tu)
                if (e.has(o)) {
                    const u = e.get(o).texture;
                    return t(u, o.mapping)
                } else {
                    const u = o.image;
                    if (u && u.height > 0) {
                        const f = new xx(u.height);
                        return f.fromEquirectangularTexture(n, o),
                        e.set(o, f),
                        o.addEventListener("dispose", r),
                        t(f.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const l = o.target;
        l.removeEventListener("dispose", r);
        const u = e.get(l);
        u !== void 0 && (e.delete(l),
        u.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class qo extends Uu {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , l = r + t
          , u = r - t;
        if (this.view !== null && this.view.enabled) {
            const f = (this.right - this.left) / this.view.fullWidth / this.zoom
              , d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += f * this.view.offsetX,
            o = s + f * this.view.width,
            l -= d * this.view.offsetY,
            u = l - d * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, l, u, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const $a = 4
  , dS = [.125, .215, .35, .446, .526, .582]
  , To = 20
  , wg = new qo
  , hS = new Oe;
let bg = null
  , Eg = 0
  , Cg = 0
  , Tg = !1;
const bo = (1 + Math.sqrt(5)) / 2
  , Oa = 1 / bo
  , pS = [new B(-bo,Oa,0), new B(bo,Oa,0), new B(-Oa,0,bo), new B(Oa,0,bo), new B(0,bo,-Oa), new B(0,bo,Oa), new B(-1,1,-1), new B(1,1,-1), new B(-1,1,1), new B(1,1,1)];
class U1 {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        bg = this._renderer.getRenderTarget(),
        Eg = this._renderer.getActiveCubeFace(),
        Cg = this._renderer.getActiveMipmapLevel(),
        Tg = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = vS(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = gS(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(bg, Eg, Cg),
        this._renderer.xr.enabled = Tg,
        e.scissorTest = !1,
        bd(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === os || e.mapping === Gs ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        bg = this._renderer.getRenderTarget(),
        Eg = this._renderer.getActiveCubeFace(),
        Cg = this._renderer.getActiveMipmapLevel(),
        Tg = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: ln,
            minFilter: ln,
            generateMipmaps: !1,
            type: Xo,
            format: qn,
            colorSpace: us,
            depthBuffer: !1
        }
          , r = mS(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = mS(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = T9(s)),
            this._blurMaterial = A9(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new Sn(this._lodPlanes[0],e);
        this._renderer.compile(t, wg)
    }
    _sceneToCubeUV(e, t, i, r) {
        const l = new yn(90,1,t,i)
          , u = [1, -1, 1, 1, 1, 1]
          , f = [1, 1, 1, -1, -1, -1]
          , d = this._renderer
          , h = d.autoClear
          , m = d.toneMapping;
        d.getClearColor(hS),
        d.toneMapping = Pr,
        d.autoClear = !1;
        const g = new qs({
            name: "PMREM.Background",
            side: ri,
            depthWrite: !1,
            depthTest: !1
        })
          , x = new Sn(new $o,g);
        let S = !1;
        const _ = e.background;
        _ ? _.isColor && (g.color.copy(_),
        e.background = null,
        S = !0) : (g.color.copy(hS),
        S = !0);
        for (let v = 0; v < 6; v++) {
            const M = v % 3;
            M === 0 ? (l.up.set(0, u[v], 0),
            l.lookAt(f[v], 0, 0)) : M === 1 ? (l.up.set(0, 0, u[v]),
            l.lookAt(0, f[v], 0)) : (l.up.set(0, u[v], 0),
            l.lookAt(0, 0, f[v]));
            const w = this._cubeSize;
            bd(r, M * w, v > 2 ? w : 0, w, w),
            d.setRenderTarget(r),
            S && d.render(x, l),
            d.render(e, l)
        }
        x.geometry.dispose(),
        x.material.dispose(),
        d.toneMapping = m,
        d.autoClear = h,
        e.background = _
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === os || e.mapping === Gs;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = vS()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = gS());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new Sn(this._lodPlanes[0],s)
          , l = s.uniforms;
        l.envMap.value = e;
        const u = this._cubeSize;
        bd(t, 0, 0, 3 * u, 2 * u),
        i.setRenderTarget(t),
        i.render(o, wg)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        const r = this._lodPlanes.length;
        for (let s = 1; s < r; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
              , l = pS[(r - s - 1) % pS.length];
            this._blur(e, s - 1, s, o, l)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, l) {
        const u = this._renderer
          , f = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const d = 3
          , h = new Sn(this._lodPlanes[r],f)
          , m = f.uniforms
          , g = this._sizeLods[i] - 1
          , x = isFinite(s) ? Math.PI / (2 * g) : 2 * Math.PI / (2 * To - 1)
          , S = s / x
          , _ = isFinite(s) ? 1 + Math.floor(d * S) : To;
        _ > To && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${To}`);
        const v = [];
        let M = 0;
        for (let A = 0; A < To; ++A) {
            const F = A / S
              , I = Math.exp(-F * F / 2);
            v.push(I),
            A === 0 ? M += I : A < _ && (M += 2 * I)
        }
        for (let A = 0; A < v.length; A++)
            v[A] = v[A] / M;
        m.envMap.value = e.texture,
        m.samples.value = _,
        m.weights.value = v,
        m.latitudinal.value = o === "latitudinal",
        l && (m.poleAxis.value = l);
        const {_lodMax: w} = this;
        m.dTheta.value = x,
        m.mipInt.value = w - i;
        const E = this._sizeLods[r]
          , O = 3 * E * (r > w - $a ? r - w + $a : 0)
          , R = 4 * (this._cubeSize - E);
        bd(t, O, R, 3 * E, 2 * E),
        u.setRenderTarget(t),
        u.render(h, wg)
    }
}
function T9(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - $a + 1 + dS.length;
    for (let o = 0; o < s; o++) {
        const l = Math.pow(2, r);
        t.push(l);
        let u = 1 / l;
        o > n - $a ? u = dS[o - n + $a - 1] : o === 0 && (u = 0),
        i.push(u);
        const f = 1 / (l - 2)
          , d = -f
          , h = 1 + f
          , m = [d, d, h, d, h, h, d, d, h, h, d, h]
          , g = 6
          , x = 6
          , S = 3
          , _ = 2
          , v = 1
          , M = new Float32Array(S * x * g)
          , w = new Float32Array(_ * x * g)
          , E = new Float32Array(v * x * g);
        for (let R = 0; R < g; R++) {
            const A = R % 3 * 2 / 3 - 1
              , F = R > 2 ? 0 : -1
              , I = [A, F, 0, A + 2 / 3, F, 0, A + 2 / 3, F + 1, 0, A, F, 0, A + 2 / 3, F + 1, 0, A, F + 1, 0];
            M.set(I, S * x * R),
            w.set(m, _ * x * R);
            const P = [R, R, R, R, R, R];
            E.set(P, v * x * R)
        }
        const O = new St;
        O.setAttribute("position", new Vt(M,S)),
        O.setAttribute("uv", new Vt(w,_)),
        O.setAttribute("faceIndex", new Vt(E,v)),
        e.push(O),
        r > $a && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function mS(n, e, t) {
    const i = new qi(n,e,t);
    return i.texture.mapping = bl,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function bd(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function A9(n, e, t) {
    const i = new Float32Array(To)
      , r = new B(0,1,0);
    return new Yi({
        name: "SphericalGaussianBlur",
        defines: {
            n: To,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: _x(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: is,
        depthTest: !1,
        depthWrite: !1
    })
}
function gS() {
    return new Yi({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: _x(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: is,
        depthTest: !1,
        depthWrite: !1
    })
}
function vS() {
    return new Yi({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: _x(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: is,
        depthTest: !1,
        depthWrite: !1
    })
}
function _x() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function R9(n) {
    let e = new WeakMap
      , t = null;
    function i(l) {
        if (l && l.isTexture) {
            const u = l.mapping
              , f = u === eu || u === tu
              , d = u === os || u === Gs;
            if (f || d) {
                let h = e.get(l);
                const m = h !== void 0 ? h.texture.pmremVersion : 0;
                if (l.isRenderTargetTexture && l.pmremVersion !== m)
                    return t === null && (t = new U1(n)),
                    h = f ? t.fromEquirectangular(l, h) : t.fromCubemap(l, h),
                    h.texture.pmremVersion = l.pmremVersion,
                    e.set(l, h),
                    h.texture;
                if (h !== void 0)
                    return h.texture;
                {
                    const g = l.image;
                    return f && g && g.height > 0 || d && g && r(g) ? (t === null && (t = new U1(n)),
                    h = f ? t.fromEquirectangular(l) : t.fromCubemap(l),
                    h.texture.pmremVersion = l.pmremVersion,
                    e.set(l, h),
                    l.addEventListener("dispose", s),
                    h.texture) : null
                }
            }
        }
        return l
    }
    function r(l) {
        let u = 0;
        const f = 6;
        for (let d = 0; d < f; d++)
            l[d] !== void 0 && u++;
        return u === f
    }
    function s(l) {
        const u = l.target;
        u.removeEventListener("dispose", s);
        const f = e.get(u);
        f !== void 0 && (e.delete(u),
        f.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function P9(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(i) {
            const r = t(i);
            return r === null && dx("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function I9(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(h) {
        const m = h.target;
        m.index !== null && e.remove(m.index);
        for (const x in m.attributes)
            e.remove(m.attributes[x]);
        for (const x in m.morphAttributes) {
            const S = m.morphAttributes[x];
            for (let _ = 0, v = S.length; _ < v; _++)
                e.remove(S[_])
        }
        m.removeEventListener("dispose", o),
        delete r[m.id];
        const g = s.get(m);
        g && (e.remove(g),
        s.delete(m)),
        i.releaseStatesOfGeometry(m),
        m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount,
        t.memory.geometries--
    }
    function l(h, m) {
        return r[m.id] === !0 || (m.addEventListener("dispose", o),
        r[m.id] = !0,
        t.memory.geometries++),
        m
    }
    function u(h) {
        const m = h.attributes;
        for (const x in m)
            e.update(m[x], n.ARRAY_BUFFER);
        const g = h.morphAttributes;
        for (const x in g) {
            const S = g[x];
            for (let _ = 0, v = S.length; _ < v; _++)
                e.update(S[_], n.ARRAY_BUFFER)
        }
    }
    function f(h) {
        const m = []
          , g = h.index
          , x = h.attributes.position;
        let S = 0;
        if (g !== null) {
            const M = g.array;
            S = g.version;
            for (let w = 0, E = M.length; w < E; w += 3) {
                const O = M[w + 0]
                  , R = M[w + 1]
                  , A = M[w + 2];
                m.push(O, R, R, A, A, O)
            }
        } else if (x !== void 0) {
            const M = x.array;
            S = x.version;
            for (let w = 0, E = M.length / 3 - 1; w < E; w += 3) {
                const O = w + 0
                  , R = w + 1
                  , A = w + 2;
                m.push(O, R, R, A, A, O)
            }
        } else
            return;
        const _ = new (Tb(m) ? mx : px)(m,1);
        _.version = S;
        const v = s.get(h);
        v && e.remove(v),
        s.set(h, _)
    }
    function d(h) {
        const m = s.get(h);
        if (m) {
            const g = h.index;
            g !== null && m.version < g.version && f(h)
        } else
            f(h);
        return s.get(h)
    }
    return {
        get: l,
        update: u,
        getWireframeAttribute: d
    }
}
function L9(n, e, t) {
    let i;
    function r(m) {
        i = m
    }
    let s, o;
    function l(m) {
        s = m.type,
        o = m.bytesPerElement
    }
    function u(m, g) {
        n.drawElements(i, g, s, m * o),
        t.update(g, i, 1)
    }
    function f(m, g, x) {
        x !== 0 && (n.drawElementsInstanced(i, g, s, m * o, x),
        t.update(g, i, x))
    }
    function d(m, g, x) {
        if (x === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, g, 0, s, m, 0, x);
        let _ = 0;
        for (let v = 0; v < x; v++)
            _ += g[v];
        t.update(_, i, 1)
    }
    function h(m, g, x, S) {
        if (x === 0)
            return;
        const _ = e.get("WEBGL_multi_draw");
        if (_ === null)
            for (let v = 0; v < m.length; v++)
                f(m[v] / o, g[v], S[v]);
        else {
            _.multiDrawElementsInstancedWEBGL(i, g, 0, s, m, 0, S, 0, x);
            let v = 0;
            for (let M = 0; M < x; M++)
                v += g[M];
            for (let M = 0; M < S.length; M++)
                t.update(v, i, S[M])
        }
    }
    this.setMode = r,
    this.setIndex = l,
    this.render = u,
    this.renderInstances = f,
    this.renderMultiDraw = d,
    this.renderMultiDrawInstances = h
}
function N9(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, l) {
        switch (t.calls++,
        o) {
        case n.TRIANGLES:
            t.triangles += l * (s / 3);
            break;
        case n.LINES:
            t.lines += l * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += l * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += l * s;
            break;
        case n.POINTS:
            t.points += l * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function O9(n, e, t) {
    const i = new WeakMap
      , r = new Bt;
    function s(o, l, u) {
        const f = o.morphTargetInfluences
          , d = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color
          , h = d !== void 0 ? d.length : 0;
        let m = i.get(l);
        if (m === void 0 || m.count !== h) {
            let I = function() {
                A.dispose(),
                i.delete(l),
                l.removeEventListener("dispose", I)
            };
            m !== void 0 && m.texture.dispose();
            const g = l.morphAttributes.position !== void 0
              , x = l.morphAttributes.normal !== void 0
              , S = l.morphAttributes.color !== void 0
              , _ = l.morphAttributes.position || []
              , v = l.morphAttributes.normal || []
              , M = l.morphAttributes.color || [];
            let w = 0;
            g === !0 && (w = 1),
            x === !0 && (w = 2),
            S === !0 && (w = 3);
            let E = l.attributes.position.count * w
              , O = 1;
            E > e.maxTextureSize && (O = Math.ceil(E / e.maxTextureSize),
            E = e.maxTextureSize);
            const R = new Float32Array(E * O * 4 * h)
              , A = new em(R,E,O,h);
            A.type = ii,
            A.needsUpdate = !0;
            const F = w * 4;
            for (let P = 0; P < h; P++) {
                const D = _[P]
                  , W = v[P]
                  , X = M[P]
                  , G = E * O * 4 * P;
                for (let q = 0; q < D.count; q++) {
                    const K = q * F;
                    g === !0 && (r.fromBufferAttribute(D, q),
                    R[G + K + 0] = r.x,
                    R[G + K + 1] = r.y,
                    R[G + K + 2] = r.z,
                    R[G + K + 3] = 0),
                    x === !0 && (r.fromBufferAttribute(W, q),
                    R[G + K + 4] = r.x,
                    R[G + K + 5] = r.y,
                    R[G + K + 6] = r.z,
                    R[G + K + 7] = 0),
                    S === !0 && (r.fromBufferAttribute(X, q),
                    R[G + K + 8] = r.x,
                    R[G + K + 9] = r.y,
                    R[G + K + 10] = r.z,
                    R[G + K + 11] = X.itemSize === 4 ? r.w : 1)
                }
            }
            m = {
                count: h,
                texture: A,
                size: new he(E,O)
            },
            i.set(l, m),
            l.addEventListener("dispose", I)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            u.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
        else {
            let g = 0;
            for (let S = 0; S < f.length; S++)
                g += f[S];
            const x = l.morphTargetsRelative ? 1 : 1 - g;
            u.getUniforms().setValue(n, "morphTargetBaseInfluence", x),
            u.getUniforms().setValue(n, "morphTargetInfluences", f)
        }
        u.getUniforms().setValue(n, "morphTargetsTexture", m.texture, t),
        u.getUniforms().setValue(n, "morphTargetsTextureSize", m.size)
    }
    return {
        update: s
    }
}
function D9(n, e, t, i) {
    let r = new WeakMap;
    function s(u) {
        const f = i.render.frame
          , d = u.geometry
          , h = e.get(u, d);
        if (r.get(h) !== f && (e.update(h),
        r.set(h, f)),
        u.isInstancedMesh && (u.hasEventListener("dispose", l) === !1 && u.addEventListener("dispose", l),
        r.get(u) !== f && (t.update(u.instanceMatrix, n.ARRAY_BUFFER),
        u.instanceColor !== null && t.update(u.instanceColor, n.ARRAY_BUFFER),
        r.set(u, f))),
        u.isSkinnedMesh) {
            const m = u.skeleton;
            r.get(m) !== f && (m.update(),
            r.set(m, f))
        }
        return h
    }
    function o() {
        r = new WeakMap
    }
    function l(u) {
        const f = u.target;
        f.removeEventListener("dispose", l),
        t.remove(f.instanceMatrix),
        f.instanceColor !== null && t.remove(f.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class tm extends en {
    constructor(e, t, i, r, s, o, l, u, f, d=Do) {
        if (d !== Do && d !== Vo)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && d === Do && (i = as),
        i === void 0 && d === Vo && (i = zo),
        super(null, r, s, o, l, u, d, i, f),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = l !== void 0 ? l : Ln,
        this.minFilter = u !== void 0 ? u : Ln,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const Ob = new en
  , xS = new tm(1,1)
  , Db = new em
  , Ub = new hx
  , Fb = new Fu
  , _S = []
  , yS = []
  , SS = new Float32Array(16)
  , MS = new Float32Array(9)
  , wS = new Float32Array(4);
function Tl(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = _S[r];
    if (s === void 0 && (s = new Float32Array(r),
    _S[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, l = 0; o !== e; ++o)
            l += t,
            n[o].toArray(s, l)
    }
    return s
}
function En(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function Cn(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function nm(n, e) {
    let t = yS[e];
    t === void 0 && (t = new Int32Array(e),
    yS[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function U9(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function F9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (En(t, e))
            return;
        n.uniform2fv(this.addr, e),
        Cn(t, e)
    }
}
function k9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (En(t, e))
            return;
        n.uniform3fv(this.addr, e),
        Cn(t, e)
    }
}
function B9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (En(t, e))
            return;
        n.uniform4fv(this.addr, e),
        Cn(t, e)
    }
}
function z9(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (En(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        Cn(t, e)
    } else {
        if (En(t, i))
            return;
        wS.set(i),
        n.uniformMatrix2fv(this.addr, !1, wS),
        Cn(t, i)
    }
}
function V9(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (En(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        Cn(t, e)
    } else {
        if (En(t, i))
            return;
        MS.set(i),
        n.uniformMatrix3fv(this.addr, !1, MS),
        Cn(t, i)
    }
}
function H9(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (En(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        Cn(t, e)
    } else {
        if (En(t, i))
            return;
        SS.set(i),
        n.uniformMatrix4fv(this.addr, !1, SS),
        Cn(t, i)
    }
}
function G9(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function W9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (En(t, e))
            return;
        n.uniform2iv(this.addr, e),
        Cn(t, e)
    }
}
function j9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (En(t, e))
            return;
        n.uniform3iv(this.addr, e),
        Cn(t, e)
    }
}
function X9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (En(t, e))
            return;
        n.uniform4iv(this.addr, e),
        Cn(t, e)
    }
}
function $9(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function q9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (En(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        Cn(t, e)
    }
}
function Y9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (En(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        Cn(t, e)
    }
}
function Z9(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (En(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        Cn(t, e)
    }
}
function K9(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r);
    let s;
    this.type === n.SAMPLER_2D_SHADOW ? (xS.compareFunction = ux,
    s = xS) : s = Ob,
    t.setTexture2D(e || s, r)
}
function J9(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || Ub, r)
}
function Q9(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || Fb, r)
}
function eO(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || Db, r)
}
function tO(n) {
    switch (n) {
    case 5126:
        return U9;
    case 35664:
        return F9;
    case 35665:
        return k9;
    case 35666:
        return B9;
    case 35674:
        return z9;
    case 35675:
        return V9;
    case 35676:
        return H9;
    case 5124:
    case 35670:
        return G9;
    case 35667:
    case 35671:
        return W9;
    case 35668:
    case 35672:
        return j9;
    case 35669:
    case 35673:
        return X9;
    case 5125:
        return $9;
    case 36294:
        return q9;
    case 36295:
        return Y9;
    case 36296:
        return Z9;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return K9;
    case 35679:
    case 36299:
    case 36307:
        return J9;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return Q9;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return eO
    }
}
function nO(n, e) {
    n.uniform1fv(this.addr, e)
}
function iO(n, e) {
    const t = Tl(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function rO(n, e) {
    const t = Tl(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function sO(n, e) {
    const t = Tl(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function oO(n, e) {
    const t = Tl(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function aO(n, e) {
    const t = Tl(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function lO(n, e) {
    const t = Tl(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function cO(n, e) {
    n.uniform1iv(this.addr, e)
}
function uO(n, e) {
    n.uniform2iv(this.addr, e)
}
function fO(n, e) {
    n.uniform3iv(this.addr, e)
}
function dO(n, e) {
    n.uniform4iv(this.addr, e)
}
function hO(n, e) {
    n.uniform1uiv(this.addr, e)
}
function pO(n, e) {
    n.uniform2uiv(this.addr, e)
}
function mO(n, e) {
    n.uniform3uiv(this.addr, e)
}
function gO(n, e) {
    n.uniform4uiv(this.addr, e)
}
function vO(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = nm(t, r);
    En(i, s) || (n.uniform1iv(this.addr, s),
    Cn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || Ob, s[o])
}
function xO(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = nm(t, r);
    En(i, s) || (n.uniform1iv(this.addr, s),
    Cn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || Ub, s[o])
}
function _O(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = nm(t, r);
    En(i, s) || (n.uniform1iv(this.addr, s),
    Cn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || Fb, s[o])
}
function yO(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = nm(t, r);
    En(i, s) || (n.uniform1iv(this.addr, s),
    Cn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || Db, s[o])
}
function SO(n) {
    switch (n) {
    case 5126:
        return nO;
    case 35664:
        return iO;
    case 35665:
        return rO;
    case 35666:
        return sO;
    case 35674:
        return oO;
    case 35675:
        return aO;
    case 35676:
        return lO;
    case 5124:
    case 35670:
        return cO;
    case 35667:
    case 35671:
        return uO;
    case 35668:
    case 35672:
        return fO;
    case 35669:
    case 35673:
        return dO;
    case 5125:
        return hO;
    case 36294:
        return pO;
    case 36295:
        return mO;
    case 36296:
        return gO;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return vO;
    case 35679:
    case 36299:
    case 36307:
        return xO;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return _O;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return yO
    }
}
class MO {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.setValue = tO(t.type)
    }
}
class wO {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = SO(t.type)
    }
}
class bO {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const l = r[s];
            l.setValue(e, t[l.id], i)
        }
    }
}
const Ag = /(\w+)(\])?(\[|\.)?/g;
function bS(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function EO(n, e, t) {
    const i = n.name
      , r = i.length;
    for (Ag.lastIndex = 0; ; ) {
        const s = Ag.exec(i)
          , o = Ag.lastIndex;
        let l = s[1];
        const u = s[2] === "]"
          , f = s[3];
        if (u && (l = l | 0),
        f === void 0 || f === "[" && o + 2 === r) {
            bS(t, f === void 0 ? new MO(l,n,e) : new wO(l,n,e));
            break
        } else {
            let h = t.map[l];
            h === void 0 && (h = new bO(l),
            bS(t, h)),
            t = h
        }
    }
}
class hh {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            EO(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const l = t[s]
              , u = i[l.id];
            u.needsUpdate !== !1 && l.setValue(e, u.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function ES(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
const CO = 37297;
let TO = 0;
function AO(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const l = o + 1;
        i.push(`${l === e ? ">" : " "} ${l}: ${t[o]}`)
    }
    return i.join(`
`)
}
function RO(n) {
    const e = kt.getPrimaries(kt.workingColorSpace)
      , t = kt.getPrimaries(n);
    let i;
    switch (e === t ? i = "" : e === lu && t === au ? i = "LinearDisplayP3ToLinearSRGB" : e === au && t === lu && (i = "LinearSRGBToLinearDisplayP3"),
    n) {
    case us:
    case Du:
        return [i, "LinearTransferOETF"];
    case Hi:
    case Qp:
        return [i, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
    }
}
function CS(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + AO(n.getShaderSource(e), o)
    } else
        return r
}
function PO(n, e) {
    const t = RO(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function IO(n, e) {
    let t;
    switch (e) {
    case ob:
        t = "Linear";
        break;
    case ab:
        t = "Reinhard";
        break;
    case lb:
        t = "OptimizedCineon";
        break;
    case Jv:
        t = "ACESFilmic";
        break;
    case ub:
        t = "AgX";
        break;
    case fb:
        t = "Neutral";
        break;
    case cb:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function LO(n) {
    return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Sc).join(`
`)
}
function NO(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function OO(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let l = 1;
        s.type === n.FLOAT_MAT2 && (l = 2),
        s.type === n.FLOAT_MAT3 && (l = 3),
        s.type === n.FLOAT_MAT4 && (l = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: l
        }
    }
    return t
}
function Sc(n) {
    return n !== ""
}
function TS(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function AS(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const DO = /^[ \t]*#include +<([\w\d./]+)>/gm;
function F1(n) {
    return n.replace(DO, FO)
}
const UO = new Map;
function FO(n, e) {
    let t = yt[e];
    if (t === void 0) {
        const i = UO.get(e);
        if (i !== void 0)
            t = yt[i],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return F1(t)
}
const kO = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function RS(n) {
    return n.replace(kO, BO)
}
function BO(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function PS(n) {
    let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function zO(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === Wp ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Rc ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === sr && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function VO(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case os:
        case Gs:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case bl:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function HO(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case Gs:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function GO(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case Nu:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case rb:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case sb:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function WO(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function jO(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , l = t.fragmentShader;
    const u = zO(t)
      , f = VO(t)
      , d = HO(t)
      , h = GO(t)
      , m = WO(t)
      , g = LO(t)
      , x = NO(s)
      , S = r.createProgram();
    let _, v, M = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (_ = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, x].filter(Sc).join(`
`),
    _.length > 0 && (_ += `
`),
    v = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, x].filter(Sc).join(`
`),
    v.length > 0 && (v += `
`)) : (_ = [PS(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, x, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Sc).join(`
`),
    v = [PS(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, x, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + h : "", m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "", m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "", m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Pr ? "#define TONE_MAPPING" : "", t.toneMapping !== Pr ? yt.tonemapping_pars_fragment : "", t.toneMapping !== Pr ? IO("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", yt.colorspace_pars_fragment, PO("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Sc).join(`
`)),
    o = F1(o),
    o = TS(o, t),
    o = AS(o, t),
    l = F1(l),
    l = TS(l, t),
    l = AS(l, t),
    o = RS(o),
    l = RS(l),
    t.isRawShaderMaterial !== !0 && (M = `#version 300 es
`,
    _ = [g, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + _,
    v = ["#define varying in", t.glslVersion === D1 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === D1 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + v);
    const w = M + _ + o
      , E = M + v + l
      , O = ES(r, r.VERTEX_SHADER, w)
      , R = ES(r, r.FRAGMENT_SHADER, E);
    r.attachShader(S, O),
    r.attachShader(S, R),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(S, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(S, 0, "position"),
    r.linkProgram(S);
    function A(D) {
        if (n.debug.checkShaderErrors) {
            const W = r.getProgramInfoLog(S).trim()
              , X = r.getShaderInfoLog(O).trim()
              , G = r.getShaderInfoLog(R).trim();
            let q = !0
              , K = !0;
            if (r.getProgramParameter(S, r.LINK_STATUS) === !1)
                if (q = !1,
                typeof n.debug.onShaderError == "function")
                    n.debug.onShaderError(r, S, O, R);
                else {
                    const oe = CS(r, O, "vertex")
                      , z = CS(r, R, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(S, r.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + W + `
` + oe + `
` + z)
                }
            else
                W !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", W) : (X === "" || G === "") && (K = !1);
            K && (D.diagnostics = {
                runnable: q,
                programLog: W,
                vertexShader: {
                    log: X,
                    prefix: _
                },
                fragmentShader: {
                    log: G,
                    prefix: v
                }
            })
        }
        r.deleteShader(O),
        r.deleteShader(R),
        F = new hh(r,S),
        I = OO(r, S)
    }
    let F;
    this.getUniforms = function() {
        return F === void 0 && A(this),
        F
    }
    ;
    let I;
    this.getAttributes = function() {
        return I === void 0 && A(this),
        I
    }
    ;
    let P = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return P === !1 && (P = r.getProgramParameter(S, CO)),
        P
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(S),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = TO++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = S,
    this.vertexShader = O,
    this.fragmentShader = R,
    this
}
let XO = 0;
class $O {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new qO(e),
        t.set(e, i)),
        i
    }
}
class qO {
    constructor(e) {
        this.id = XO++,
        this.code = e,
        this.usedTimes = 0
    }
}
function YO(n, e, t, i, r, s, o) {
    const l = new Fo
      , u = new $O
      , f = new Set
      , d = []
      , h = r.logarithmicDepthBuffer
      , m = r.vertexTextures;
    let g = r.precision;
    const x = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function S(I) {
        return f.add(I),
        I === 0 ? "uv" : `uv${I}`
    }
    function _(I, P, D, W, X) {
        const G = W.fog
          , q = X.geometry
          , K = I.isMeshStandardMaterial ? W.environment : null
          , oe = (I.isMeshStandardMaterial ? t : e).get(I.envMap || K)
          , z = oe && oe.mapping === bl ? oe.image.height : null
          , ee = x[I.type];
        I.precision !== null && (g = r.getMaxPrecision(I.precision),
        g !== I.precision && console.warn("THREE.WebGLProgram.getParameters:", I.precision, "not supported, using", g, "instead."));
        const Q = q.morphAttributes.position || q.morphAttributes.normal || q.morphAttributes.color
          , ce = Q !== void 0 ? Q.length : 0;
        let be = 0;
        q.morphAttributes.position !== void 0 && (be = 1),
        q.morphAttributes.normal !== void 0 && (be = 2),
        q.morphAttributes.color !== void 0 && (be = 3);
        let Ue, se, ue, Te;
        if (ee) {
            const Rt = ar[ee];
            Ue = Rt.vertexShader,
            se = Rt.fragmentShader
        } else
            Ue = I.vertexShader,
            se = I.fragmentShader,
            u.update(I),
            ue = u.getVertexShaderID(I),
            Te = u.getFragmentShaderID(I);
        const Me = n.getRenderTarget()
          , Ye = X.isInstancedMesh === !0
          , Qe = X.isBatchedMesh === !0
          , ze = !!I.map
          , ke = !!I.matcap
          , k = !!oe
          , pe = !!I.aoMap
          , ye = !!I.lightMap
          , Pe = !!I.bumpMap
          , fe = !!I.normalMap
          , $e = !!I.displacementMap
          , Le = !!I.emissiveMap
          , Be = !!I.metalnessMap
          , H = !!I.roughnessMap
          , L = I.anisotropy > 0
          , te = I.clearcoat > 0
          , _e = I.dispersion > 0
          , ge = I.iridescence > 0
          , ve = I.sheen > 0
          , Ke = I.transmission > 0
          , we = L && !!I.anisotropyMap
          , He = te && !!I.clearcoatMap
          , ft = te && !!I.clearcoatNormalMap
          , Ee = te && !!I.clearcoatRoughnessMap
          , We = ge && !!I.iridescenceMap
          , Ct = ge && !!I.iridescenceThicknessMap
          , dt = ve && !!I.sheenColorMap
          , je = ve && !!I.sheenRoughnessMap
          , pt = !!I.specularMap
          , Mt = !!I.specularColorMap
          , Gt = !!I.specularIntensityMap
          , $ = Ke && !!I.transmissionMap
          , Ae = Ke && !!I.thicknessMap
          , me = !!I.gradientMap
          , xe = !!I.alphaMap
          , Ne = I.alphaTest > 0
          , ut = !!I.alphaHash
          , Tt = !!I.extensions;
        let Kt = Pr;
        I.toneMapped && (Me === null || Me.isXRRenderTarget === !0) && (Kt = n.toneMapping);
        const Mn = {
            shaderID: ee,
            shaderType: I.type,
            shaderName: I.name,
            vertexShader: Ue,
            fragmentShader: se,
            defines: I.defines,
            customVertexShaderID: ue,
            customFragmentShaderID: Te,
            isRawShaderMaterial: I.isRawShaderMaterial === !0,
            glslVersion: I.glslVersion,
            precision: g,
            batching: Qe,
            batchingColor: Qe && X._colorsTexture !== null,
            instancing: Ye,
            instancingColor: Ye && X.instanceColor !== null,
            instancingMorph: Ye && X.morphTexture !== null,
            supportsVertexTextures: m,
            outputColorSpace: Me === null ? n.outputColorSpace : Me.isXRRenderTarget === !0 ? Me.texture.colorSpace : us,
            alphaToCoverage: !!I.alphaToCoverage,
            map: ze,
            matcap: ke,
            envMap: k,
            envMapMode: k && oe.mapping,
            envMapCubeUVHeight: z,
            aoMap: pe,
            lightMap: ye,
            bumpMap: Pe,
            normalMap: fe,
            displacementMap: m && $e,
            emissiveMap: Le,
            normalMapObjectSpace: fe && I.normalMapType === xb,
            normalMapTangentSpace: fe && I.normalMapType === $s,
            metalnessMap: Be,
            roughnessMap: H,
            anisotropy: L,
            anisotropyMap: we,
            clearcoat: te,
            clearcoatMap: He,
            clearcoatNormalMap: ft,
            clearcoatRoughnessMap: Ee,
            dispersion: _e,
            iridescence: ge,
            iridescenceMap: We,
            iridescenceThicknessMap: Ct,
            sheen: ve,
            sheenColorMap: dt,
            sheenRoughnessMap: je,
            specularMap: pt,
            specularColorMap: Mt,
            specularIntensityMap: Gt,
            transmission: Ke,
            transmissionMap: $,
            thicknessMap: Ae,
            gradientMap: me,
            opaque: I.transparent === !1 && I.blending === Oo && I.alphaToCoverage === !1,
            alphaMap: xe,
            alphaTest: Ne,
            alphaHash: ut,
            combine: I.combine,
            mapUv: ze && S(I.map.channel),
            aoMapUv: pe && S(I.aoMap.channel),
            lightMapUv: ye && S(I.lightMap.channel),
            bumpMapUv: Pe && S(I.bumpMap.channel),
            normalMapUv: fe && S(I.normalMap.channel),
            displacementMapUv: $e && S(I.displacementMap.channel),
            emissiveMapUv: Le && S(I.emissiveMap.channel),
            metalnessMapUv: Be && S(I.metalnessMap.channel),
            roughnessMapUv: H && S(I.roughnessMap.channel),
            anisotropyMapUv: we && S(I.anisotropyMap.channel),
            clearcoatMapUv: He && S(I.clearcoatMap.channel),
            clearcoatNormalMapUv: ft && S(I.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Ee && S(I.clearcoatRoughnessMap.channel),
            iridescenceMapUv: We && S(I.iridescenceMap.channel),
            iridescenceThicknessMapUv: Ct && S(I.iridescenceThicknessMap.channel),
            sheenColorMapUv: dt && S(I.sheenColorMap.channel),
            sheenRoughnessMapUv: je && S(I.sheenRoughnessMap.channel),
            specularMapUv: pt && S(I.specularMap.channel),
            specularColorMapUv: Mt && S(I.specularColorMap.channel),
            specularIntensityMapUv: Gt && S(I.specularIntensityMap.channel),
            transmissionMapUv: $ && S(I.transmissionMap.channel),
            thicknessMapUv: Ae && S(I.thicknessMap.channel),
            alphaMapUv: xe && S(I.alphaMap.channel),
            vertexTangents: !!q.attributes.tangent && (fe || L),
            vertexColors: I.vertexColors,
            vertexAlphas: I.vertexColors === !0 && !!q.attributes.color && q.attributes.color.itemSize === 4,
            pointsUvs: X.isPoints === !0 && !!q.attributes.uv && (ze || xe),
            fog: !!G,
            useFog: I.fog === !0,
            fogExp2: !!G && G.isFogExp2,
            flatShading: I.flatShading === !0,
            sizeAttenuation: I.sizeAttenuation === !0,
            logarithmicDepthBuffer: h,
            skinning: X.isSkinnedMesh === !0,
            morphTargets: q.morphAttributes.position !== void 0,
            morphNormals: q.morphAttributes.normal !== void 0,
            morphColors: q.morphAttributes.color !== void 0,
            morphTargetsCount: ce,
            morphTextureStride: be,
            numDirLights: P.directional.length,
            numPointLights: P.point.length,
            numSpotLights: P.spot.length,
            numSpotLightMaps: P.spotLightMap.length,
            numRectAreaLights: P.rectArea.length,
            numHemiLights: P.hemi.length,
            numDirLightShadows: P.directionalShadowMap.length,
            numPointLightShadows: P.pointShadowMap.length,
            numSpotLightShadows: P.spotShadowMap.length,
            numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps,
            numLightProbes: P.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: I.dithering,
            shadowMapEnabled: n.shadowMap.enabled && D.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Kt,
            decodeVideoTexture: ze && I.map.isVideoTexture === !0 && kt.getTransfer(I.map.colorSpace) === $t,
            premultipliedAlpha: I.premultipliedAlpha,
            doubleSided: I.side === lr,
            flipSided: I.side === ri,
            useDepthPacking: I.depthPacking >= 0,
            depthPacking: I.depthPacking || 0,
            index0AttributeName: I.index0AttributeName,
            extensionClipCullDistance: Tt && I.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Tt && I.extensions.multiDraw === !0 || Qe) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: I.customProgramCacheKey()
        };
        return Mn.vertexUv1s = f.has(1),
        Mn.vertexUv2s = f.has(2),
        Mn.vertexUv3s = f.has(3),
        f.clear(),
        Mn
    }
    function v(I) {
        const P = [];
        if (I.shaderID ? P.push(I.shaderID) : (P.push(I.customVertexShaderID),
        P.push(I.customFragmentShaderID)),
        I.defines !== void 0)
            for (const D in I.defines)
                P.push(D),
                P.push(I.defines[D]);
        return I.isRawShaderMaterial === !1 && (M(P, I),
        w(P, I),
        P.push(n.outputColorSpace)),
        P.push(I.customProgramCacheKey),
        P.join()
    }
    function M(I, P) {
        I.push(P.precision),
        I.push(P.outputColorSpace),
        I.push(P.envMapMode),
        I.push(P.envMapCubeUVHeight),
        I.push(P.mapUv),
        I.push(P.alphaMapUv),
        I.push(P.lightMapUv),
        I.push(P.aoMapUv),
        I.push(P.bumpMapUv),
        I.push(P.normalMapUv),
        I.push(P.displacementMapUv),
        I.push(P.emissiveMapUv),
        I.push(P.metalnessMapUv),
        I.push(P.roughnessMapUv),
        I.push(P.anisotropyMapUv),
        I.push(P.clearcoatMapUv),
        I.push(P.clearcoatNormalMapUv),
        I.push(P.clearcoatRoughnessMapUv),
        I.push(P.iridescenceMapUv),
        I.push(P.iridescenceThicknessMapUv),
        I.push(P.sheenColorMapUv),
        I.push(P.sheenRoughnessMapUv),
        I.push(P.specularMapUv),
        I.push(P.specularColorMapUv),
        I.push(P.specularIntensityMapUv),
        I.push(P.transmissionMapUv),
        I.push(P.thicknessMapUv),
        I.push(P.combine),
        I.push(P.fogExp2),
        I.push(P.sizeAttenuation),
        I.push(P.morphTargetsCount),
        I.push(P.morphAttributeCount),
        I.push(P.numDirLights),
        I.push(P.numPointLights),
        I.push(P.numSpotLights),
        I.push(P.numSpotLightMaps),
        I.push(P.numHemiLights),
        I.push(P.numRectAreaLights),
        I.push(P.numDirLightShadows),
        I.push(P.numPointLightShadows),
        I.push(P.numSpotLightShadows),
        I.push(P.numSpotLightShadowsWithMaps),
        I.push(P.numLightProbes),
        I.push(P.shadowMapType),
        I.push(P.toneMapping),
        I.push(P.numClippingPlanes),
        I.push(P.numClipIntersection),
        I.push(P.depthPacking)
    }
    function w(I, P) {
        l.disableAll(),
        P.supportsVertexTextures && l.enable(0),
        P.instancing && l.enable(1),
        P.instancingColor && l.enable(2),
        P.instancingMorph && l.enable(3),
        P.matcap && l.enable(4),
        P.envMap && l.enable(5),
        P.normalMapObjectSpace && l.enable(6),
        P.normalMapTangentSpace && l.enable(7),
        P.clearcoat && l.enable(8),
        P.iridescence && l.enable(9),
        P.alphaTest && l.enable(10),
        P.vertexColors && l.enable(11),
        P.vertexAlphas && l.enable(12),
        P.vertexUv1s && l.enable(13),
        P.vertexUv2s && l.enable(14),
        P.vertexUv3s && l.enable(15),
        P.vertexTangents && l.enable(16),
        P.anisotropy && l.enable(17),
        P.alphaHash && l.enable(18),
        P.batching && l.enable(19),
        P.dispersion && l.enable(20),
        P.batchingColor && l.enable(21),
        I.push(l.mask),
        l.disableAll(),
        P.fog && l.enable(0),
        P.useFog && l.enable(1),
        P.flatShading && l.enable(2),
        P.logarithmicDepthBuffer && l.enable(3),
        P.skinning && l.enable(4),
        P.morphTargets && l.enable(5),
        P.morphNormals && l.enable(6),
        P.morphColors && l.enable(7),
        P.premultipliedAlpha && l.enable(8),
        P.shadowMapEnabled && l.enable(9),
        P.doubleSided && l.enable(10),
        P.flipSided && l.enable(11),
        P.useDepthPacking && l.enable(12),
        P.dithering && l.enable(13),
        P.transmission && l.enable(14),
        P.sheen && l.enable(15),
        P.opaque && l.enable(16),
        P.pointsUvs && l.enable(17),
        P.decodeVideoTexture && l.enable(18),
        P.alphaToCoverage && l.enable(19),
        I.push(l.mask)
    }
    function E(I) {
        const P = x[I.type];
        let D;
        if (P) {
            const W = ar[P];
            D = gx.clone(W.uniforms)
        } else
            D = I.uniforms;
        return D
    }
    function O(I, P) {
        let D;
        for (let W = 0, X = d.length; W < X; W++) {
            const G = d[W];
            if (G.cacheKey === P) {
                D = G,
                ++D.usedTimes;
                break
            }
        }
        return D === void 0 && (D = new jO(n,P,I,s),
        d.push(D)),
        D
    }
    function R(I) {
        if (--I.usedTimes === 0) {
            const P = d.indexOf(I);
            d[P] = d[d.length - 1],
            d.pop(),
            I.destroy()
        }
    }
    function A(I) {
        u.remove(I)
    }
    function F() {
        u.dispose()
    }
    return {
        getParameters: _,
        getProgramCacheKey: v,
        getUniforms: E,
        acquireProgram: O,
        releaseProgram: R,
        releaseShaderCache: A,
        programs: d,
        dispose: F
    }
}
function ZO() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function i(s, o, l) {
        n.get(s)[o] = l
    }
    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}
function KO(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function IS(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function LS() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(h, m, g, x, S, _) {
        let v = n[e];
        return v === void 0 ? (v = {
            id: h.id,
            object: h,
            geometry: m,
            material: g,
            groupOrder: x,
            renderOrder: h.renderOrder,
            z: S,
            group: _
        },
        n[e] = v) : (v.id = h.id,
        v.object = h,
        v.geometry = m,
        v.material = g,
        v.groupOrder = x,
        v.renderOrder = h.renderOrder,
        v.z = S,
        v.group = _),
        e++,
        v
    }
    function l(h, m, g, x, S, _) {
        const v = o(h, m, g, x, S, _);
        g.transmission > 0 ? i.push(v) : g.transparent === !0 ? r.push(v) : t.push(v)
    }
    function u(h, m, g, x, S, _) {
        const v = o(h, m, g, x, S, _);
        g.transmission > 0 ? i.unshift(v) : g.transparent === !0 ? r.unshift(v) : t.unshift(v)
    }
    function f(h, m) {
        t.length > 1 && t.sort(h || KO),
        i.length > 1 && i.sort(m || IS),
        r.length > 1 && r.sort(m || IS)
    }
    function d() {
        for (let h = e, m = n.length; h < m; h++) {
            const g = n[h];
            if (g.id === null)
                break;
            g.id = null,
            g.object = null,
            g.geometry = null,
            g.material = null,
            g.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: l,
        unshift: u,
        finish: d,
        sort: f
    }
}
function JO() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new LS,
        n.set(i, [o])) : r >= s.length ? (o = new LS,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function QO() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new B,
                    color: new Oe
                };
                break;
            case "SpotLight":
                t = {
                    position: new B,
                    direction: new B,
                    color: new Oe,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new B,
                    color: new Oe,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new B,
                    skyColor: new Oe,
                    groundColor: new Oe
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Oe,
                    position: new B,
                    halfWidth: new B,
                    halfHeight: new B
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function eD() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new he
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new he
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new he,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let tD = 0;
function nD(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function iD(n) {
    const e = new QO
      , t = eD()
      , i = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let f = 0; f < 9; f++)
        i.probe.push(new B);
    const r = new B
      , s = new ct
      , o = new ct;
    function l(f) {
        let d = 0
          , h = 0
          , m = 0;
        for (let I = 0; I < 9; I++)
            i.probe[I].set(0, 0, 0);
        let g = 0
          , x = 0
          , S = 0
          , _ = 0
          , v = 0
          , M = 0
          , w = 0
          , E = 0
          , O = 0
          , R = 0
          , A = 0;
        f.sort(nD);
        for (let I = 0, P = f.length; I < P; I++) {
            const D = f[I]
              , W = D.color
              , X = D.intensity
              , G = D.distance
              , q = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
            if (D.isAmbientLight)
                d += W.r * X,
                h += W.g * X,
                m += W.b * X;
            else if (D.isLightProbe) {
                for (let K = 0; K < 9; K++)
                    i.probe[K].addScaledVector(D.sh.coefficients[K], X);
                A++
            } else if (D.isDirectionalLight) {
                const K = e.get(D);
                if (K.color.copy(D.color).multiplyScalar(D.intensity),
                D.castShadow) {
                    const oe = D.shadow
                      , z = t.get(D);
                    z.shadowIntensity = oe.intensity,
                    z.shadowBias = oe.bias,
                    z.shadowNormalBias = oe.normalBias,
                    z.shadowRadius = oe.radius,
                    z.shadowMapSize = oe.mapSize,
                    i.directionalShadow[g] = z,
                    i.directionalShadowMap[g] = q,
                    i.directionalShadowMatrix[g] = D.shadow.matrix,
                    M++
                }
                i.directional[g] = K,
                g++
            } else if (D.isSpotLight) {
                const K = e.get(D);
                K.position.setFromMatrixPosition(D.matrixWorld),
                K.color.copy(W).multiplyScalar(X),
                K.distance = G,
                K.coneCos = Math.cos(D.angle),
                K.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)),
                K.decay = D.decay,
                i.spot[S] = K;
                const oe = D.shadow;
                if (D.map && (i.spotLightMap[O] = D.map,
                O++,
                oe.updateMatrices(D),
                D.castShadow && R++),
                i.spotLightMatrix[S] = oe.matrix,
                D.castShadow) {
                    const z = t.get(D);
                    z.shadowIntensity = oe.intensity,
                    z.shadowBias = oe.bias,
                    z.shadowNormalBias = oe.normalBias,
                    z.shadowRadius = oe.radius,
                    z.shadowMapSize = oe.mapSize,
                    i.spotShadow[S] = z,
                    i.spotShadowMap[S] = q,
                    E++
                }
                S++
            } else if (D.isRectAreaLight) {
                const K = e.get(D);
                K.color.copy(W).multiplyScalar(X),
                K.halfWidth.set(D.width * .5, 0, 0),
                K.halfHeight.set(0, D.height * .5, 0),
                i.rectArea[_] = K,
                _++
            } else if (D.isPointLight) {
                const K = e.get(D);
                if (K.color.copy(D.color).multiplyScalar(D.intensity),
                K.distance = D.distance,
                K.decay = D.decay,
                D.castShadow) {
                    const oe = D.shadow
                      , z = t.get(D);
                    z.shadowIntensity = oe.intensity,
                    z.shadowBias = oe.bias,
                    z.shadowNormalBias = oe.normalBias,
                    z.shadowRadius = oe.radius,
                    z.shadowMapSize = oe.mapSize,
                    z.shadowCameraNear = oe.camera.near,
                    z.shadowCameraFar = oe.camera.far,
                    i.pointShadow[x] = z,
                    i.pointShadowMap[x] = q,
                    i.pointShadowMatrix[x] = D.shadow.matrix,
                    w++
                }
                i.point[x] = K,
                x++
            } else if (D.isHemisphereLight) {
                const K = e.get(D);
                K.skyColor.copy(D.color).multiplyScalar(X),
                K.groundColor.copy(D.groundColor).multiplyScalar(X),
                i.hemi[v] = K,
                v++
            }
        }
        _ > 0 && (n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = De.LTC_FLOAT_1,
        i.rectAreaLTC2 = De.LTC_FLOAT_2) : (i.rectAreaLTC1 = De.LTC_HALF_1,
        i.rectAreaLTC2 = De.LTC_HALF_2)),
        i.ambient[0] = d,
        i.ambient[1] = h,
        i.ambient[2] = m;
        const F = i.hash;
        (F.directionalLength !== g || F.pointLength !== x || F.spotLength !== S || F.rectAreaLength !== _ || F.hemiLength !== v || F.numDirectionalShadows !== M || F.numPointShadows !== w || F.numSpotShadows !== E || F.numSpotMaps !== O || F.numLightProbes !== A) && (i.directional.length = g,
        i.spot.length = S,
        i.rectArea.length = _,
        i.point.length = x,
        i.hemi.length = v,
        i.directionalShadow.length = M,
        i.directionalShadowMap.length = M,
        i.pointShadow.length = w,
        i.pointShadowMap.length = w,
        i.spotShadow.length = E,
        i.spotShadowMap.length = E,
        i.directionalShadowMatrix.length = M,
        i.pointShadowMatrix.length = w,
        i.spotLightMatrix.length = E + O - R,
        i.spotLightMap.length = O,
        i.numSpotLightShadowsWithMaps = R,
        i.numLightProbes = A,
        F.directionalLength = g,
        F.pointLength = x,
        F.spotLength = S,
        F.rectAreaLength = _,
        F.hemiLength = v,
        F.numDirectionalShadows = M,
        F.numPointShadows = w,
        F.numSpotShadows = E,
        F.numSpotMaps = O,
        F.numLightProbes = A,
        i.version = tD++)
    }
    function u(f, d) {
        let h = 0
          , m = 0
          , g = 0
          , x = 0
          , S = 0;
        const _ = d.matrixWorldInverse;
        for (let v = 0, M = f.length; v < M; v++) {
            const w = f[v];
            if (w.isDirectionalLight) {
                const E = i.directional[h];
                E.direction.setFromMatrixPosition(w.matrixWorld),
                r.setFromMatrixPosition(w.target.matrixWorld),
                E.direction.sub(r),
                E.direction.transformDirection(_),
                h++
            } else if (w.isSpotLight) {
                const E = i.spot[g];
                E.position.setFromMatrixPosition(w.matrixWorld),
                E.position.applyMatrix4(_),
                E.direction.setFromMatrixPosition(w.matrixWorld),
                r.setFromMatrixPosition(w.target.matrixWorld),
                E.direction.sub(r),
                E.direction.transformDirection(_),
                g++
            } else if (w.isRectAreaLight) {
                const E = i.rectArea[x];
                E.position.setFromMatrixPosition(w.matrixWorld),
                E.position.applyMatrix4(_),
                o.identity(),
                s.copy(w.matrixWorld),
                s.premultiply(_),
                o.extractRotation(s),
                E.halfWidth.set(w.width * .5, 0, 0),
                E.halfHeight.set(0, w.height * .5, 0),
                E.halfWidth.applyMatrix4(o),
                E.halfHeight.applyMatrix4(o),
                x++
            } else if (w.isPointLight) {
                const E = i.point[m];
                E.position.setFromMatrixPosition(w.matrixWorld),
                E.position.applyMatrix4(_),
                m++
            } else if (w.isHemisphereLight) {
                const E = i.hemi[S];
                E.direction.setFromMatrixPosition(w.matrixWorld),
                E.direction.transformDirection(_),
                S++
            }
        }
    }
    return {
        setup: l,
        setupView: u,
        state: i
    }
}
function NS(n) {
    const e = new iD(n)
      , t = []
      , i = [];
    function r(d) {
        f.camera = d,
        t.length = 0,
        i.length = 0
    }
    function s(d) {
        t.push(d)
    }
    function o(d) {
        i.push(d)
    }
    function l() {
        e.setup(t)
    }
    function u(d) {
        e.setupView(t, d)
    }
    const f = {
        lightsArray: t,
        shadowsArray: i,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: r,
        state: f,
        setupLights: l,
        setupLightsView: u,
        pushLight: s,
        pushShadow: o
    }
}
function rD(n) {
    let e = new WeakMap;
    function t(r, s=0) {
        const o = e.get(r);
        let l;
        return o === void 0 ? (l = new NS(n),
        e.set(r, [l])) : s >= o.length ? (l = new NS(n),
        o.push(l)) : l = o[s],
        l
    }
    function i() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: i
    }
}
class yx extends Fn {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = gb,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Sx extends Fn {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const sD = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , oD = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function aD(n, e, t) {
    let i = new ku;
    const r = new he
      , s = new he
      , o = new Bt
      , l = new yx({
        depthPacking: vb
    })
      , u = new Sx
      , f = {}
      , d = t.maxTextureSize
      , h = {
        [Dr]: ri,
        [ri]: Dr,
        [lr]: lr
    }
      , m = new Yi({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new he
            },
            radius: {
                value: 4
            }
        },
        vertexShader: sD,
        fragmentShader: oD
    })
      , g = m.clone();
    g.defines.HORIZONTAL_PASS = 1;
    const x = new St;
    x.setAttribute("position", new Vt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const S = new Sn(x,m)
      , _ = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Wp;
    let v = this.type;
    this.render = function(R, A, F) {
        if (_.enabled === !1 || _.autoUpdate === !1 && _.needsUpdate === !1 || R.length === 0)
            return;
        const I = n.getRenderTarget()
          , P = n.getActiveCubeFace()
          , D = n.getActiveMipmapLevel()
          , W = n.state;
        W.setBlending(is),
        W.buffers.color.setClear(1, 1, 1, 1),
        W.buffers.depth.setTest(!0),
        W.setScissorTest(!1);
        const X = v !== sr && this.type === sr
          , G = v === sr && this.type !== sr;
        for (let q = 0, K = R.length; q < K; q++) {
            const oe = R[q]
              , z = oe.shadow;
            if (z === void 0) {
                console.warn("THREE.WebGLShadowMap:", oe, "has no shadow.");
                continue
            }
            if (z.autoUpdate === !1 && z.needsUpdate === !1)
                continue;
            r.copy(z.mapSize);
            const ee = z.getFrameExtents();
            if (r.multiply(ee),
            s.copy(z.mapSize),
            (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / ee.x),
            r.x = s.x * ee.x,
            z.mapSize.x = s.x),
            r.y > d && (s.y = Math.floor(d / ee.y),
            r.y = s.y * ee.y,
            z.mapSize.y = s.y)),
            z.map === null || X === !0 || G === !0) {
                const ce = this.type !== sr ? {
                    minFilter: Ln,
                    magFilter: Ln
                } : {};
                z.map !== null && z.map.dispose(),
                z.map = new qi(r.x,r.y,ce),
                z.map.texture.name = oe.name + ".shadowMap",
                z.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(z.map),
            n.clear();
            const Q = z.getViewportCount();
            for (let ce = 0; ce < Q; ce++) {
                const be = z.getViewport(ce);
                o.set(s.x * be.x, s.y * be.y, s.x * be.z, s.y * be.w),
                W.viewport(o),
                z.updateMatrices(oe, ce),
                i = z.getFrustum(),
                E(A, F, z.camera, oe, this.type)
            }
            z.isPointLightShadow !== !0 && this.type === sr && M(z, F),
            z.needsUpdate = !1
        }
        v = this.type,
        _.needsUpdate = !1,
        n.setRenderTarget(I, P, D)
    }
    ;
    function M(R, A) {
        const F = e.update(S);
        m.defines.VSM_SAMPLES !== R.blurSamples && (m.defines.VSM_SAMPLES = R.blurSamples,
        g.defines.VSM_SAMPLES = R.blurSamples,
        m.needsUpdate = !0,
        g.needsUpdate = !0),
        R.mapPass === null && (R.mapPass = new qi(r.x,r.y)),
        m.uniforms.shadow_pass.value = R.map.texture,
        m.uniforms.resolution.value = R.mapSize,
        m.uniforms.radius.value = R.radius,
        n.setRenderTarget(R.mapPass),
        n.clear(),
        n.renderBufferDirect(A, null, F, m, S, null),
        g.uniforms.shadow_pass.value = R.mapPass.texture,
        g.uniforms.resolution.value = R.mapSize,
        g.uniforms.radius.value = R.radius,
        n.setRenderTarget(R.map),
        n.clear(),
        n.renderBufferDirect(A, null, F, g, S, null)
    }
    function w(R, A, F, I) {
        let P = null;
        const D = F.isPointLight === !0 ? R.customDistanceMaterial : R.customDepthMaterial;
        if (D !== void 0)
            P = D;
        else if (P = F.isPointLight === !0 ? u : l,
        n.localClippingEnabled && A.clipShadows === !0 && Array.isArray(A.clippingPlanes) && A.clippingPlanes.length !== 0 || A.displacementMap && A.displacementScale !== 0 || A.alphaMap && A.alphaTest > 0 || A.map && A.alphaTest > 0) {
            const W = P.uuid
              , X = A.uuid;
            let G = f[W];
            G === void 0 && (G = {},
            f[W] = G);
            let q = G[X];
            q === void 0 && (q = P.clone(),
            G[X] = q,
            A.addEventListener("dispose", O)),
            P = q
        }
        if (P.visible = A.visible,
        P.wireframe = A.wireframe,
        I === sr ? P.side = A.shadowSide !== null ? A.shadowSide : A.side : P.side = A.shadowSide !== null ? A.shadowSide : h[A.side],
        P.alphaMap = A.alphaMap,
        P.alphaTest = A.alphaTest,
        P.map = A.map,
        P.clipShadows = A.clipShadows,
        P.clippingPlanes = A.clippingPlanes,
        P.clipIntersection = A.clipIntersection,
        P.displacementMap = A.displacementMap,
        P.displacementScale = A.displacementScale,
        P.displacementBias = A.displacementBias,
        P.wireframeLinewidth = A.wireframeLinewidth,
        P.linewidth = A.linewidth,
        F.isPointLight === !0 && P.isMeshDistanceMaterial === !0) {
            const W = n.properties.get(P);
            W.light = F
        }
        return P
    }
    function E(R, A, F, I, P) {
        if (R.visible === !1)
            return;
        if (R.layers.test(A.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && P === sr) && (!R.frustumCulled || i.intersectsObject(R))) {
            R.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, R.matrixWorld);
            const X = e.update(R)
              , G = R.material;
            if (Array.isArray(G)) {
                const q = X.groups;
                for (let K = 0, oe = q.length; K < oe; K++) {
                    const z = q[K]
                      , ee = G[z.materialIndex];
                    if (ee && ee.visible) {
                        const Q = w(R, ee, I, P);
                        R.onBeforeShadow(n, R, A, F, X, Q, z),
                        n.renderBufferDirect(F, null, X, Q, R, z),
                        R.onAfterShadow(n, R, A, F, X, Q, z)
                    }
                }
            } else if (G.visible) {
                const q = w(R, G, I, P);
                R.onBeforeShadow(n, R, A, F, X, q, null),
                n.renderBufferDirect(F, null, X, q, R, null),
                R.onAfterShadow(n, R, A, F, X, q, null)
            }
        }
        const W = R.children;
        for (let X = 0, G = W.length; X < G; X++)
            E(W[X], A, F, I, P)
    }
    function O(R) {
        R.target.removeEventListener("dispose", O);
        for (const F in f) {
            const I = f[F]
              , P = R.target.uuid;
            P in I && (I[P].dispose(),
            delete I[P])
        }
    }
}
function lD(n) {
    function e() {
        let $ = !1;
        const Ae = new Bt;
        let me = null;
        const xe = new Bt(0,0,0,0);
        return {
            setMask: function(Ne) {
                me !== Ne && !$ && (n.colorMask(Ne, Ne, Ne, Ne),
                me = Ne)
            },
            setLocked: function(Ne) {
                $ = Ne
            },
            setClear: function(Ne, ut, Tt, Kt, Mn) {
                Mn === !0 && (Ne *= Kt,
                ut *= Kt,
                Tt *= Kt),
                Ae.set(Ne, ut, Tt, Kt),
                xe.equals(Ae) === !1 && (n.clearColor(Ne, ut, Tt, Kt),
                xe.copy(Ae))
            },
            reset: function() {
                $ = !1,
                me = null,
                xe.set(-1, 0, 0, 0)
            }
        }
    }
    function t() {
        let $ = !1
          , Ae = null
          , me = null
          , xe = null;
        return {
            setTest: function(Ne) {
                Ne ? Te(n.DEPTH_TEST) : Me(n.DEPTH_TEST)
            },
            setMask: function(Ne) {
                Ae !== Ne && !$ && (n.depthMask(Ne),
                Ae = Ne)
            },
            setFunc: function(Ne) {
                if (me !== Ne) {
                    switch (Ne) {
                    case Kw:
                        n.depthFunc(n.NEVER);
                        break;
                    case Jw:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case Qw:
                        n.depthFunc(n.LESS);
                        break;
                    case Qc:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case eb:
                        n.depthFunc(n.EQUAL);
                        break;
                    case tb:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case nb:
                        n.depthFunc(n.GREATER);
                        break;
                    case ib:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    me = Ne
                }
            },
            setLocked: function(Ne) {
                $ = Ne
            },
            setClear: function(Ne) {
                xe !== Ne && (n.clearDepth(Ne),
                xe = Ne)
            },
            reset: function() {
                $ = !1,
                Ae = null,
                me = null,
                xe = null
            }
        }
    }
    function i() {
        let $ = !1
          , Ae = null
          , me = null
          , xe = null
          , Ne = null
          , ut = null
          , Tt = null
          , Kt = null
          , Mn = null;
        return {
            setTest: function(Rt) {
                $ || (Rt ? Te(n.STENCIL_TEST) : Me(n.STENCIL_TEST))
            },
            setMask: function(Rt) {
                Ae !== Rt && !$ && (n.stencilMask(Rt),
                Ae = Rt)
            },
            setFunc: function(Rt, Li, xi) {
                (me !== Rt || xe !== Li || Ne !== xi) && (n.stencilFunc(Rt, Li, xi),
                me = Rt,
                xe = Li,
                Ne = xi)
            },
            setOp: function(Rt, Li, xi) {
                (ut !== Rt || Tt !== Li || Kt !== xi) && (n.stencilOp(Rt, Li, xi),
                ut = Rt,
                Tt = Li,
                Kt = xi)
            },
            setLocked: function(Rt) {
                $ = Rt
            },
            setClear: function(Rt) {
                Mn !== Rt && (n.clearStencil(Rt),
                Mn = Rt)
            },
            reset: function() {
                $ = !1,
                Ae = null,
                me = null,
                xe = null,
                Ne = null,
                ut = null,
                Tt = null,
                Kt = null,
                Mn = null
            }
        }
    }
    const r = new e
      , s = new t
      , o = new i
      , l = new WeakMap
      , u = new WeakMap;
    let f = {}
      , d = {}
      , h = new WeakMap
      , m = []
      , g = null
      , x = !1
      , S = null
      , _ = null
      , v = null
      , M = null
      , w = null
      , E = null
      , O = null
      , R = new Oe(0,0,0)
      , A = 0
      , F = !1
      , I = null
      , P = null
      , D = null
      , W = null
      , X = null;
    const G = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let q = !1
      , K = 0;
    const oe = n.getParameter(n.VERSION);
    oe.indexOf("WebGL") !== -1 ? (K = parseFloat(/^WebGL (\d)/.exec(oe)[1]),
    q = K >= 1) : oe.indexOf("OpenGL ES") !== -1 && (K = parseFloat(/^OpenGL ES (\d)/.exec(oe)[1]),
    q = K >= 2);
    let z = null
      , ee = {};
    const Q = n.getParameter(n.SCISSOR_BOX)
      , ce = n.getParameter(n.VIEWPORT)
      , be = new Bt().fromArray(Q)
      , Ue = new Bt().fromArray(ce);
    function se($, Ae, me, xe) {
        const Ne = new Uint8Array(4)
          , ut = n.createTexture();
        n.bindTexture($, ut),
        n.texParameteri($, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri($, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let Tt = 0; Tt < me; Tt++)
            $ === n.TEXTURE_3D || $ === n.TEXTURE_2D_ARRAY ? n.texImage3D(Ae, 0, n.RGBA, 1, 1, xe, 0, n.RGBA, n.UNSIGNED_BYTE, Ne) : n.texImage2D(Ae + Tt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Ne);
        return ut
    }
    const ue = {};
    ue[n.TEXTURE_2D] = se(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    ue[n.TEXTURE_CUBE_MAP] = se(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    ue[n.TEXTURE_2D_ARRAY] = se(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    ue[n.TEXTURE_3D] = se(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1),
    r.setClear(0, 0, 0, 1),
    s.setClear(1),
    o.setClear(0),
    Te(n.DEPTH_TEST),
    s.setFunc(Qc),
    Pe(!1),
    fe(P1),
    Te(n.CULL_FACE),
    pe(is);
    function Te($) {
        f[$] !== !0 && (n.enable($),
        f[$] = !0)
    }
    function Me($) {
        f[$] !== !1 && (n.disable($),
        f[$] = !1)
    }
    function Ye($, Ae) {
        return d[$] !== Ae ? (n.bindFramebuffer($, Ae),
        d[$] = Ae,
        $ === n.DRAW_FRAMEBUFFER && (d[n.FRAMEBUFFER] = Ae),
        $ === n.FRAMEBUFFER && (d[n.DRAW_FRAMEBUFFER] = Ae),
        !0) : !1
    }
    function Qe($, Ae) {
        let me = m
          , xe = !1;
        if ($) {
            me = h.get(Ae),
            me === void 0 && (me = [],
            h.set(Ae, me));
            const Ne = $.textures;
            if (me.length !== Ne.length || me[0] !== n.COLOR_ATTACHMENT0) {
                for (let ut = 0, Tt = Ne.length; ut < Tt; ut++)
                    me[ut] = n.COLOR_ATTACHMENT0 + ut;
                me.length = Ne.length,
                xe = !0
            }
        } else
            me[0] !== n.BACK && (me[0] = n.BACK,
            xe = !0);
        xe && n.drawBuffers(me)
    }
    function ze($) {
        return g !== $ ? (n.useProgram($),
        g = $,
        !0) : !1
    }
    const ke = {
        [Ls]: n.FUNC_ADD,
        [Ow]: n.FUNC_SUBTRACT,
        [Dw]: n.FUNC_REVERSE_SUBTRACT
    };
    ke[Uw] = n.MIN,
    ke[Fw] = n.MAX;
    const k = {
        [kw]: n.ZERO,
        [Bw]: n.ONE,
        [zw]: n.SRC_COLOR,
        [Ah]: n.SRC_ALPHA,
        [Xw]: n.SRC_ALPHA_SATURATE,
        [Ww]: n.DST_COLOR,
        [Hw]: n.DST_ALPHA,
        [Vw]: n.ONE_MINUS_SRC_COLOR,
        [Rh]: n.ONE_MINUS_SRC_ALPHA,
        [jw]: n.ONE_MINUS_DST_COLOR,
        [Gw]: n.ONE_MINUS_DST_ALPHA,
        [$w]: n.CONSTANT_COLOR,
        [qw]: n.ONE_MINUS_CONSTANT_COLOR,
        [Yw]: n.CONSTANT_ALPHA,
        [Zw]: n.ONE_MINUS_CONSTANT_ALPHA
    };
    function pe($, Ae, me, xe, Ne, ut, Tt, Kt, Mn, Rt) {
        if ($ === is) {
            x === !0 && (Me(n.BLEND),
            x = !1);
            return
        }
        if (x === !1 && (Te(n.BLEND),
        x = !0),
        $ !== Nw) {
            if ($ !== S || Rt !== F) {
                if ((_ !== Ls || w !== Ls) && (n.blendEquation(n.FUNC_ADD),
                _ = Ls,
                w = Ls),
                Rt)
                    switch ($) {
                    case Oo:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Jc:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case I1:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case L1:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", $);
                        break
                    }
                else
                    switch ($) {
                    case Oo:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Jc:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case I1:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case L1:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", $);
                        break
                    }
                v = null,
                M = null,
                E = null,
                O = null,
                R.set(0, 0, 0),
                A = 0,
                S = $,
                F = Rt
            }
            return
        }
        Ne = Ne || Ae,
        ut = ut || me,
        Tt = Tt || xe,
        (Ae !== _ || Ne !== w) && (n.blendEquationSeparate(ke[Ae], ke[Ne]),
        _ = Ae,
        w = Ne),
        (me !== v || xe !== M || ut !== E || Tt !== O) && (n.blendFuncSeparate(k[me], k[xe], k[ut], k[Tt]),
        v = me,
        M = xe,
        E = ut,
        O = Tt),
        (Kt.equals(R) === !1 || Mn !== A) && (n.blendColor(Kt.r, Kt.g, Kt.b, Mn),
        R.copy(Kt),
        A = Mn),
        S = $,
        F = !1
    }
    function ye($, Ae) {
        $.side === lr ? Me(n.CULL_FACE) : Te(n.CULL_FACE);
        let me = $.side === ri;
        Ae && (me = !me),
        Pe(me),
        $.blending === Oo && $.transparent === !1 ? pe(is) : pe($.blending, $.blendEquation, $.blendSrc, $.blendDst, $.blendEquationAlpha, $.blendSrcAlpha, $.blendDstAlpha, $.blendColor, $.blendAlpha, $.premultipliedAlpha),
        s.setFunc($.depthFunc),
        s.setTest($.depthTest),
        s.setMask($.depthWrite),
        r.setMask($.colorWrite);
        const xe = $.stencilWrite;
        o.setTest(xe),
        xe && (o.setMask($.stencilWriteMask),
        o.setFunc($.stencilFunc, $.stencilRef, $.stencilFuncMask),
        o.setOp($.stencilFail, $.stencilZFail, $.stencilZPass)),
        Le($.polygonOffset, $.polygonOffsetFactor, $.polygonOffsetUnits),
        $.alphaToCoverage === !0 ? Te(n.SAMPLE_ALPHA_TO_COVERAGE) : Me(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function Pe($) {
        I !== $ && ($ ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        I = $)
    }
    function fe($) {
        $ !== Pw ? (Te(n.CULL_FACE),
        $ !== P && ($ === P1 ? n.cullFace(n.BACK) : $ === Iw ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : Me(n.CULL_FACE),
        P = $
    }
    function $e($) {
        $ !== D && (q && n.lineWidth($),
        D = $)
    }
    function Le($, Ae, me) {
        $ ? (Te(n.POLYGON_OFFSET_FILL),
        (W !== Ae || X !== me) && (n.polygonOffset(Ae, me),
        W = Ae,
        X = me)) : Me(n.POLYGON_OFFSET_FILL)
    }
    function Be($) {
        $ ? Te(n.SCISSOR_TEST) : Me(n.SCISSOR_TEST)
    }
    function H($) {
        $ === void 0 && ($ = n.TEXTURE0 + G - 1),
        z !== $ && (n.activeTexture($),
        z = $)
    }
    function L($, Ae, me) {
        me === void 0 && (z === null ? me = n.TEXTURE0 + G - 1 : me = z);
        let xe = ee[me];
        xe === void 0 && (xe = {
            type: void 0,
            texture: void 0
        },
        ee[me] = xe),
        (xe.type !== $ || xe.texture !== Ae) && (z !== me && (n.activeTexture(me),
        z = me),
        n.bindTexture($, Ae || ue[$]),
        xe.type = $,
        xe.texture = Ae)
    }
    function te() {
        const $ = ee[z];
        $ !== void 0 && $.type !== void 0 && (n.bindTexture($.type, null),
        $.type = void 0,
        $.texture = void 0)
    }
    function _e() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function ge() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function ve() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function Ke() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function we() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function He() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function ft() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function Ee() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function We() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function Ct() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch ($) {
            console.error("THREE.WebGLState:", $)
        }
    }
    function dt($) {
        be.equals($) === !1 && (n.scissor($.x, $.y, $.z, $.w),
        be.copy($))
    }
    function je($) {
        Ue.equals($) === !1 && (n.viewport($.x, $.y, $.z, $.w),
        Ue.copy($))
    }
    function pt($, Ae) {
        let me = u.get(Ae);
        me === void 0 && (me = new WeakMap,
        u.set(Ae, me));
        let xe = me.get($);
        xe === void 0 && (xe = n.getUniformBlockIndex(Ae, $.name),
        me.set($, xe))
    }
    function Mt($, Ae) {
        const xe = u.get(Ae).get($);
        l.get(Ae) !== xe && (n.uniformBlockBinding(Ae, xe, $.__bindingPointIndex),
        l.set(Ae, xe))
    }
    function Gt() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.blendColor(0, 0, 0, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        f = {},
        z = null,
        ee = {},
        d = {},
        h = new WeakMap,
        m = [],
        g = null,
        x = !1,
        S = null,
        _ = null,
        v = null,
        M = null,
        w = null,
        E = null,
        O = null,
        R = new Oe(0,0,0),
        A = 0,
        F = !1,
        I = null,
        P = null,
        D = null,
        W = null,
        X = null,
        be.set(0, 0, n.canvas.width, n.canvas.height),
        Ue.set(0, 0, n.canvas.width, n.canvas.height),
        r.reset(),
        s.reset(),
        o.reset()
    }
    return {
        buffers: {
            color: r,
            depth: s,
            stencil: o
        },
        enable: Te,
        disable: Me,
        bindFramebuffer: Ye,
        drawBuffers: Qe,
        useProgram: ze,
        setBlending: pe,
        setMaterial: ye,
        setFlipSided: Pe,
        setCullFace: fe,
        setLineWidth: $e,
        setPolygonOffset: Le,
        setScissorTest: Be,
        activeTexture: H,
        bindTexture: L,
        unbindTexture: te,
        compressedTexImage2D: _e,
        compressedTexImage3D: ge,
        texImage2D: We,
        texImage3D: Ct,
        updateUBOMapping: pt,
        uniformBlockBinding: Mt,
        texStorage2D: ft,
        texStorage3D: Ee,
        texSubImage2D: ve,
        texSubImage3D: Ke,
        compressedTexSubImage2D: we,
        compressedTexSubImage3D: He,
        scissor: dt,
        viewport: je,
        reset: Gt
    }
}
function cD(n, e) {
    const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
    return t > e ? (n.repeat.x = 1,
    n.repeat.y = t / e,
    n.offset.x = 0,
    n.offset.y = (1 - n.repeat.y) / 2) : (n.repeat.x = e / t,
    n.repeat.y = 1,
    n.offset.x = (1 - n.repeat.x) / 2,
    n.offset.y = 0),
    n
}
function uD(n, e) {
    const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
    return t > e ? (n.repeat.x = e / t,
    n.repeat.y = 1,
    n.offset.x = (1 - n.repeat.x) / 2,
    n.offset.y = 0) : (n.repeat.x = 1,
    n.repeat.y = t / e,
    n.offset.x = 0,
    n.offset.y = (1 - n.repeat.y) / 2),
    n
}
function fD(n) {
    return n.repeat.x = 1,
    n.repeat.y = 1,
    n.offset.x = 0,
    n.offset.y = 0,
    n
}
function k1(n, e, t, i) {
    const r = dD(i);
    switch (t) {
    case ix:
        return n * e;
    case sx:
        return n * e;
    case ox:
        return n * e * 2;
    case Yp:
        return n * e / r.components * r.byteLength;
    case Ou:
        return n * e / r.components * r.byteLength;
    case ax:
        return n * e * 2 / r.components * r.byteLength;
    case Zp:
        return n * e * 2 / r.components * r.byteLength;
    case rx:
        return n * e * 3 / r.components * r.byteLength;
    case qn:
        return n * e * 4 / r.components * r.byteLength;
    case Kp:
        return n * e * 4 / r.components * r.byteLength;
    case Ic:
    case Lc:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Nc:
    case Oc:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ih:
    case Nh:
        return Math.max(n, 16) * Math.max(e, 8) / 4;
    case Ph:
    case Lh:
        return Math.max(n, 8) * Math.max(e, 8) / 2;
    case Oh:
    case Dh:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Uh:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Fh:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case kh:
        return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Bh:
        return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case zh:
        return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Vh:
        return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Hh:
        return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Gh:
        return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Wh:
        return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case jh:
        return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Xh:
        return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case $h:
        return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case qh:
        return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Yh:
        return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Zh:
        return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Dc:
    case Kh:
    case Jh:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case lx:
    case Qh:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case ep:
    case tp:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function dD(n) {
    switch (n) {
    case fr:
    case ex:
        return {
            byteLength: 1,
            components: 1
        };
    case dl:
    case tx:
    case Xo:
        return {
            byteLength: 2,
            components: 1
        };
    case $p:
    case qp:
        return {
            byteLength: 2,
            components: 4
        };
    case as:
    case Xp:
    case ii:
        return {
            byteLength: 4,
            components: 1
        };
    case nx:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${n}.`)
}
const hD = {
    contain: cD,
    cover: uD,
    fill: fD,
    getByteLength: k1
};
function pD(n, e, t, i, r, s, o) {
    const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , f = new he
      , d = new WeakMap;
    let h;
    const m = new WeakMap;
    let g = !1;
    try {
        g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function x(H, L) {
        return g ? new OffscreenCanvas(H,L) : fu("canvas")
    }
    function S(H, L, te) {
        let _e = 1;
        const ge = Be(H);
        if ((ge.width > te || ge.height > te) && (_e = te / Math.max(ge.width, ge.height)),
        _e < 1)
            if (typeof HTMLImageElement < "u" && H instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && H instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && H instanceof ImageBitmap || typeof VideoFrame < "u" && H instanceof VideoFrame) {
                const ve = Math.floor(_e * ge.width)
                  , Ke = Math.floor(_e * ge.height);
                h === void 0 && (h = x(ve, Ke));
                const we = L ? x(ve, Ke) : h;
                return we.width = ve,
                we.height = Ke,
                we.getContext("2d").drawImage(H, 0, 0, ve, Ke),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ge.width + "x" + ge.height + ") to (" + ve + "x" + Ke + ")."),
                we
            } else
                return "data"in H && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ge.width + "x" + ge.height + ")."),
                H;
        return H
    }
    function _(H) {
        return H.generateMipmaps && H.minFilter !== Ln && H.minFilter !== ln
    }
    function v(H) {
        n.generateMipmap(H)
    }
    function M(H, L, te, _e, ge=!1) {
        if (H !== null) {
            if (n[H] !== void 0)
                return n[H];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + H + "'")
        }
        let ve = L;
        if (L === n.RED && (te === n.FLOAT && (ve = n.R32F),
        te === n.HALF_FLOAT && (ve = n.R16F),
        te === n.UNSIGNED_BYTE && (ve = n.R8)),
        L === n.RED_INTEGER && (te === n.UNSIGNED_BYTE && (ve = n.R8UI),
        te === n.UNSIGNED_SHORT && (ve = n.R16UI),
        te === n.UNSIGNED_INT && (ve = n.R32UI),
        te === n.BYTE && (ve = n.R8I),
        te === n.SHORT && (ve = n.R16I),
        te === n.INT && (ve = n.R32I)),
        L === n.RG && (te === n.FLOAT && (ve = n.RG32F),
        te === n.HALF_FLOAT && (ve = n.RG16F),
        te === n.UNSIGNED_BYTE && (ve = n.RG8)),
        L === n.RG_INTEGER && (te === n.UNSIGNED_BYTE && (ve = n.RG8UI),
        te === n.UNSIGNED_SHORT && (ve = n.RG16UI),
        te === n.UNSIGNED_INT && (ve = n.RG32UI),
        te === n.BYTE && (ve = n.RG8I),
        te === n.SHORT && (ve = n.RG16I),
        te === n.INT && (ve = n.RG32I)),
        L === n.RGB && te === n.UNSIGNED_INT_5_9_9_9_REV && (ve = n.RGB9_E5),
        L === n.RGBA) {
            const Ke = ge ? ou : kt.getTransfer(_e);
            te === n.FLOAT && (ve = n.RGBA32F),
            te === n.HALF_FLOAT && (ve = n.RGBA16F),
            te === n.UNSIGNED_BYTE && (ve = Ke === $t ? n.SRGB8_ALPHA8 : n.RGBA8),
            te === n.UNSIGNED_SHORT_4_4_4_4 && (ve = n.RGBA4),
            te === n.UNSIGNED_SHORT_5_5_5_1 && (ve = n.RGB5_A1)
        }
        return (ve === n.R16F || ve === n.R32F || ve === n.RG16F || ve === n.RG32F || ve === n.RGBA16F || ve === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        ve
    }
    function w(H, L) {
        let te;
        return H ? L === null || L === as || L === zo ? te = n.DEPTH24_STENCIL8 : L === ii ? te = n.DEPTH32F_STENCIL8 : L === dl && (te = n.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : L === null || L === as || L === zo ? te = n.DEPTH_COMPONENT24 : L === ii ? te = n.DEPTH_COMPONENT32F : L === dl && (te = n.DEPTH_COMPONENT16),
        te
    }
    function E(H, L) {
        return _(H) === !0 || H.isFramebufferTexture && H.minFilter !== Ln && H.minFilter !== ln ? Math.log2(Math.max(L.width, L.height)) + 1 : H.mipmaps !== void 0 && H.mipmaps.length > 0 ? H.mipmaps.length : H.isCompressedTexture && Array.isArray(H.image) ? L.mipmaps.length : 1
    }
    function O(H) {
        const L = H.target;
        L.removeEventListener("dispose", O),
        A(L),
        L.isVideoTexture && d.delete(L)
    }
    function R(H) {
        const L = H.target;
        L.removeEventListener("dispose", R),
        I(L)
    }
    function A(H) {
        const L = i.get(H);
        if (L.__webglInit === void 0)
            return;
        const te = H.source
          , _e = m.get(te);
        if (_e) {
            const ge = _e[L.__cacheKey];
            ge.usedTimes--,
            ge.usedTimes === 0 && F(H),
            Object.keys(_e).length === 0 && m.delete(te)
        }
        i.remove(H)
    }
    function F(H) {
        const L = i.get(H);
        n.deleteTexture(L.__webglTexture);
        const te = H.source
          , _e = m.get(te);
        delete _e[L.__cacheKey],
        o.memory.textures--
    }
    function I(H) {
        const L = i.get(H);
        if (H.depthTexture && H.depthTexture.dispose(),
        H.isWebGLCubeRenderTarget)
            for (let _e = 0; _e < 6; _e++) {
                if (Array.isArray(L.__webglFramebuffer[_e]))
                    for (let ge = 0; ge < L.__webglFramebuffer[_e].length; ge++)
                        n.deleteFramebuffer(L.__webglFramebuffer[_e][ge]);
                else
                    n.deleteFramebuffer(L.__webglFramebuffer[_e]);
                L.__webglDepthbuffer && n.deleteRenderbuffer(L.__webglDepthbuffer[_e])
            }
        else {
            if (Array.isArray(L.__webglFramebuffer))
                for (let _e = 0; _e < L.__webglFramebuffer.length; _e++)
                    n.deleteFramebuffer(L.__webglFramebuffer[_e]);
            else
                n.deleteFramebuffer(L.__webglFramebuffer);
            if (L.__webglDepthbuffer && n.deleteRenderbuffer(L.__webglDepthbuffer),
            L.__webglMultisampledFramebuffer && n.deleteFramebuffer(L.__webglMultisampledFramebuffer),
            L.__webglColorRenderbuffer)
                for (let _e = 0; _e < L.__webglColorRenderbuffer.length; _e++)
                    L.__webglColorRenderbuffer[_e] && n.deleteRenderbuffer(L.__webglColorRenderbuffer[_e]);
            L.__webglDepthRenderbuffer && n.deleteRenderbuffer(L.__webglDepthRenderbuffer)
        }
        const te = H.textures;
        for (let _e = 0, ge = te.length; _e < ge; _e++) {
            const ve = i.get(te[_e]);
            ve.__webglTexture && (n.deleteTexture(ve.__webglTexture),
            o.memory.textures--),
            i.remove(te[_e])
        }
        i.remove(H)
    }
    let P = 0;
    function D() {
        P = 0
    }
    function W() {
        const H = P;
        return H >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + H + " texture units while this GPU supports only " + r.maxTextures),
        P += 1,
        H
    }
    function X(H) {
        const L = [];
        return L.push(H.wrapS),
        L.push(H.wrapT),
        L.push(H.wrapR || 0),
        L.push(H.magFilter),
        L.push(H.minFilter),
        L.push(H.anisotropy),
        L.push(H.internalFormat),
        L.push(H.format),
        L.push(H.type),
        L.push(H.generateMipmaps),
        L.push(H.premultiplyAlpha),
        L.push(H.flipY),
        L.push(H.unpackAlignment),
        L.push(H.colorSpace),
        L.join()
    }
    function G(H, L) {
        const te = i.get(H);
        if (H.isVideoTexture && $e(H),
        H.isRenderTargetTexture === !1 && H.version > 0 && te.__version !== H.version) {
            const _e = H.image;
            if (_e === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (_e.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Ue(te, H, L);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, te.__webglTexture, n.TEXTURE0 + L)
    }
    function q(H, L) {
        const te = i.get(H);
        if (H.version > 0 && te.__version !== H.version) {
            Ue(te, H, L);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, te.__webglTexture, n.TEXTURE0 + L)
    }
    function K(H, L) {
        const te = i.get(H);
        if (H.version > 0 && te.__version !== H.version) {
            Ue(te, H, L);
            return
        }
        t.bindTexture(n.TEXTURE_3D, te.__webglTexture, n.TEXTURE0 + L)
    }
    function oe(H, L) {
        const te = i.get(H);
        if (H.version > 0 && te.__version !== H.version) {
            se(te, H, L);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, te.__webglTexture, n.TEXTURE0 + L)
    }
    const z = {
        [nu]: n.REPEAT,
        [Xi]: n.CLAMP_TO_EDGE,
        [iu]: n.MIRRORED_REPEAT
    }
      , ee = {
        [Ln]: n.NEAREST,
        [Qv]: n.NEAREST_MIPMAP_NEAREST,
        [ja]: n.NEAREST_MIPMAP_LINEAR,
        [ln]: n.LINEAR,
        [Pc]: n.LINEAR_MIPMAP_NEAREST,
        [Cr]: n.LINEAR_MIPMAP_LINEAR
    }
      , Q = {
        [_b]: n.NEVER,
        [Eb]: n.ALWAYS,
        [yb]: n.LESS,
        [ux]: n.LEQUAL,
        [Sb]: n.EQUAL,
        [bb]: n.GEQUAL,
        [Mb]: n.GREATER,
        [wb]: n.NOTEQUAL
    };
    function ce(H, L) {
        if (L.type === ii && e.has("OES_texture_float_linear") === !1 && (L.magFilter === ln || L.magFilter === Pc || L.magFilter === ja || L.magFilter === Cr || L.minFilter === ln || L.minFilter === Pc || L.minFilter === ja || L.minFilter === Cr) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        n.texParameteri(H, n.TEXTURE_WRAP_S, z[L.wrapS]),
        n.texParameteri(H, n.TEXTURE_WRAP_T, z[L.wrapT]),
        (H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY) && n.texParameteri(H, n.TEXTURE_WRAP_R, z[L.wrapR]),
        n.texParameteri(H, n.TEXTURE_MAG_FILTER, ee[L.magFilter]),
        n.texParameteri(H, n.TEXTURE_MIN_FILTER, ee[L.minFilter]),
        L.compareFunction && (n.texParameteri(H, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(H, n.TEXTURE_COMPARE_FUNC, Q[L.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (L.magFilter === Ln || L.minFilter !== ja && L.minFilter !== Cr || L.type === ii && e.has("OES_texture_float_linear") === !1)
                return;
            if (L.anisotropy > 1 || i.get(L).__currentAnisotropy) {
                const te = e.get("EXT_texture_filter_anisotropic");
                n.texParameterf(H, te.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(L.anisotropy, r.getMaxAnisotropy())),
                i.get(L).__currentAnisotropy = L.anisotropy
            }
        }
    }
    function be(H, L) {
        let te = !1;
        H.__webglInit === void 0 && (H.__webglInit = !0,
        L.addEventListener("dispose", O));
        const _e = L.source;
        let ge = m.get(_e);
        ge === void 0 && (ge = {},
        m.set(_e, ge));
        const ve = X(L);
        if (ve !== H.__cacheKey) {
            ge[ve] === void 0 && (ge[ve] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            te = !0),
            ge[ve].usedTimes++;
            const Ke = ge[H.__cacheKey];
            Ke !== void 0 && (ge[H.__cacheKey].usedTimes--,
            Ke.usedTimes === 0 && F(L)),
            H.__cacheKey = ve,
            H.__webglTexture = ge[ve].texture
        }
        return te
    }
    function Ue(H, L, te) {
        let _e = n.TEXTURE_2D;
        (L.isDataArrayTexture || L.isCompressedArrayTexture) && (_e = n.TEXTURE_2D_ARRAY),
        L.isData3DTexture && (_e = n.TEXTURE_3D);
        const ge = be(H, L)
          , ve = L.source;
        t.bindTexture(_e, H.__webglTexture, n.TEXTURE0 + te);
        const Ke = i.get(ve);
        if (ve.version !== Ke.__version || ge === !0) {
            t.activeTexture(n.TEXTURE0 + te);
            const we = kt.getPrimaries(kt.workingColorSpace)
              , He = L.colorSpace === es ? null : kt.getPrimaries(L.colorSpace)
              , ft = L.colorSpace === es || we === He ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ft);
            let Ee = S(L.image, !1, r.maxTextureSize);
            Ee = Le(L, Ee);
            const We = s.convert(L.format, L.colorSpace)
              , Ct = s.convert(L.type);
            let dt = M(L.internalFormat, We, Ct, L.colorSpace, L.isVideoTexture);
            ce(_e, L);
            let je;
            const pt = L.mipmaps
              , Mt = L.isVideoTexture !== !0
              , Gt = Ke.__version === void 0 || ge === !0
              , $ = ve.dataReady
              , Ae = E(L, Ee);
            if (L.isDepthTexture)
                dt = w(L.format === Vo, L.type),
                Gt && (Mt ? t.texStorage2D(n.TEXTURE_2D, 1, dt, Ee.width, Ee.height) : t.texImage2D(n.TEXTURE_2D, 0, dt, Ee.width, Ee.height, 0, We, Ct, null));
            else if (L.isDataTexture)
                if (pt.length > 0) {
                    Mt && Gt && t.texStorage2D(n.TEXTURE_2D, Ae, dt, pt[0].width, pt[0].height);
                    for (let me = 0, xe = pt.length; me < xe; me++)
                        je = pt[me],
                        Mt ? $ && t.texSubImage2D(n.TEXTURE_2D, me, 0, 0, je.width, je.height, We, Ct, je.data) : t.texImage2D(n.TEXTURE_2D, me, dt, je.width, je.height, 0, We, Ct, je.data);
                    L.generateMipmaps = !1
                } else
                    Mt ? (Gt && t.texStorage2D(n.TEXTURE_2D, Ae, dt, Ee.width, Ee.height),
                    $ && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ee.width, Ee.height, We, Ct, Ee.data)) : t.texImage2D(n.TEXTURE_2D, 0, dt, Ee.width, Ee.height, 0, We, Ct, Ee.data);
            else if (L.isCompressedTexture)
                if (L.isCompressedArrayTexture) {
                    Mt && Gt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ae, dt, pt[0].width, pt[0].height, Ee.depth);
                    for (let me = 0, xe = pt.length; me < xe; me++)
                        if (je = pt[me],
                        L.format !== qn)
                            if (We !== null)
                                if (Mt) {
                                    if ($)
                                        if (L.layerUpdates.size > 0) {
                                            const Ne = k1(je.width, je.height, L.format, L.type);
                                            for (const ut of L.layerUpdates) {
                                                const Tt = je.data.subarray(ut * Ne / je.data.BYTES_PER_ELEMENT, (ut + 1) * Ne / je.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, me, 0, 0, ut, je.width, je.height, 1, We, Tt, 0, 0)
                                            }
                                            L.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, me, 0, 0, 0, je.width, je.height, Ee.depth, We, je.data, 0, 0)
                                } else
                                    t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, me, dt, je.width, je.height, Ee.depth, 0, je.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            Mt ? $ && t.texSubImage3D(n.TEXTURE_2D_ARRAY, me, 0, 0, 0, je.width, je.height, Ee.depth, We, Ct, je.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, me, dt, je.width, je.height, Ee.depth, 0, We, Ct, je.data)
                } else {
                    Mt && Gt && t.texStorage2D(n.TEXTURE_2D, Ae, dt, pt[0].width, pt[0].height);
                    for (let me = 0, xe = pt.length; me < xe; me++)
                        je = pt[me],
                        L.format !== qn ? We !== null ? Mt ? $ && t.compressedTexSubImage2D(n.TEXTURE_2D, me, 0, 0, je.width, je.height, We, je.data) : t.compressedTexImage2D(n.TEXTURE_2D, me, dt, je.width, je.height, 0, je.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Mt ? $ && t.texSubImage2D(n.TEXTURE_2D, me, 0, 0, je.width, je.height, We, Ct, je.data) : t.texImage2D(n.TEXTURE_2D, me, dt, je.width, je.height, 0, We, Ct, je.data)
                }
            else if (L.isDataArrayTexture)
                if (Mt) {
                    if (Gt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ae, dt, Ee.width, Ee.height, Ee.depth),
                    $)
                        if (L.layerUpdates.size > 0) {
                            const me = k1(Ee.width, Ee.height, L.format, L.type);
                            for (const xe of L.layerUpdates) {
                                const Ne = Ee.data.subarray(xe * me / Ee.data.BYTES_PER_ELEMENT, (xe + 1) * me / Ee.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, xe, Ee.width, Ee.height, 1, We, Ct, Ne)
                            }
                            L.clearLayerUpdates()
                        } else
                            t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ee.width, Ee.height, Ee.depth, We, Ct, Ee.data)
                } else
                    t.texImage3D(n.TEXTURE_2D_ARRAY, 0, dt, Ee.width, Ee.height, Ee.depth, 0, We, Ct, Ee.data);
            else if (L.isData3DTexture)
                Mt ? (Gt && t.texStorage3D(n.TEXTURE_3D, Ae, dt, Ee.width, Ee.height, Ee.depth),
                $ && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Ee.width, Ee.height, Ee.depth, We, Ct, Ee.data)) : t.texImage3D(n.TEXTURE_3D, 0, dt, Ee.width, Ee.height, Ee.depth, 0, We, Ct, Ee.data);
            else if (L.isFramebufferTexture) {
                if (Gt)
                    if (Mt)
                        t.texStorage2D(n.TEXTURE_2D, Ae, dt, Ee.width, Ee.height);
                    else {
                        let me = Ee.width
                          , xe = Ee.height;
                        for (let Ne = 0; Ne < Ae; Ne++)
                            t.texImage2D(n.TEXTURE_2D, Ne, dt, me, xe, 0, We, Ct, null),
                            me >>= 1,
                            xe >>= 1
                    }
            } else if (pt.length > 0) {
                if (Mt && Gt) {
                    const me = Be(pt[0]);
                    t.texStorage2D(n.TEXTURE_2D, Ae, dt, me.width, me.height)
                }
                for (let me = 0, xe = pt.length; me < xe; me++)
                    je = pt[me],
                    Mt ? $ && t.texSubImage2D(n.TEXTURE_2D, me, 0, 0, We, Ct, je) : t.texImage2D(n.TEXTURE_2D, me, dt, We, Ct, je);
                L.generateMipmaps = !1
            } else if (Mt) {
                if (Gt) {
                    const me = Be(Ee);
                    t.texStorage2D(n.TEXTURE_2D, Ae, dt, me.width, me.height)
                }
                $ && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, We, Ct, Ee)
            } else
                t.texImage2D(n.TEXTURE_2D, 0, dt, We, Ct, Ee);
            _(L) && v(_e),
            Ke.__version = ve.version,
            L.onUpdate && L.onUpdate(L)
        }
        H.__version = L.version
    }
    function se(H, L, te) {
        if (L.image.length !== 6)
            return;
        const _e = be(H, L)
          , ge = L.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, H.__webglTexture, n.TEXTURE0 + te);
        const ve = i.get(ge);
        if (ge.version !== ve.__version || _e === !0) {
            t.activeTexture(n.TEXTURE0 + te);
            const Ke = kt.getPrimaries(kt.workingColorSpace)
              , we = L.colorSpace === es ? null : kt.getPrimaries(L.colorSpace)
              , He = L.colorSpace === es || Ke === we ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, He);
            const ft = L.isCompressedTexture || L.image[0].isCompressedTexture
              , Ee = L.image[0] && L.image[0].isDataTexture
              , We = [];
            for (let xe = 0; xe < 6; xe++)
                !ft && !Ee ? We[xe] = S(L.image[xe], !0, r.maxCubemapSize) : We[xe] = Ee ? L.image[xe].image : L.image[xe],
                We[xe] = Le(L, We[xe]);
            const Ct = We[0]
              , dt = s.convert(L.format, L.colorSpace)
              , je = s.convert(L.type)
              , pt = M(L.internalFormat, dt, je, L.colorSpace)
              , Mt = L.isVideoTexture !== !0
              , Gt = ve.__version === void 0 || _e === !0
              , $ = ge.dataReady;
            let Ae = E(L, Ct);
            ce(n.TEXTURE_CUBE_MAP, L);
            let me;
            if (ft) {
                Mt && Gt && t.texStorage2D(n.TEXTURE_CUBE_MAP, Ae, pt, Ct.width, Ct.height);
                for (let xe = 0; xe < 6; xe++) {
                    me = We[xe].mipmaps;
                    for (let Ne = 0; Ne < me.length; Ne++) {
                        const ut = me[Ne];
                        L.format !== qn ? dt !== null ? Mt ? $ && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne, 0, 0, ut.width, ut.height, dt, ut.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne, pt, ut.width, ut.height, 0, ut.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Mt ? $ && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne, 0, 0, ut.width, ut.height, dt, je, ut.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne, pt, ut.width, ut.height, 0, dt, je, ut.data)
                    }
                }
            } else {
                if (me = L.mipmaps,
                Mt && Gt) {
                    me.length > 0 && Ae++;
                    const xe = Be(We[0]);
                    t.texStorage2D(n.TEXTURE_CUBE_MAP, Ae, pt, xe.width, xe.height)
                }
                for (let xe = 0; xe < 6; xe++)
                    if (Ee) {
                        Mt ? $ && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, 0, 0, We[xe].width, We[xe].height, dt, je, We[xe].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, pt, We[xe].width, We[xe].height, 0, dt, je, We[xe].data);
                        for (let Ne = 0; Ne < me.length; Ne++) {
                            const Tt = me[Ne].image[xe].image;
                            Mt ? $ && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne + 1, 0, 0, Tt.width, Tt.height, dt, je, Tt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne + 1, pt, Tt.width, Tt.height, 0, dt, je, Tt.data)
                        }
                    } else {
                        Mt ? $ && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, 0, 0, dt, je, We[xe]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, pt, dt, je, We[xe]);
                        for (let Ne = 0; Ne < me.length; Ne++) {
                            const ut = me[Ne];
                            Mt ? $ && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne + 1, 0, 0, dt, je, ut.image[xe]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ne + 1, pt, dt, je, ut.image[xe])
                        }
                    }
            }
            _(L) && v(n.TEXTURE_CUBE_MAP),
            ve.__version = ge.version,
            L.onUpdate && L.onUpdate(L)
        }
        H.__version = L.version
    }
    function ue(H, L, te, _e, ge, ve) {
        const Ke = s.convert(te.format, te.colorSpace)
          , we = s.convert(te.type)
          , He = M(te.internalFormat, Ke, we, te.colorSpace);
        if (!i.get(L).__hasExternalTextures) {
            const Ee = Math.max(1, L.width >> ve)
              , We = Math.max(1, L.height >> ve);
            ge === n.TEXTURE_3D || ge === n.TEXTURE_2D_ARRAY ? t.texImage3D(ge, ve, He, Ee, We, L.depth, 0, Ke, we, null) : t.texImage2D(ge, ve, He, Ee, We, 0, Ke, we, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, H),
        fe(L) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, _e, ge, i.get(te).__webglTexture, 0, Pe(L)) : (ge === n.TEXTURE_2D || ge >= n.TEXTURE_CUBE_MAP_POSITIVE_X && ge <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, _e, ge, i.get(te).__webglTexture, ve),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function Te(H, L, te) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, H),
        L.depthBuffer) {
            const _e = L.depthTexture
              , ge = _e && _e.isDepthTexture ? _e.type : null
              , ve = w(L.stencilBuffer, ge)
              , Ke = L.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , we = Pe(L);
            fe(L) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, we, ve, L.width, L.height) : te ? n.renderbufferStorageMultisample(n.RENDERBUFFER, we, ve, L.width, L.height) : n.renderbufferStorage(n.RENDERBUFFER, ve, L.width, L.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, Ke, n.RENDERBUFFER, H)
        } else {
            const _e = L.textures;
            for (let ge = 0; ge < _e.length; ge++) {
                const ve = _e[ge]
                  , Ke = s.convert(ve.format, ve.colorSpace)
                  , we = s.convert(ve.type)
                  , He = M(ve.internalFormat, Ke, we, ve.colorSpace)
                  , ft = Pe(L);
                te && fe(L) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, ft, He, L.width, L.height) : fe(L) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, ft, He, L.width, L.height) : n.renderbufferStorage(n.RENDERBUFFER, He, L.width, L.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function Me(H, L) {
        if (L && L.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, H),
        !(L.depthTexture && L.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(L.depthTexture).__webglTexture || L.depthTexture.image.width !== L.width || L.depthTexture.image.height !== L.height) && (L.depthTexture.image.width = L.width,
        L.depthTexture.image.height = L.height,
        L.depthTexture.needsUpdate = !0),
        G(L.depthTexture, 0);
        const _e = i.get(L.depthTexture).__webglTexture
          , ge = Pe(L);
        if (L.depthTexture.format === Do)
            fe(L) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, _e, 0, ge) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, _e, 0);
        else if (L.depthTexture.format === Vo)
            fe(L) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, _e, 0, ge) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, _e, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Ye(H) {
        const L = i.get(H)
          , te = H.isWebGLCubeRenderTarget === !0;
        if (H.depthTexture && !L.__autoAllocateDepthBuffer) {
            if (te)
                throw new Error("target.depthTexture not supported in Cube render targets");
            Me(L.__webglFramebuffer, H)
        } else if (te) {
            L.__webglDepthbuffer = [];
            for (let _e = 0; _e < 6; _e++)
                t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer[_e]),
                L.__webglDepthbuffer[_e] = n.createRenderbuffer(),
                Te(L.__webglDepthbuffer[_e], H, !1)
        } else
            t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer),
            L.__webglDepthbuffer = n.createRenderbuffer(),
            Te(L.__webglDepthbuffer, H, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function Qe(H, L, te) {
        const _e = i.get(H);
        L !== void 0 && ue(_e.__webglFramebuffer, H, H.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
        te !== void 0 && Ye(H)
    }
    function ze(H) {
        const L = H.texture
          , te = i.get(H)
          , _e = i.get(L);
        H.addEventListener("dispose", R);
        const ge = H.textures
          , ve = H.isWebGLCubeRenderTarget === !0
          , Ke = ge.length > 1;
        if (Ke || (_e.__webglTexture === void 0 && (_e.__webglTexture = n.createTexture()),
        _e.__version = L.version,
        o.memory.textures++),
        ve) {
            te.__webglFramebuffer = [];
            for (let we = 0; we < 6; we++)
                if (L.mipmaps && L.mipmaps.length > 0) {
                    te.__webglFramebuffer[we] = [];
                    for (let He = 0; He < L.mipmaps.length; He++)
                        te.__webglFramebuffer[we][He] = n.createFramebuffer()
                } else
                    te.__webglFramebuffer[we] = n.createFramebuffer()
        } else {
            if (L.mipmaps && L.mipmaps.length > 0) {
                te.__webglFramebuffer = [];
                for (let we = 0; we < L.mipmaps.length; we++)
                    te.__webglFramebuffer[we] = n.createFramebuffer()
            } else
                te.__webglFramebuffer = n.createFramebuffer();
            if (Ke)
                for (let we = 0, He = ge.length; we < He; we++) {
                    const ft = i.get(ge[we]);
                    ft.__webglTexture === void 0 && (ft.__webglTexture = n.createTexture(),
                    o.memory.textures++)
                }
            if (H.samples > 0 && fe(H) === !1) {
                te.__webglMultisampledFramebuffer = n.createFramebuffer(),
                te.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, te.__webglMultisampledFramebuffer);
                for (let we = 0; we < ge.length; we++) {
                    const He = ge[we];
                    te.__webglColorRenderbuffer[we] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, te.__webglColorRenderbuffer[we]);
                    const ft = s.convert(He.format, He.colorSpace)
                      , Ee = s.convert(He.type)
                      , We = M(He.internalFormat, ft, Ee, He.colorSpace, H.isXRRenderTarget === !0)
                      , Ct = Pe(H);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, Ct, We, H.width, H.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + we, n.RENDERBUFFER, te.__webglColorRenderbuffer[we])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                H.depthBuffer && (te.__webglDepthRenderbuffer = n.createRenderbuffer(),
                Te(te.__webglDepthRenderbuffer, H, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (ve) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, _e.__webglTexture),
            ce(n.TEXTURE_CUBE_MAP, L);
            for (let we = 0; we < 6; we++)
                if (L.mipmaps && L.mipmaps.length > 0)
                    for (let He = 0; He < L.mipmaps.length; He++)
                        ue(te.__webglFramebuffer[we][He], H, L, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + we, He);
                else
                    ue(te.__webglFramebuffer[we], H, L, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + we, 0);
            _(L) && v(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (Ke) {
            for (let we = 0, He = ge.length; we < He; we++) {
                const ft = ge[we]
                  , Ee = i.get(ft);
                t.bindTexture(n.TEXTURE_2D, Ee.__webglTexture),
                ce(n.TEXTURE_2D, ft),
                ue(te.__webglFramebuffer, H, ft, n.COLOR_ATTACHMENT0 + we, n.TEXTURE_2D, 0),
                _(ft) && v(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let we = n.TEXTURE_2D;
            if ((H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) && (we = H.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
            t.bindTexture(we, _e.__webglTexture),
            ce(we, L),
            L.mipmaps && L.mipmaps.length > 0)
                for (let He = 0; He < L.mipmaps.length; He++)
                    ue(te.__webglFramebuffer[He], H, L, n.COLOR_ATTACHMENT0, we, He);
            else
                ue(te.__webglFramebuffer, H, L, n.COLOR_ATTACHMENT0, we, 0);
            _(L) && v(we),
            t.unbindTexture()
        }
        H.depthBuffer && Ye(H)
    }
    function ke(H) {
        const L = H.textures;
        for (let te = 0, _e = L.length; te < _e; te++) {
            const ge = L[te];
            if (_(ge)) {
                const ve = H.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D
                  , Ke = i.get(ge).__webglTexture;
                t.bindTexture(ve, Ke),
                v(ve),
                t.unbindTexture()
            }
        }
    }
    const k = []
      , pe = [];
    function ye(H) {
        if (H.samples > 0) {
            if (fe(H) === !1) {
                const L = H.textures
                  , te = H.width
                  , _e = H.height;
                let ge = n.COLOR_BUFFER_BIT;
                const ve = H.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
                  , Ke = i.get(H)
                  , we = L.length > 1;
                if (we)
                    for (let He = 0; He < L.length; He++)
                        t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.RENDERBUFFER, null),
                        t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.TEXTURE_2D, null, 0);
                t.bindFramebuffer(n.READ_FRAMEBUFFER, Ke.__webglMultisampledFramebuffer),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ke.__webglFramebuffer);
                for (let He = 0; He < L.length; He++) {
                    if (H.resolveDepthBuffer && (H.depthBuffer && (ge |= n.DEPTH_BUFFER_BIT),
                    H.stencilBuffer && H.resolveStencilBuffer && (ge |= n.STENCIL_BUFFER_BIT)),
                    we) {
                        n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Ke.__webglColorRenderbuffer[He]);
                        const ft = i.get(L[He]).__webglTexture;
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, ft, 0)
                    }
                    n.blitFramebuffer(0, 0, te, _e, 0, 0, te, _e, ge, n.NEAREST),
                    u === !0 && (k.length = 0,
                    pe.length = 0,
                    k.push(n.COLOR_ATTACHMENT0 + He),
                    H.depthBuffer && H.resolveDepthBuffer === !1 && (k.push(ve),
                    pe.push(ve),
                    n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, pe)),
                    n.invalidateFramebuffer(n.READ_FRAMEBUFFER, k))
                }
                if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                we)
                    for (let He = 0; He < L.length; He++) {
                        t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.RENDERBUFFER, Ke.__webglColorRenderbuffer[He]);
                        const ft = i.get(L[He]).__webglTexture;
                        t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.TEXTURE_2D, ft, 0)
                    }
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ke.__webglMultisampledFramebuffer)
            } else if (H.depthBuffer && H.resolveDepthBuffer === !1 && u) {
                const L = H.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [L])
            }
        }
    }
    function Pe(H) {
        return Math.min(r.maxSamples, H.samples)
    }
    function fe(H) {
        const L = i.get(H);
        return H.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && L.__useRenderToTexture !== !1
    }
    function $e(H) {
        const L = o.render.frame;
        d.get(H) !== L && (d.set(H, L),
        H.update())
    }
    function Le(H, L) {
        const te = H.colorSpace
          , _e = H.format
          , ge = H.type;
        return H.isCompressedTexture === !0 || H.isVideoTexture === !0 || te !== us && te !== es && (kt.getTransfer(te) === $t ? (_e !== qn || ge !== fr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", te)),
        L
    }
    function Be(H) {
        return typeof HTMLImageElement < "u" && H instanceof HTMLImageElement ? (f.width = H.naturalWidth || H.width,
        f.height = H.naturalHeight || H.height) : typeof VideoFrame < "u" && H instanceof VideoFrame ? (f.width = H.displayWidth,
        f.height = H.displayHeight) : (f.width = H.width,
        f.height = H.height),
        f
    }
    this.allocateTextureUnit = W,
    this.resetTextureUnits = D,
    this.setTexture2D = G,
    this.setTexture2DArray = q,
    this.setTexture3D = K,
    this.setTextureCube = oe,
    this.rebindTextures = Qe,
    this.setupRenderTarget = ze,
    this.updateRenderTargetMipmap = ke,
    this.updateMultisampleRenderTarget = ye,
    this.setupDepthRenderbuffer = Ye,
    this.setupFrameBufferTexture = ue,
    this.useMultisampledRTT = fe
}
function kb(n, e) {
    function t(i, r=es) {
        let s;
        const o = kt.getTransfer(r);
        if (i === fr)
            return n.UNSIGNED_BYTE;
        if (i === $p)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (i === qp)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (i === nx)
            return n.UNSIGNED_INT_5_9_9_9_REV;
        if (i === ex)
            return n.BYTE;
        if (i === tx)
            return n.SHORT;
        if (i === dl)
            return n.UNSIGNED_SHORT;
        if (i === Xp)
            return n.INT;
        if (i === as)
            return n.UNSIGNED_INT;
        if (i === ii)
            return n.FLOAT;
        if (i === Xo)
            return n.HALF_FLOAT;
        if (i === ix)
            return n.ALPHA;
        if (i === rx)
            return n.RGB;
        if (i === qn)
            return n.RGBA;
        if (i === sx)
            return n.LUMINANCE;
        if (i === ox)
            return n.LUMINANCE_ALPHA;
        if (i === Do)
            return n.DEPTH_COMPONENT;
        if (i === Vo)
            return n.DEPTH_STENCIL;
        if (i === Yp)
            return n.RED;
        if (i === Ou)
            return n.RED_INTEGER;
        if (i === ax)
            return n.RG;
        if (i === Zp)
            return n.RG_INTEGER;
        if (i === Kp)
            return n.RGBA_INTEGER;
        if (i === Ic || i === Lc || i === Nc || i === Oc)
            if (o === $t)
                if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                s !== null) {
                    if (i === Ic)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (i === Lc)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (i === Nc)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (i === Oc)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"),
            s !== null) {
                if (i === Ic)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (i === Lc)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (i === Nc)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (i === Oc)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (i === Ph || i === Ih || i === Lh || i === Nh)
            if (s = e.get("WEBGL_compressed_texture_pvrtc"),
            s !== null) {
                if (i === Ph)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (i === Ih)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (i === Lh)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (i === Nh)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (i === Oh || i === Dh || i === Uh)
            if (s = e.get("WEBGL_compressed_texture_etc"),
            s !== null) {
                if (i === Oh || i === Dh)
                    return o === $t ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (i === Uh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (i === Fh || i === kh || i === Bh || i === zh || i === Vh || i === Hh || i === Gh || i === Wh || i === jh || i === Xh || i === $h || i === qh || i === Yh || i === Zh)
            if (s = e.get("WEBGL_compressed_texture_astc"),
            s !== null) {
                if (i === Fh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (i === kh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (i === Bh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (i === zh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (i === Vh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (i === Hh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (i === Gh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (i === Wh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (i === jh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (i === Xh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (i === $h)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (i === qh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (i === Yh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (i === Zh)
                    return o === $t ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (i === Dc || i === Kh || i === Jh)
            if (s = e.get("EXT_texture_compression_bptc"),
            s !== null) {
                if (i === Dc)
                    return o === $t ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (i === Kh)
                    return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (i === Jh)
                    return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (i === lx || i === Qh || i === ep || i === tp)
            if (s = e.get("EXT_texture_compression_rgtc"),
            s !== null) {
                if (i === Dc)
                    return s.COMPRESSED_RED_RGTC1_EXT;
                if (i === Qh)
                    return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (i === ep)
                    return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (i === tp)
                    return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return i === zo ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null
    }
    return {
        convert: t
    }
}
class Bb extends yn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class qa extends It {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const mD = {
    type: "move"
};
class Rg {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new qa,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new qa,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new B,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new B),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new qa,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new B,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new B),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const l = this._targetRay
          , u = this._grip
          , f = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (f && e.hand) {
                o = !0;
                for (const S of e.hand.values()) {
                    const _ = t.getJointPose(S, i)
                      , v = this._getHandJoint(f, S);
                    _ !== null && (v.matrix.fromArray(_.transform.matrix),
                    v.matrix.decompose(v.position, v.rotation, v.scale),
                    v.matrixWorldNeedsUpdate = !0,
                    v.jointRadius = _.radius),
                    v.visible = _ !== null
                }
                const d = f.joints["index-finger-tip"]
                  , h = f.joints["thumb-tip"]
                  , m = d.position.distanceTo(h.position)
                  , g = .02
                  , x = .005;
                f.inputState.pinching && m > g + x ? (f.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !f.inputState.pinching && m <= g - x && (f.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                u !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (u.matrix.fromArray(s.transform.matrix),
                u.matrix.decompose(u.position, u.rotation, u.scale),
                u.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (u.hasLinearVelocity = !0,
                u.linearVelocity.copy(s.linearVelocity)) : u.hasLinearVelocity = !1,
                s.angularVelocity ? (u.hasAngularVelocity = !0,
                u.angularVelocity.copy(s.angularVelocity)) : u.hasAngularVelocity = !1));
            l !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (l.matrix.fromArray(r.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            l.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (l.hasLinearVelocity = !0,
            l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1,
            r.angularVelocity ? (l.hasAngularVelocity = !0,
            l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1,
            this.dispatchEvent(mD)))
        }
        return l !== null && (l.visible = r !== null),
        u !== null && (u.visible = s !== null),
        f !== null && (f.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new qa;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
const gD = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , vD = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class xD {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, i) {
        if (this.texture === null) {
            const r = new en
              , s = e.properties.get(r);
            s.__webglTexture = t.texture,
            (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = r
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , i = new Yi({
                vertexShader: gD,
                fragmentShader: vD,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new Sn(new Cl(20,20),i)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class _D extends fs {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , l = "local-floor"
          , u = 1
          , f = null
          , d = null
          , h = null
          , m = null
          , g = null
          , x = null;
        const S = new xD
          , _ = t.getContextAttributes();
        let v = null
          , M = null;
        const w = []
          , E = []
          , O = new he;
        let R = null;
        const A = new yn;
        A.layers.enable(1),
        A.viewport = new Bt;
        const F = new yn;
        F.layers.enable(2),
        F.viewport = new Bt;
        const I = [A, F]
          , P = new Bb;
        P.layers.enable(1),
        P.layers.enable(2);
        let D = null
          , W = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(se) {
            let ue = w[se];
            return ue === void 0 && (ue = new Rg,
            w[se] = ue),
            ue.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(se) {
            let ue = w[se];
            return ue === void 0 && (ue = new Rg,
            w[se] = ue),
            ue.getGripSpace()
        }
        ,
        this.getHand = function(se) {
            let ue = w[se];
            return ue === void 0 && (ue = new Rg,
            w[se] = ue),
            ue.getHandSpace()
        }
        ;
        function X(se) {
            const ue = E.indexOf(se.inputSource);
            if (ue === -1)
                return;
            const Te = w[ue];
            Te !== void 0 && (Te.update(se.inputSource, se.frame, f || o),
            Te.dispatchEvent({
                type: se.type,
                data: se.inputSource
            }))
        }
        function G() {
            r.removeEventListener("select", X),
            r.removeEventListener("selectstart", X),
            r.removeEventListener("selectend", X),
            r.removeEventListener("squeeze", X),
            r.removeEventListener("squeezestart", X),
            r.removeEventListener("squeezeend", X),
            r.removeEventListener("end", G),
            r.removeEventListener("inputsourceschange", q);
            for (let se = 0; se < w.length; se++) {
                const ue = E[se];
                ue !== null && (E[se] = null,
                w[se].disconnect(ue))
            }
            D = null,
            W = null,
            S.reset(),
            e.setRenderTarget(v),
            g = null,
            m = null,
            h = null,
            r = null,
            M = null,
            Ue.stop(),
            i.isPresenting = !1,
            e.setPixelRatio(R),
            e.setSize(O.width, O.height, !1),
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(se) {
            s = se,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(se) {
            l = se,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return f || o
        }
        ,
        this.setReferenceSpace = function(se) {
            f = se
        }
        ,
        this.getBaseLayer = function() {
            return m !== null ? m : g
        }
        ,
        this.getBinding = function() {
            return h
        }
        ,
        this.getFrame = function() {
            return x
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(se) {
            if (r = se,
            r !== null) {
                if (v = e.getRenderTarget(),
                r.addEventListener("select", X),
                r.addEventListener("selectstart", X),
                r.addEventListener("selectend", X),
                r.addEventListener("squeeze", X),
                r.addEventListener("squeezestart", X),
                r.addEventListener("squeezeend", X),
                r.addEventListener("end", G),
                r.addEventListener("inputsourceschange", q),
                _.xrCompatible !== !0 && await t.makeXRCompatible(),
                R = e.getPixelRatio(),
                e.getSize(O),
                r.renderState.layers === void 0) {
                    const ue = {
                        antialias: _.antialias,
                        alpha: !0,
                        depth: _.depth,
                        stencil: _.stencil,
                        framebufferScaleFactor: s
                    };
                    g = new XRWebGLLayer(r,t,ue),
                    r.updateRenderState({
                        baseLayer: g
                    }),
                    e.setPixelRatio(1),
                    e.setSize(g.framebufferWidth, g.framebufferHeight, !1),
                    M = new qi(g.framebufferWidth,g.framebufferHeight,{
                        format: qn,
                        type: fr,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: _.stencil
                    })
                } else {
                    let ue = null
                      , Te = null
                      , Me = null;
                    _.depth && (Me = _.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    ue = _.stencil ? Vo : Do,
                    Te = _.stencil ? zo : as);
                    const Ye = {
                        colorFormat: t.RGBA8,
                        depthFormat: Me,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r,t),
                    m = h.createProjectionLayer(Ye),
                    r.updateRenderState({
                        layers: [m]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(m.textureWidth, m.textureHeight, !1),
                    M = new qi(m.textureWidth,m.textureHeight,{
                        format: qn,
                        type: fr,
                        depthTexture: new tm(m.textureWidth,m.textureHeight,Te,void 0,void 0,void 0,void 0,void 0,void 0,ue),
                        stencilBuffer: _.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: _.antialias ? 4 : 0,
                        resolveDepthBuffer: m.ignoreDepthValues === !1
                    })
                }
                M.isXRRenderTarget = !0,
                this.setFoveation(u),
                f = null,
                o = await r.requestReferenceSpace(l),
                Ue.setContext(r),
                Ue.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return S.getDepthTexture()
        }
        ;
        function q(se) {
            for (let ue = 0; ue < se.removed.length; ue++) {
                const Te = se.removed[ue]
                  , Me = E.indexOf(Te);
                Me >= 0 && (E[Me] = null,
                w[Me].disconnect(Te))
            }
            for (let ue = 0; ue < se.added.length; ue++) {
                const Te = se.added[ue];
                let Me = E.indexOf(Te);
                if (Me === -1) {
                    for (let Qe = 0; Qe < w.length; Qe++)
                        if (Qe >= E.length) {
                            E.push(Te),
                            Me = Qe;
                            break
                        } else if (E[Qe] === null) {
                            E[Qe] = Te,
                            Me = Qe;
                            break
                        }
                    if (Me === -1)
                        break
                }
                const Ye = w[Me];
                Ye && Ye.connect(Te)
            }
        }
        const K = new B
          , oe = new B;
        function z(se, ue, Te) {
            K.setFromMatrixPosition(ue.matrixWorld),
            oe.setFromMatrixPosition(Te.matrixWorld);
            const Me = K.distanceTo(oe)
              , Ye = ue.projectionMatrix.elements
              , Qe = Te.projectionMatrix.elements
              , ze = Ye[14] / (Ye[10] - 1)
              , ke = Ye[14] / (Ye[10] + 1)
              , k = (Ye[9] + 1) / Ye[5]
              , pe = (Ye[9] - 1) / Ye[5]
              , ye = (Ye[8] - 1) / Ye[0]
              , Pe = (Qe[8] + 1) / Qe[0]
              , fe = ze * ye
              , $e = ze * Pe
              , Le = Me / (-ye + Pe)
              , Be = Le * -ye;
            ue.matrixWorld.decompose(se.position, se.quaternion, se.scale),
            se.translateX(Be),
            se.translateZ(Le),
            se.matrixWorld.compose(se.position, se.quaternion, se.scale),
            se.matrixWorldInverse.copy(se.matrixWorld).invert();
            const H = ze + Le
              , L = ke + Le
              , te = fe - Be
              , _e = $e + (Me - Be)
              , ge = k * ke / L * H
              , ve = pe * ke / L * H;
            se.projectionMatrix.makePerspective(te, _e, ge, ve, H, L),
            se.projectionMatrixInverse.copy(se.projectionMatrix).invert()
        }
        function ee(se, ue) {
            ue === null ? se.matrixWorld.copy(se.matrix) : se.matrixWorld.multiplyMatrices(ue.matrixWorld, se.matrix),
            se.matrixWorldInverse.copy(se.matrixWorld).invert()
        }
        this.updateCamera = function(se) {
            if (r === null)
                return;
            S.texture !== null && (se.near = S.depthNear,
            se.far = S.depthFar),
            P.near = F.near = A.near = se.near,
            P.far = F.far = A.far = se.far,
            (D !== P.near || W !== P.far) && (r.updateRenderState({
                depthNear: P.near,
                depthFar: P.far
            }),
            D = P.near,
            W = P.far,
            A.near = D,
            A.far = W,
            F.near = D,
            F.far = W,
            A.updateProjectionMatrix(),
            F.updateProjectionMatrix(),
            se.updateProjectionMatrix());
            const ue = se.parent
              , Te = P.cameras;
            ee(P, ue);
            for (let Me = 0; Me < Te.length; Me++)
                ee(Te[Me], ue);
            Te.length === 2 ? z(P, A, F) : P.projectionMatrix.copy(A.projectionMatrix),
            Q(se, P, ue)
        }
        ;
        function Q(se, ue, Te) {
            Te === null ? se.matrix.copy(ue.matrixWorld) : (se.matrix.copy(Te.matrixWorld),
            se.matrix.invert(),
            se.matrix.multiply(ue.matrixWorld)),
            se.matrix.decompose(se.position, se.quaternion, se.scale),
            se.updateMatrixWorld(!0),
            se.projectionMatrix.copy(ue.projectionMatrix),
            se.projectionMatrixInverse.copy(ue.projectionMatrixInverse),
            se.isPerspectiveCamera && (se.fov = hl * 2 * Math.atan(1 / se.projectionMatrix.elements[5]),
            se.zoom = 1)
        }
        this.getCamera = function() {
            return P
        }
        ,
        this.getFoveation = function() {
            if (!(m === null && g === null))
                return u
        }
        ,
        this.setFoveation = function(se) {
            u = se,
            m !== null && (m.fixedFoveation = se),
            g !== null && g.fixedFoveation !== void 0 && (g.fixedFoveation = se)
        }
        ,
        this.hasDepthSensing = function() {
            return S.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return S.getMesh(P)
        }
        ;
        let ce = null;
        function be(se, ue) {
            if (d = ue.getViewerPose(f || o),
            x = ue,
            d !== null) {
                const Te = d.views;
                g !== null && (e.setRenderTargetFramebuffer(M, g.framebuffer),
                e.setRenderTarget(M));
                let Me = !1;
                Te.length !== P.cameras.length && (P.cameras.length = 0,
                Me = !0);
                for (let Qe = 0; Qe < Te.length; Qe++) {
                    const ze = Te[Qe];
                    let ke = null;
                    if (g !== null)
                        ke = g.getViewport(ze);
                    else {
                        const pe = h.getViewSubImage(m, ze);
                        ke = pe.viewport,
                        Qe === 0 && (e.setRenderTargetTextures(M, pe.colorTexture, m.ignoreDepthValues ? void 0 : pe.depthStencilTexture),
                        e.setRenderTarget(M))
                    }
                    let k = I[Qe];
                    k === void 0 && (k = new yn,
                    k.layers.enable(Qe),
                    k.viewport = new Bt,
                    I[Qe] = k),
                    k.matrix.fromArray(ze.transform.matrix),
                    k.matrix.decompose(k.position, k.quaternion, k.scale),
                    k.projectionMatrix.fromArray(ze.projectionMatrix),
                    k.projectionMatrixInverse.copy(k.projectionMatrix).invert(),
                    k.viewport.set(ke.x, ke.y, ke.width, ke.height),
                    Qe === 0 && (P.matrix.copy(k.matrix),
                    P.matrix.decompose(P.position, P.quaternion, P.scale)),
                    Me === !0 && P.cameras.push(k)
                }
                const Ye = r.enabledFeatures;
                if (Ye && Ye.includes("depth-sensing")) {
                    const Qe = h.getDepthInformation(Te[0]);
                    Qe && Qe.isValid && Qe.texture && S.init(e, Qe, r.renderState)
                }
            }
            for (let Te = 0; Te < w.length; Te++) {
                const Me = E[Te]
                  , Ye = w[Te];
                Me !== null && Ye !== void 0 && Ye.update(Me, ue, f || o)
            }
            ce && ce(se, ue),
            ue.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: ue
            }),
            x = null
        }
        const Ue = new Nb;
        Ue.setAnimationLoop(be),
        this.setAnimationLoop = function(se) {
            ce = se
        }
        ,
        this.dispose = function() {}
    }
}
const go = new Ri
  , yD = new ct;
function SD(n, e) {
    function t(_, v) {
        _.matrixAutoUpdate === !0 && _.updateMatrix(),
        v.value.copy(_.matrix)
    }
    function i(_, v) {
        v.color.getRGB(_.fogColor.value, Lb(n)),
        v.isFog ? (_.fogNear.value = v.near,
        _.fogFar.value = v.far) : v.isFogExp2 && (_.fogDensity.value = v.density)
    }
    function r(_, v, M, w, E) {
        v.isMeshBasicMaterial || v.isMeshLambertMaterial ? s(_, v) : v.isMeshToonMaterial ? (s(_, v),
        h(_, v)) : v.isMeshPhongMaterial ? (s(_, v),
        d(_, v)) : v.isMeshStandardMaterial ? (s(_, v),
        m(_, v),
        v.isMeshPhysicalMaterial && g(_, v, E)) : v.isMeshMatcapMaterial ? (s(_, v),
        x(_, v)) : v.isMeshDepthMaterial ? s(_, v) : v.isMeshDistanceMaterial ? (s(_, v),
        S(_, v)) : v.isMeshNormalMaterial ? s(_, v) : v.isLineBasicMaterial ? (o(_, v),
        v.isLineDashedMaterial && l(_, v)) : v.isPointsMaterial ? u(_, v, M, w) : v.isSpriteMaterial ? f(_, v) : v.isShadowMaterial ? (_.color.value.copy(v.color),
        _.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = !1)
    }
    function s(_, v) {
        _.opacity.value = v.opacity,
        v.color && _.diffuse.value.copy(v.color),
        v.emissive && _.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),
        v.map && (_.map.value = v.map,
        t(v.map, _.mapTransform)),
        v.alphaMap && (_.alphaMap.value = v.alphaMap,
        t(v.alphaMap, _.alphaMapTransform)),
        v.bumpMap && (_.bumpMap.value = v.bumpMap,
        t(v.bumpMap, _.bumpMapTransform),
        _.bumpScale.value = v.bumpScale,
        v.side === ri && (_.bumpScale.value *= -1)),
        v.normalMap && (_.normalMap.value = v.normalMap,
        t(v.normalMap, _.normalMapTransform),
        _.normalScale.value.copy(v.normalScale),
        v.side === ri && _.normalScale.value.negate()),
        v.displacementMap && (_.displacementMap.value = v.displacementMap,
        t(v.displacementMap, _.displacementMapTransform),
        _.displacementScale.value = v.displacementScale,
        _.displacementBias.value = v.displacementBias),
        v.emissiveMap && (_.emissiveMap.value = v.emissiveMap,
        t(v.emissiveMap, _.emissiveMapTransform)),
        v.specularMap && (_.specularMap.value = v.specularMap,
        t(v.specularMap, _.specularMapTransform)),
        v.alphaTest > 0 && (_.alphaTest.value = v.alphaTest);
        const M = e.get(v)
          , w = M.envMap
          , E = M.envMapRotation;
        w && (_.envMap.value = w,
        go.copy(E),
        go.x *= -1,
        go.y *= -1,
        go.z *= -1,
        w.isCubeTexture && w.isRenderTargetTexture === !1 && (go.y *= -1,
        go.z *= -1),
        _.envMapRotation.value.setFromMatrix4(yD.makeRotationFromEuler(go)),
        _.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
        _.reflectivity.value = v.reflectivity,
        _.ior.value = v.ior,
        _.refractionRatio.value = v.refractionRatio),
        v.lightMap && (_.lightMap.value = v.lightMap,
        _.lightMapIntensity.value = v.lightMapIntensity,
        t(v.lightMap, _.lightMapTransform)),
        v.aoMap && (_.aoMap.value = v.aoMap,
        _.aoMapIntensity.value = v.aoMapIntensity,
        t(v.aoMap, _.aoMapTransform))
    }
    function o(_, v) {
        _.diffuse.value.copy(v.color),
        _.opacity.value = v.opacity,
        v.map && (_.map.value = v.map,
        t(v.map, _.mapTransform))
    }
    function l(_, v) {
        _.dashSize.value = v.dashSize,
        _.totalSize.value = v.dashSize + v.gapSize,
        _.scale.value = v.scale
    }
    function u(_, v, M, w) {
        _.diffuse.value.copy(v.color),
        _.opacity.value = v.opacity,
        _.size.value = v.size * M,
        _.scale.value = w * .5,
        v.map && (_.map.value = v.map,
        t(v.map, _.uvTransform)),
        v.alphaMap && (_.alphaMap.value = v.alphaMap,
        t(v.alphaMap, _.alphaMapTransform)),
        v.alphaTest > 0 && (_.alphaTest.value = v.alphaTest)
    }
    function f(_, v) {
        _.diffuse.value.copy(v.color),
        _.opacity.value = v.opacity,
        _.rotation.value = v.rotation,
        v.map && (_.map.value = v.map,
        t(v.map, _.mapTransform)),
        v.alphaMap && (_.alphaMap.value = v.alphaMap,
        t(v.alphaMap, _.alphaMapTransform)),
        v.alphaTest > 0 && (_.alphaTest.value = v.alphaTest)
    }
    function d(_, v) {
        _.specular.value.copy(v.specular),
        _.shininess.value = Math.max(v.shininess, 1e-4)
    }
    function h(_, v) {
        v.gradientMap && (_.gradientMap.value = v.gradientMap)
    }
    function m(_, v) {
        _.metalness.value = v.metalness,
        v.metalnessMap && (_.metalnessMap.value = v.metalnessMap,
        t(v.metalnessMap, _.metalnessMapTransform)),
        _.roughness.value = v.roughness,
        v.roughnessMap && (_.roughnessMap.value = v.roughnessMap,
        t(v.roughnessMap, _.roughnessMapTransform)),
        v.envMap && (_.envMapIntensity.value = v.envMapIntensity)
    }
    function g(_, v, M) {
        _.ior.value = v.ior,
        v.sheen > 0 && (_.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),
        _.sheenRoughness.value = v.sheenRoughness,
        v.sheenColorMap && (_.sheenColorMap.value = v.sheenColorMap,
        t(v.sheenColorMap, _.sheenColorMapTransform)),
        v.sheenRoughnessMap && (_.sheenRoughnessMap.value = v.sheenRoughnessMap,
        t(v.sheenRoughnessMap, _.sheenRoughnessMapTransform))),
        v.clearcoat > 0 && (_.clearcoat.value = v.clearcoat,
        _.clearcoatRoughness.value = v.clearcoatRoughness,
        v.clearcoatMap && (_.clearcoatMap.value = v.clearcoatMap,
        t(v.clearcoatMap, _.clearcoatMapTransform)),
        v.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap,
        t(v.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)),
        v.clearcoatNormalMap && (_.clearcoatNormalMap.value = v.clearcoatNormalMap,
        t(v.clearcoatNormalMap, _.clearcoatNormalMapTransform),
        _.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),
        v.side === ri && _.clearcoatNormalScale.value.negate())),
        v.dispersion > 0 && (_.dispersion.value = v.dispersion),
        v.iridescence > 0 && (_.iridescence.value = v.iridescence,
        _.iridescenceIOR.value = v.iridescenceIOR,
        _.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0],
        _.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1],
        v.iridescenceMap && (_.iridescenceMap.value = v.iridescenceMap,
        t(v.iridescenceMap, _.iridescenceMapTransform)),
        v.iridescenceThicknessMap && (_.iridescenceThicknessMap.value = v.iridescenceThicknessMap,
        t(v.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))),
        v.transmission > 0 && (_.transmission.value = v.transmission,
        _.transmissionSamplerMap.value = M.texture,
        _.transmissionSamplerSize.value.set(M.width, M.height),
        v.transmissionMap && (_.transmissionMap.value = v.transmissionMap,
        t(v.transmissionMap, _.transmissionMapTransform)),
        _.thickness.value = v.thickness,
        v.thicknessMap && (_.thicknessMap.value = v.thicknessMap,
        t(v.thicknessMap, _.thicknessMapTransform)),
        _.attenuationDistance.value = v.attenuationDistance,
        _.attenuationColor.value.copy(v.attenuationColor)),
        v.anisotropy > 0 && (_.anisotropyVector.value.set(v.anisotropy * Math.cos(v.anisotropyRotation), v.anisotropy * Math.sin(v.anisotropyRotation)),
        v.anisotropyMap && (_.anisotropyMap.value = v.anisotropyMap,
        t(v.anisotropyMap, _.anisotropyMapTransform))),
        _.specularIntensity.value = v.specularIntensity,
        _.specularColor.value.copy(v.specularColor),
        v.specularColorMap && (_.specularColorMap.value = v.specularColorMap,
        t(v.specularColorMap, _.specularColorMapTransform)),
        v.specularIntensityMap && (_.specularIntensityMap.value = v.specularIntensityMap,
        t(v.specularIntensityMap, _.specularIntensityMapTransform))
    }
    function x(_, v) {
        v.matcap && (_.matcap.value = v.matcap)
    }
    function S(_, v) {
        const M = e.get(v).light;
        _.referencePosition.value.setFromMatrixPosition(M.matrixWorld),
        _.nearDistance.value = M.shadow.camera.near,
        _.farDistance.value = M.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}
function MD(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const l = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
    function u(M, w) {
        const E = w.program;
        i.uniformBlockBinding(M, E)
    }
    function f(M, w) {
        let E = r[M.id];
        E === void 0 && (x(M),
        E = d(M),
        r[M.id] = E,
        M.addEventListener("dispose", _));
        const O = w.program;
        i.updateUBOMapping(M, O);
        const R = e.render.frame;
        s[M.id] !== R && (m(M),
        s[M.id] = R)
    }
    function d(M) {
        const w = h();
        M.__bindingPointIndex = w;
        const E = n.createBuffer()
          , O = M.__size
          , R = M.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, E),
        n.bufferData(n.UNIFORM_BUFFER, O, R),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, w, E),
        E
    }
    function h() {
        for (let M = 0; M < l; M++)
            if (o.indexOf(M) === -1)
                return o.push(M),
                M;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function m(M) {
        const w = r[M.id]
          , E = M.uniforms
          , O = M.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, w);
        for (let R = 0, A = E.length; R < A; R++) {
            const F = Array.isArray(E[R]) ? E[R] : [E[R]];
            for (let I = 0, P = F.length; I < P; I++) {
                const D = F[I];
                if (g(D, R, I, O) === !0) {
                    const W = D.__offset
                      , X = Array.isArray(D.value) ? D.value : [D.value];
                    let G = 0;
                    for (let q = 0; q < X.length; q++) {
                        const K = X[q]
                          , oe = S(K);
                        typeof K == "number" || typeof K == "boolean" ? (D.__data[0] = K,
                        n.bufferSubData(n.UNIFORM_BUFFER, W + G, D.__data)) : K.isMatrix3 ? (D.__data[0] = K.elements[0],
                        D.__data[1] = K.elements[1],
                        D.__data[2] = K.elements[2],
                        D.__data[3] = 0,
                        D.__data[4] = K.elements[3],
                        D.__data[5] = K.elements[4],
                        D.__data[6] = K.elements[5],
                        D.__data[7] = 0,
                        D.__data[8] = K.elements[6],
                        D.__data[9] = K.elements[7],
                        D.__data[10] = K.elements[8],
                        D.__data[11] = 0) : (K.toArray(D.__data, G),
                        G += oe.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, W, D.__data)
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function g(M, w, E, O) {
        const R = M.value
          , A = w + "_" + E;
        if (O[A] === void 0)
            return typeof R == "number" || typeof R == "boolean" ? O[A] = R : O[A] = R.clone(),
            !0;
        {
            const F = O[A];
            if (typeof R == "number" || typeof R == "boolean") {
                if (F !== R)
                    return O[A] = R,
                    !0
            } else if (F.equals(R) === !1)
                return F.copy(R),
                !0
        }
        return !1
    }
    function x(M) {
        const w = M.uniforms;
        let E = 0;
        const O = 16;
        for (let A = 0, F = w.length; A < F; A++) {
            const I = Array.isArray(w[A]) ? w[A] : [w[A]];
            for (let P = 0, D = I.length; P < D; P++) {
                const W = I[P]
                  , X = Array.isArray(W.value) ? W.value : [W.value];
                for (let G = 0, q = X.length; G < q; G++) {
                    const K = X[G]
                      , oe = S(K)
                      , z = E % O;
                    z !== 0 && O - z < oe.boundary && (E += O - z),
                    W.__data = new Float32Array(oe.storage / Float32Array.BYTES_PER_ELEMENT),
                    W.__offset = E,
                    E += oe.storage
                }
            }
        }
        const R = E % O;
        return R > 0 && (E += O - R),
        M.__size = E,
        M.__cache = {},
        this
    }
    function S(M) {
        const w = {
            boundary: 0,
            storage: 0
        };
        return typeof M == "number" || typeof M == "boolean" ? (w.boundary = 4,
        w.storage = 4) : M.isVector2 ? (w.boundary = 8,
        w.storage = 8) : M.isVector3 || M.isColor ? (w.boundary = 16,
        w.storage = 12) : M.isVector4 ? (w.boundary = 16,
        w.storage = 16) : M.isMatrix3 ? (w.boundary = 48,
        w.storage = 48) : M.isMatrix4 ? (w.boundary = 64,
        w.storage = 64) : M.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", M),
        w
    }
    function _(M) {
        const w = M.target;
        w.removeEventListener("dispose", _);
        const E = o.indexOf(w.__bindingPointIndex);
        o.splice(E, 1),
        n.deleteBuffer(r[w.id]),
        delete r[w.id],
        delete s[w.id]
    }
    function v() {
        for (const M in r)
            n.deleteBuffer(r[M]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: u,
        update: f,
        dispose: v
    }
}
class zb {
    constructor(e={}) {
        const {canvas: t=Ab(), context: i=null, depth: r=!0, stencil: s=!1, alpha: o=!1, antialias: l=!1, premultipliedAlpha: u=!0, preserveDrawingBuffer: f=!1, powerPreference: d="default", failIfMajorPerformanceCaveat: h=!1} = e;
        this.isWebGLRenderer = !0;
        let m;
        if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            m = i.getContextAttributes().alpha
        } else
            m = o;
        const g = new Uint32Array(4)
          , x = new Int32Array(4);
        let S = null
          , _ = null;
        const v = []
          , M = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Hi,
        this.toneMapping = Pr,
        this.toneMappingExposure = 1;
        const w = this;
        let E = !1
          , O = 0
          , R = 0
          , A = null
          , F = -1
          , I = null;
        const P = new Bt
          , D = new Bt;
        let W = null;
        const X = new Oe(0);
        let G = 0
          , q = t.width
          , K = t.height
          , oe = 1
          , z = null
          , ee = null;
        const Q = new Bt(0,0,q,K)
          , ce = new Bt(0,0,q,K);
        let be = !1;
        const Ue = new ku;
        let se = !1
          , ue = !1;
        const Te = new ct
          , Me = new B
          , Ye = new Bt
          , Qe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let ze = !1;
        function ke() {
            return A === null ? oe : 1
        }
        let k = i;
        function pe(U, Y) {
            return t.getContext(U, Y)
        }
        try {
            const U = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: l,
                premultipliedAlpha: u,
                preserveDrawingBuffer: f,
                powerPreference: d,
                failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${Gp}`),
            t.addEventListener("webglcontextlost", me, !1),
            t.addEventListener("webglcontextrestored", xe, !1),
            t.addEventListener("webglcontextcreationerror", Ne, !1),
            k === null) {
                const Y = "webgl2";
                if (k = pe(Y, U),
                k === null)
                    throw pe(Y) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (U) {
            throw console.error("THREE.WebGLRenderer: " + U.message),
            U
        }
        let ye, Pe, fe, $e, Le, Be, H, L, te, _e, ge, ve, Ke, we, He, ft, Ee, We, Ct, dt, je, pt, Mt, Gt;
        function $() {
            ye = new P9(k),
            ye.init(),
            pt = new kb(k,ye),
            Pe = new b9(k,ye,e,pt),
            fe = new lD(k),
            $e = new N9(k),
            Le = new ZO,
            Be = new pD(k,ye,fe,Le,Pe,pt,$e),
            H = new C9(w),
            L = new R9(w),
            te = new z7(k),
            Mt = new M9(k,te),
            _e = new I9(k,te,$e,Mt),
            ge = new D9(k,_e,te,$e),
            Ct = new O9(k,Pe,Be),
            ft = new E9(Le),
            ve = new YO(w,H,L,ye,Pe,Mt,ft),
            Ke = new SD(w,Le),
            we = new JO,
            He = new rD(ye),
            We = new S9(w,H,L,fe,ge,m,u),
            Ee = new aD(w,ge,Pe),
            Gt = new MD(k,$e,Pe,fe),
            dt = new w9(k,ye,$e),
            je = new L9(k,ye,$e),
            $e.programs = ve.programs,
            w.capabilities = Pe,
            w.extensions = ye,
            w.properties = Le,
            w.renderLists = we,
            w.shadowMap = Ee,
            w.state = fe,
            w.info = $e
        }
        $();
        const Ae = new _D(w,k);
        this.xr = Ae,
        this.getContext = function() {
            return k
        }
        ,
        this.getContextAttributes = function() {
            return k.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const U = ye.get("WEBGL_lose_context");
            U && U.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const U = ye.get("WEBGL_lose_context");
            U && U.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return oe
        }
        ,
        this.setPixelRatio = function(U) {
            U !== void 0 && (oe = U,
            this.setSize(q, K, !1))
        }
        ,
        this.getSize = function(U) {
            return U.set(q, K)
        }
        ,
        this.setSize = function(U, Y, ie=!0) {
            if (Ae.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            q = U,
            K = Y,
            t.width = Math.floor(U * oe),
            t.height = Math.floor(Y * oe),
            ie === !0 && (t.style.width = U + "px",
            t.style.height = Y + "px"),
            this.setViewport(0, 0, U, Y)
        }
        ,
        this.getDrawingBufferSize = function(U) {
            return U.set(q * oe, K * oe).floor()
        }
        ,
        this.setDrawingBufferSize = function(U, Y, ie) {
            q = U,
            K = Y,
            oe = ie,
            t.width = Math.floor(U * ie),
            t.height = Math.floor(Y * ie),
            this.setViewport(0, 0, U, Y)
        }
        ,
        this.getCurrentViewport = function(U) {
            return U.copy(P)
        }
        ,
        this.getViewport = function(U) {
            return U.copy(Q)
        }
        ,
        this.setViewport = function(U, Y, ie, re) {
            U.isVector4 ? Q.set(U.x, U.y, U.z, U.w) : Q.set(U, Y, ie, re),
            fe.viewport(P.copy(Q).multiplyScalar(oe).round())
        }
        ,
        this.getScissor = function(U) {
            return U.copy(ce)
        }
        ,
        this.setScissor = function(U, Y, ie, re) {
            U.isVector4 ? ce.set(U.x, U.y, U.z, U.w) : ce.set(U, Y, ie, re),
            fe.scissor(D.copy(ce).multiplyScalar(oe).round())
        }
        ,
        this.getScissorTest = function() {
            return be
        }
        ,
        this.setScissorTest = function(U) {
            fe.setScissorTest(be = U)
        }
        ,
        this.setOpaqueSort = function(U) {
            z = U
        }
        ,
        this.setTransparentSort = function(U) {
            ee = U
        }
        ,
        this.getClearColor = function(U) {
            return U.copy(We.getClearColor())
        }
        ,
        this.setClearColor = function() {
            We.setClearColor.apply(We, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return We.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            We.setClearAlpha.apply(We, arguments)
        }
        ,
        this.clear = function(U=!0, Y=!0, ie=!0) {
            let re = 0;
            if (U) {
                let J = !1;
                if (A !== null) {
                    const Re = A.texture.format;
                    J = Re === Kp || Re === Zp || Re === Ou
                }
                if (J) {
                    const Re = A.texture.type
                      , Ge = Re === fr || Re === as || Re === dl || Re === zo || Re === $p || Re === qp
                      , Ze = We.getClearColor()
                      , qe = We.getClearAlpha()
                      , st = Ze.r
                      , lt = Ze.g
                      , it = Ze.b;
                    Ge ? (g[0] = st,
                    g[1] = lt,
                    g[2] = it,
                    g[3] = qe,
                    k.clearBufferuiv(k.COLOR, 0, g)) : (x[0] = st,
                    x[1] = lt,
                    x[2] = it,
                    x[3] = qe,
                    k.clearBufferiv(k.COLOR, 0, x))
                } else
                    re |= k.COLOR_BUFFER_BIT
            }
            Y && (re |= k.DEPTH_BUFFER_BIT),
            ie && (re |= k.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            k.clear(re)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", me, !1),
            t.removeEventListener("webglcontextrestored", xe, !1),
            t.removeEventListener("webglcontextcreationerror", Ne, !1),
            we.dispose(),
            He.dispose(),
            Le.dispose(),
            H.dispose(),
            L.dispose(),
            ge.dispose(),
            Mt.dispose(),
            Gt.dispose(),
            ve.dispose(),
            Ae.dispose(),
            Ae.removeEventListener("sessionstart", xi),
            Ae.removeEventListener("sessionend", Ku),
            kr.stop()
        }
        ;
        function me(U) {
            U.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            E = !0
        }
        function xe() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            E = !1;
            const U = $e.autoReset
              , Y = Ee.enabled
              , ie = Ee.autoUpdate
              , re = Ee.needsUpdate
              , J = Ee.type;
            $(),
            $e.autoReset = U,
            Ee.enabled = Y,
            Ee.autoUpdate = ie,
            Ee.needsUpdate = re,
            Ee.type = J
        }
        function Ne(U) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", U.statusMessage)
        }
        function ut(U) {
            const Y = U.target;
            Y.removeEventListener("dispose", ut),
            Tt(Y)
        }
        function Tt(U) {
            Kt(U),
            Le.remove(U)
        }
        function Kt(U) {
            const Y = Le.get(U).programs;
            Y !== void 0 && (Y.forEach(function(ie) {
                ve.releaseProgram(ie)
            }),
            U.isShaderMaterial && ve.releaseShaderCache(U))
        }
        this.renderBufferDirect = function(U, Y, ie, re, J, Re) {
            Y === null && (Y = Qe);
            const Ge = J.isMesh && J.matrixWorld.determinant() < 0
              , Ze = Am(U, Y, ie, re, J);
            fe.setMaterial(re, Ge);
            let qe = ie.index
              , st = 1;
            if (re.wireframe === !0) {
                if (qe = _e.getWireframeAttribute(ie),
                qe === void 0)
                    return;
                st = 2
            }
            const lt = ie.drawRange
              , it = ie.attributes.position;
            let Lt = lt.start * st
              , Wt = (lt.start + lt.count) * st;
            Re !== null && (Lt = Math.max(Lt, Re.start * st),
            Wt = Math.min(Wt, (Re.start + Re.count) * st)),
            qe !== null ? (Lt = Math.max(Lt, 0),
            Wt = Math.min(Wt, qe.count)) : it != null && (Lt = Math.max(Lt, 0),
            Wt = Math.min(Wt, it.count));
            const zt = Wt - Lt;
            if (zt < 0 || zt === 1 / 0)
                return;
            Mt.setup(J, re, Ze, ie, qe);
            let tn, nt = dt;
            if (qe !== null && (tn = te.get(qe),
            nt = je,
            nt.setIndex(tn)),
            J.isMesh)
                re.wireframe === !0 ? (fe.setLineWidth(re.wireframeLinewidth * ke()),
                nt.setMode(k.LINES)) : nt.setMode(k.TRIANGLES);
            else if (J.isLine) {
                let Ie = re.linewidth;
                Ie === void 0 && (Ie = 1),
                fe.setLineWidth(Ie * ke()),
                J.isLineSegments ? nt.setMode(k.LINES) : J.isLineLoop ? nt.setMode(k.LINE_LOOP) : nt.setMode(k.LINE_STRIP)
            } else
                J.isPoints ? nt.setMode(k.POINTS) : J.isSprite && nt.setMode(k.TRIANGLES);
            if (J.isBatchedMesh)
                if (J._multiDrawInstances !== null)
                    nt.renderMultiDrawInstances(J._multiDrawStarts, J._multiDrawCounts, J._multiDrawCount, J._multiDrawInstances);
                else if (ye.get("WEBGL_multi_draw"))
                    nt.renderMultiDraw(J._multiDrawStarts, J._multiDrawCounts, J._multiDrawCount);
                else {
                    const Ie = J._multiDrawStarts
                      , jt = J._multiDrawCounts
                      , ht = J._multiDrawCount
                      , Xt = qe ? te.get(qe).bytesPerElement : 1
                      , ai = Le.get(re).currentProgram.getUniforms();
                    for (let pn = 0; pn < ht; pn++)
                        ai.setValue(k, "_gl_DrawID", pn),
                        nt.render(Ie[pn] / Xt, jt[pn])
                }
            else if (J.isInstancedMesh)
                nt.renderInstances(Lt, zt, J.count);
            else if (ie.isInstancedBufferGeometry) {
                const Ie = ie._maxInstanceCount !== void 0 ? ie._maxInstanceCount : 1 / 0
                  , jt = Math.min(ie.instanceCount, Ie);
                nt.renderInstances(Lt, zt, jt)
            } else
                nt.render(Lt, zt)
        }
        ;
        function Mn(U, Y, ie) {
            U.transparent === !0 && U.side === lr && U.forceSinglePass === !1 ? (U.side = ri,
            U.needsUpdate = !0,
            ea(U, Y, ie),
            U.side = Dr,
            U.needsUpdate = !0,
            ea(U, Y, ie),
            U.side = lr) : ea(U, Y, ie)
        }
        this.compile = function(U, Y, ie=null) {
            ie === null && (ie = U),
            _ = He.get(ie),
            _.init(Y),
            M.push(_),
            ie.traverseVisible(function(J) {
                J.isLight && J.layers.test(Y.layers) && (_.pushLight(J),
                J.castShadow && _.pushShadow(J))
            }),
            U !== ie && U.traverseVisible(function(J) {
                J.isLight && J.layers.test(Y.layers) && (_.pushLight(J),
                J.castShadow && _.pushShadow(J))
            }),
            _.setupLights();
            const re = new Set;
            return U.traverse(function(J) {
                const Re = J.material;
                if (Re)
                    if (Array.isArray(Re))
                        for (let Ge = 0; Ge < Re.length; Ge++) {
                            const Ze = Re[Ge];
                            Mn(Ze, ie, J),
                            re.add(Ze)
                        }
                    else
                        Mn(Re, ie, J),
                        re.add(Re)
            }),
            M.pop(),
            _ = null,
            re
        }
        ,
        this.compileAsync = function(U, Y, ie=null) {
            const re = this.compile(U, Y, ie);
            return new Promise(J => {
                function Re() {
                    if (re.forEach(function(Ge) {
                        Le.get(Ge).currentProgram.isReady() && re.delete(Ge)
                    }),
                    re.size === 0) {
                        J(U);
                        return
                    }
                    setTimeout(Re, 10)
                }
                ye.get("KHR_parallel_shader_compile") !== null ? Re() : setTimeout(Re, 10)
            }
            )
        }
        ;
        let Rt = null;
        function Li(U) {
            Rt && Rt(U)
        }
        function xi() {
            kr.stop()
        }
        function Ku() {
            kr.start()
        }
        const kr = new Nb;
        kr.setAnimationLoop(Li),
        typeof self < "u" && kr.setContext(self),
        this.setAnimationLoop = function(U) {
            Rt = U,
            Ae.setAnimationLoop(U),
            U === null ? kr.stop() : kr.start()
        }
        ,
        Ae.addEventListener("sessionstart", xi),
        Ae.addEventListener("sessionend", Ku),
        this.render = function(U, Y) {
            if (Y !== void 0 && Y.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (E === !0)
                return;
            if (U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(),
            Y.parent === null && Y.matrixWorldAutoUpdate === !0 && Y.updateMatrixWorld(),
            Ae.enabled === !0 && Ae.isPresenting === !0 && (Ae.cameraAutoUpdate === !0 && Ae.updateCamera(Y),
            Y = Ae.getCamera()),
            U.isScene === !0 && U.onBeforeRender(w, U, Y, A),
            _ = He.get(U, M.length),
            _.init(Y),
            M.push(_),
            Te.multiplyMatrices(Y.projectionMatrix, Y.matrixWorldInverse),
            Ue.setFromProjectionMatrix(Te),
            ue = this.localClippingEnabled,
            se = ft.init(this.clippingPlanes, ue),
            S = we.get(U, v.length),
            S.init(),
            v.push(S),
            Ae.enabled === !0 && Ae.isPresenting === !0) {
                const Re = w.xr.getDepthSensingMesh();
                Re !== null && Rl(Re, Y, -1 / 0, w.sortObjects)
            }
            Rl(U, Y, 0, w.sortObjects),
            S.finish(),
            w.sortObjects === !0 && S.sort(z, ee),
            ze = Ae.enabled === !1 || Ae.isPresenting === !1 || Ae.hasDepthSensing() === !1,
            ze && We.addToRenderList(S, U),
            this.info.render.frame++,
            se === !0 && ft.beginShadows();
            const ie = _.state.shadowsArray;
            Ee.render(ie, U, Y),
            se === !0 && ft.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const re = S.opaque
              , J = S.transmissive;
            if (_.setupLights(),
            Y.isArrayCamera) {
                const Re = Y.cameras;
                if (J.length > 0)
                    for (let Ge = 0, Ze = Re.length; Ge < Ze; Ge++) {
                        const qe = Re[Ge];
                        Jo(re, J, U, qe)
                    }
                ze && We.render(U);
                for (let Ge = 0, Ze = Re.length; Ge < Ze; Ge++) {
                    const qe = Re[Ge];
                    Pl(S, U, qe, qe.viewport)
                }
            } else
                J.length > 0 && Jo(re, J, U, Y),
                ze && We.render(U),
                Pl(S, U, Y);
            A !== null && (Be.updateMultisampleRenderTarget(A),
            Be.updateRenderTargetMipmap(A)),
            U.isScene === !0 && U.onAfterRender(w, U, Y),
            Mt.resetDefaultState(),
            F = -1,
            I = null,
            M.pop(),
            M.length > 0 ? (_ = M[M.length - 1],
            se === !0 && ft.setGlobalState(w.clippingPlanes, _.state.camera)) : _ = null,
            v.pop(),
            v.length > 0 ? S = v[v.length - 1] : S = null
        }
        ;
        function Rl(U, Y, ie, re) {
            if (U.visible === !1)
                return;
            if (U.layers.test(Y.layers)) {
                if (U.isGroup)
                    ie = U.renderOrder;
                else if (U.isLOD)
                    U.autoUpdate === !0 && U.update(Y);
                else if (U.isLight)
                    _.pushLight(U),
                    U.castShadow && _.pushShadow(U);
                else if (U.isSprite) {
                    if (!U.frustumCulled || Ue.intersectsSprite(U)) {
                        re && Ye.setFromMatrixPosition(U.matrixWorld).applyMatrix4(Te);
                        const Ge = ge.update(U)
                          , Ze = U.material;
                        Ze.visible && S.push(U, Ge, Ze, ie, Ye.z, null)
                    }
                } else if ((U.isMesh || U.isLine || U.isPoints) && (!U.frustumCulled || Ue.intersectsObject(U))) {
                    const Ge = ge.update(U)
                      , Ze = U.material;
                    if (re && (U.boundingSphere !== void 0 ? (U.boundingSphere === null && U.computeBoundingSphere(),
                    Ye.copy(U.boundingSphere.center)) : (Ge.boundingSphere === null && Ge.computeBoundingSphere(),
                    Ye.copy(Ge.boundingSphere.center)),
                    Ye.applyMatrix4(U.matrixWorld).applyMatrix4(Te)),
                    Array.isArray(Ze)) {
                        const qe = Ge.groups;
                        for (let st = 0, lt = qe.length; st < lt; st++) {
                            const it = qe[st]
                              , Lt = Ze[it.materialIndex];
                            Lt && Lt.visible && S.push(U, Ge, Lt, ie, Ye.z, it)
                        }
                    } else
                        Ze.visible && S.push(U, Ge, Ze, ie, Ye.z, null)
                }
            }
            const Re = U.children;
            for (let Ge = 0, Ze = Re.length; Ge < Ze; Ge++)
                Rl(Re[Ge], Y, ie, re)
        }
        function Pl(U, Y, ie, re) {
            const J = U.opaque
              , Re = U.transmissive
              , Ge = U.transparent;
            _.setupLightsView(ie),
            se === !0 && ft.setGlobalState(w.clippingPlanes, ie),
            re && fe.viewport(P.copy(re)),
            J.length > 0 && Qo(J, Y, ie),
            Re.length > 0 && Qo(Re, Y, ie),
            Ge.length > 0 && Qo(Ge, Y, ie),
            fe.buffers.depth.setTest(!0),
            fe.buffers.depth.setMask(!0),
            fe.buffers.color.setMask(!0),
            fe.setPolygonOffset(!1)
        }
        function Jo(U, Y, ie, re) {
            if ((ie.isScene === !0 ? ie.overrideMaterial : null) !== null)
                return;
            _.state.transmissionRenderTarget[re.id] === void 0 && (_.state.transmissionRenderTarget[re.id] = new qi(1,1,{
                generateMipmaps: !0,
                type: ye.has("EXT_color_buffer_half_float") || ye.has("EXT_color_buffer_float") ? Xo : fr,
                minFilter: Cr,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: kt.workingColorSpace
            }));
            const Re = _.state.transmissionRenderTarget[re.id]
              , Ge = re.viewport || P;
            Re.setSize(Ge.z, Ge.w);
            const Ze = w.getRenderTarget();
            w.setRenderTarget(Re),
            w.getClearColor(X),
            G = w.getClearAlpha(),
            G < 1 && w.setClearColor(16777215, .5),
            ze ? We.render(ie) : w.clear();
            const qe = w.toneMapping;
            w.toneMapping = Pr;
            const st = re.viewport;
            if (re.viewport !== void 0 && (re.viewport = void 0),
            _.setupLightsView(re),
            se === !0 && ft.setGlobalState(w.clippingPlanes, re),
            Qo(U, ie, re),
            Be.updateMultisampleRenderTarget(Re),
            Be.updateRenderTargetMipmap(Re),
            ye.has("WEBGL_multisampled_render_to_texture") === !1) {
                let lt = !1;
                for (let it = 0, Lt = Y.length; it < Lt; it++) {
                    const Wt = Y[it]
                      , zt = Wt.object
                      , tn = Wt.geometry
                      , nt = Wt.material
                      , Ie = Wt.group;
                    if (nt.side === lr && zt.layers.test(re.layers)) {
                        const jt = nt.side;
                        nt.side = ri,
                        nt.needsUpdate = !0,
                        ds(zt, ie, re, tn, nt, Ie),
                        nt.side = jt,
                        nt.needsUpdate = !0,
                        lt = !0
                    }
                }
                lt === !0 && (Be.updateMultisampleRenderTarget(Re),
                Be.updateRenderTargetMipmap(Re))
            }
            w.setRenderTarget(Ze),
            w.setClearColor(X, G),
            st !== void 0 && (re.viewport = st),
            w.toneMapping = qe
        }
        function Qo(U, Y, ie) {
            const re = Y.isScene === !0 ? Y.overrideMaterial : null;
            for (let J = 0, Re = U.length; J < Re; J++) {
                const Ge = U[J]
                  , Ze = Ge.object
                  , qe = Ge.geometry
                  , st = re === null ? Ge.material : re
                  , lt = Ge.group;
                Ze.layers.test(ie.layers) && ds(Ze, Y, ie, qe, st, lt)
            }
        }
        function ds(U, Y, ie, re, J, Re) {
            U.onBeforeRender(w, Y, ie, re, J, Re),
            U.modelViewMatrix.multiplyMatrices(ie.matrixWorldInverse, U.matrixWorld),
            U.normalMatrix.getNormalMatrix(U.modelViewMatrix),
            J.transparent === !0 && J.side === lr && J.forceSinglePass === !1 ? (J.side = ri,
            J.needsUpdate = !0,
            w.renderBufferDirect(ie, Y, re, J, U, Re),
            J.side = Dr,
            J.needsUpdate = !0,
            w.renderBufferDirect(ie, Y, re, J, U, Re),
            J.side = lr) : w.renderBufferDirect(ie, Y, re, J, U, Re),
            U.onAfterRender(w, Y, ie, re, J, Re)
        }
        function ea(U, Y, ie) {
            Y.isScene !== !0 && (Y = Qe);
            const re = Le.get(U)
              , J = _.state.lights
              , Re = _.state.shadowsArray
              , Ge = J.state.version
              , Ze = ve.getParameters(U, J.state, Re, Y, ie)
              , qe = ve.getProgramCacheKey(Ze);
            let st = re.programs;
            re.environment = U.isMeshStandardMaterial ? Y.environment : null,
            re.fog = Y.fog,
            re.envMap = (U.isMeshStandardMaterial ? L : H).get(U.envMap || re.environment),
            re.envMapRotation = re.environment !== null && U.envMap === null ? Y.environmentRotation : U.envMapRotation,
            st === void 0 && (U.addEventListener("dispose", ut),
            st = new Map,
            re.programs = st);
            let lt = st.get(qe);
            if (lt !== void 0) {
                if (re.currentProgram === lt && re.lightsStateVersion === Ge)
                    return Qu(U, Ze),
                    lt
            } else
                Ze.uniforms = ve.getUniforms(U),
                U.onBeforeCompile(Ze, w),
                lt = ve.acquireProgram(Ze, qe),
                st.set(qe, lt),
                re.uniforms = Ze.uniforms;
            const it = re.uniforms;
            return (!U.isShaderMaterial && !U.isRawShaderMaterial || U.clipping === !0) && (it.clippingPlanes = ft.uniform),
            Qu(U, Ze),
            re.needsLights = Pm(U),
            re.lightsStateVersion = Ge,
            re.needsLights && (it.ambientLightColor.value = J.state.ambient,
            it.lightProbe.value = J.state.probe,
            it.directionalLights.value = J.state.directional,
            it.directionalLightShadows.value = J.state.directionalShadow,
            it.spotLights.value = J.state.spot,
            it.spotLightShadows.value = J.state.spotShadow,
            it.rectAreaLights.value = J.state.rectArea,
            it.ltc_1.value = J.state.rectAreaLTC1,
            it.ltc_2.value = J.state.rectAreaLTC2,
            it.pointLights.value = J.state.point,
            it.pointLightShadows.value = J.state.pointShadow,
            it.hemisphereLights.value = J.state.hemi,
            it.directionalShadowMap.value = J.state.directionalShadowMap,
            it.directionalShadowMatrix.value = J.state.directionalShadowMatrix,
            it.spotShadowMap.value = J.state.spotShadowMap,
            it.spotLightMatrix.value = J.state.spotLightMatrix,
            it.spotLightMap.value = J.state.spotLightMap,
            it.pointShadowMap.value = J.state.pointShadowMap,
            it.pointShadowMatrix.value = J.state.pointShadowMatrix),
            re.currentProgram = lt,
            re.uniformsList = null,
            lt
        }
        function Ju(U) {
            if (U.uniformsList === null) {
                const Y = U.currentProgram.getUniforms();
                U.uniformsList = hh.seqWithValue(Y.seq, U.uniforms)
            }
            return U.uniformsList
        }
        function Qu(U, Y) {
            const ie = Le.get(U);
            ie.outputColorSpace = Y.outputColorSpace,
            ie.batching = Y.batching,
            ie.batchingColor = Y.batchingColor,
            ie.instancing = Y.instancing,
            ie.instancingColor = Y.instancingColor,
            ie.instancingMorph = Y.instancingMorph,
            ie.skinning = Y.skinning,
            ie.morphTargets = Y.morphTargets,
            ie.morphNormals = Y.morphNormals,
            ie.morphColors = Y.morphColors,
            ie.morphTargetsCount = Y.morphTargetsCount,
            ie.numClippingPlanes = Y.numClippingPlanes,
            ie.numIntersection = Y.numClipIntersection,
            ie.vertexAlphas = Y.vertexAlphas,
            ie.vertexTangents = Y.vertexTangents,
            ie.toneMapping = Y.toneMapping
        }
        function Am(U, Y, ie, re, J) {
            Y.isScene !== !0 && (Y = Qe),
            Be.resetTextureUnits();
            const Re = Y.fog
              , Ge = re.isMeshStandardMaterial ? Y.environment : null
              , Ze = A === null ? w.outputColorSpace : A.isXRRenderTarget === !0 ? A.texture.colorSpace : us
              , qe = (re.isMeshStandardMaterial ? L : H).get(re.envMap || Ge)
              , st = re.vertexColors === !0 && !!ie.attributes.color && ie.attributes.color.itemSize === 4
              , lt = !!ie.attributes.tangent && (!!re.normalMap || re.anisotropy > 0)
              , it = !!ie.morphAttributes.position
              , Lt = !!ie.morphAttributes.normal
              , Wt = !!ie.morphAttributes.color;
            let zt = Pr;
            re.toneMapped && (A === null || A.isXRRenderTarget === !0) && (zt = w.toneMapping);
            const tn = ie.morphAttributes.position || ie.morphAttributes.normal || ie.morphAttributes.color
              , nt = tn !== void 0 ? tn.length : 0
              , Ie = Le.get(re)
              , jt = _.state.lights;
            if (se === !0 && (ue === !0 || U !== I)) {
                const Nn = U === I && re.id === F;
                ft.setState(re, U, Nn)
            }
            let ht = !1;
            re.version === Ie.__version ? (Ie.needsLights && Ie.lightsStateVersion !== jt.state.version || Ie.outputColorSpace !== Ze || J.isBatchedMesh && Ie.batching === !1 || !J.isBatchedMesh && Ie.batching === !0 || J.isBatchedMesh && Ie.batchingColor === !0 && J.colorTexture === null || J.isBatchedMesh && Ie.batchingColor === !1 && J.colorTexture !== null || J.isInstancedMesh && Ie.instancing === !1 || !J.isInstancedMesh && Ie.instancing === !0 || J.isSkinnedMesh && Ie.skinning === !1 || !J.isSkinnedMesh && Ie.skinning === !0 || J.isInstancedMesh && Ie.instancingColor === !0 && J.instanceColor === null || J.isInstancedMesh && Ie.instancingColor === !1 && J.instanceColor !== null || J.isInstancedMesh && Ie.instancingMorph === !0 && J.morphTexture === null || J.isInstancedMesh && Ie.instancingMorph === !1 && J.morphTexture !== null || Ie.envMap !== qe || re.fog === !0 && Ie.fog !== Re || Ie.numClippingPlanes !== void 0 && (Ie.numClippingPlanes !== ft.numPlanes || Ie.numIntersection !== ft.numIntersection) || Ie.vertexAlphas !== st || Ie.vertexTangents !== lt || Ie.morphTargets !== it || Ie.morphNormals !== Lt || Ie.morphColors !== Wt || Ie.toneMapping !== zt || Ie.morphTargetsCount !== nt) && (ht = !0) : (ht = !0,
            Ie.__version = re.version);
            let Xt = Ie.currentProgram;
            ht === !0 && (Xt = ea(re, Y, J));
            let ai = !1
              , pn = !1
              , Tn = !1;
            const qt = Xt.getUniforms()
              , Qi = Ie.uniforms;
            if (fe.useProgram(Xt.program) && (ai = !0,
            pn = !0,
            Tn = !0),
            re.id !== F && (F = re.id,
            pn = !0),
            ai || I !== U) {
                qt.setValue(k, "projectionMatrix", U.projectionMatrix),
                qt.setValue(k, "viewMatrix", U.matrixWorldInverse);
                const Nn = qt.map.cameraPosition;
                Nn !== void 0 && Nn.setValue(k, Me.setFromMatrixPosition(U.matrixWorld)),
                Pe.logarithmicDepthBuffer && qt.setValue(k, "logDepthBufFC", 2 / (Math.log(U.far + 1) / Math.LN2)),
                (re.isMeshPhongMaterial || re.isMeshToonMaterial || re.isMeshLambertMaterial || re.isMeshBasicMaterial || re.isMeshStandardMaterial || re.isShaderMaterial) && qt.setValue(k, "isOrthographic", U.isOrthographicCamera === !0),
                I !== U && (I = U,
                pn = !0,
                Tn = !0)
            }
            if (J.isSkinnedMesh) {
                qt.setOptional(k, J, "bindMatrix"),
                qt.setOptional(k, J, "bindMatrixInverse");
                const Nn = J.skeleton;
                Nn && (Nn.boneTexture === null && Nn.computeBoneTexture(),
                qt.setValue(k, "boneTexture", Nn.boneTexture, Be))
            }
            J.isBatchedMesh && (qt.setOptional(k, J, "batchingTexture"),
            qt.setValue(k, "batchingTexture", J._matricesTexture, Be),
            qt.setOptional(k, J, "batchingIdTexture"),
            qt.setValue(k, "batchingIdTexture", J._indirectTexture, Be),
            qt.setOptional(k, J, "batchingColorTexture"),
            J._colorsTexture !== null && qt.setValue(k, "batchingColorTexture", J._colorsTexture, Be));
            const ta = ie.morphAttributes;
            if ((ta.position !== void 0 || ta.normal !== void 0 || ta.color !== void 0) && Ct.update(J, ie, Xt),
            (pn || Ie.receiveShadow !== J.receiveShadow) && (Ie.receiveShadow = J.receiveShadow,
            qt.setValue(k, "receiveShadow", J.receiveShadow)),
            re.isMeshGouraudMaterial && re.envMap !== null && (Qi.envMap.value = qe,
            Qi.flipEnvMap.value = qe.isCubeTexture && qe.isRenderTargetTexture === !1 ? -1 : 1),
            re.isMeshStandardMaterial && re.envMap === null && Y.environment !== null && (Qi.envMapIntensity.value = Y.environmentIntensity),
            pn && (qt.setValue(k, "toneMappingExposure", w.toneMappingExposure),
            Ie.needsLights && Rm(Qi, Tn),
            Re && re.fog === !0 && Ke.refreshFogUniforms(Qi, Re),
            Ke.refreshMaterialUniforms(Qi, re, oe, K, _.state.transmissionRenderTarget[U.id]),
            hh.upload(k, Ju(Ie), Qi, Be)),
            re.isShaderMaterial && re.uniformsNeedUpdate === !0 && (hh.upload(k, Ju(Ie), Qi, Be),
            re.uniformsNeedUpdate = !1),
            re.isSpriteMaterial && qt.setValue(k, "center", J.center),
            qt.setValue(k, "modelViewMatrix", J.modelViewMatrix),
            qt.setValue(k, "normalMatrix", J.normalMatrix),
            qt.setValue(k, "modelMatrix", J.matrixWorld),
            re.isShaderMaterial || re.isRawShaderMaterial) {
                const Nn = re.uniformsGroups;
                for (let na = 0, _i = Nn.length; na < _i; na++) {
                    const ef = Nn[na];
                    Gt.update(ef, Xt),
                    Gt.bind(ef, Xt)
                }
            }
            return Xt
        }
        function Rm(U, Y) {
            U.ambientLightColor.needsUpdate = Y,
            U.lightProbe.needsUpdate = Y,
            U.directionalLights.needsUpdate = Y,
            U.directionalLightShadows.needsUpdate = Y,
            U.pointLights.needsUpdate = Y,
            U.pointLightShadows.needsUpdate = Y,
            U.spotLights.needsUpdate = Y,
            U.spotLightShadows.needsUpdate = Y,
            U.rectAreaLights.needsUpdate = Y,
            U.hemisphereLights.needsUpdate = Y
        }
        function Pm(U) {
            return U.isMeshLambertMaterial || U.isMeshToonMaterial || U.isMeshPhongMaterial || U.isMeshStandardMaterial || U.isShadowMaterial || U.isShaderMaterial && U.lights === !0
        }
        this.getActiveCubeFace = function() {
            return O
        }
        ,
        this.getActiveMipmapLevel = function() {
            return R
        }
        ,
        this.getRenderTarget = function() {
            return A
        }
        ,
        this.setRenderTargetTextures = function(U, Y, ie) {
            Le.get(U.texture).__webglTexture = Y,
            Le.get(U.depthTexture).__webglTexture = ie;
            const re = Le.get(U);
            re.__hasExternalTextures = !0,
            re.__autoAllocateDepthBuffer = ie === void 0,
            re.__autoAllocateDepthBuffer || ye.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            re.__useRenderToTexture = !1)
        }
        ,
        this.setRenderTargetFramebuffer = function(U, Y) {
            const ie = Le.get(U);
            ie.__webglFramebuffer = Y,
            ie.__useDefaultFramebuffer = Y === void 0
        }
        ,
        this.setRenderTarget = function(U, Y=0, ie=0) {
            A = U,
            O = Y,
            R = ie;
            let re = !0
              , J = null
              , Re = !1
              , Ge = !1;
            if (U) {
                const qe = Le.get(U);
                qe.__useDefaultFramebuffer !== void 0 ? (fe.bindFramebuffer(k.FRAMEBUFFER, null),
                re = !1) : qe.__webglFramebuffer === void 0 ? Be.setupRenderTarget(U) : qe.__hasExternalTextures && Be.rebindTextures(U, Le.get(U.texture).__webglTexture, Le.get(U.depthTexture).__webglTexture);
                const st = U.texture;
                (st.isData3DTexture || st.isDataArrayTexture || st.isCompressedArrayTexture) && (Ge = !0);
                const lt = Le.get(U).__webglFramebuffer;
                U.isWebGLCubeRenderTarget ? (Array.isArray(lt[Y]) ? J = lt[Y][ie] : J = lt[Y],
                Re = !0) : U.samples > 0 && Be.useMultisampledRTT(U) === !1 ? J = Le.get(U).__webglMultisampledFramebuffer : Array.isArray(lt) ? J = lt[ie] : J = lt,
                P.copy(U.viewport),
                D.copy(U.scissor),
                W = U.scissorTest
            } else
                P.copy(Q).multiplyScalar(oe).floor(),
                D.copy(ce).multiplyScalar(oe).floor(),
                W = be;
            if (fe.bindFramebuffer(k.FRAMEBUFFER, J) && re && fe.drawBuffers(U, J),
            fe.viewport(P),
            fe.scissor(D),
            fe.setScissorTest(W),
            Re) {
                const qe = Le.get(U.texture);
                k.framebufferTexture2D(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_CUBE_MAP_POSITIVE_X + Y, qe.__webglTexture, ie)
            } else if (Ge) {
                const qe = Le.get(U.texture)
                  , st = Y || 0;
                k.framebufferTextureLayer(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, qe.__webglTexture, ie || 0, st)
            }
            F = -1
        }
        ,
        this.readRenderTargetPixels = function(U, Y, ie, re, J, Re, Ge) {
            if (!(U && U.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Ze = Le.get(U).__webglFramebuffer;
            if (U.isWebGLCubeRenderTarget && Ge !== void 0 && (Ze = Ze[Ge]),
            Ze) {
                fe.bindFramebuffer(k.FRAMEBUFFER, Ze);
                try {
                    const qe = U.texture
                      , st = qe.format
                      , lt = qe.type;
                    if (!Pe.textureFormatReadable(st)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!Pe.textureTypeReadable(lt)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    Y >= 0 && Y <= U.width - re && ie >= 0 && ie <= U.height - J && k.readPixels(Y, ie, re, J, pt.convert(st), pt.convert(lt), Re)
                } finally {
                    const qe = A !== null ? Le.get(A).__webglFramebuffer : null;
                    fe.bindFramebuffer(k.FRAMEBUFFER, qe)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(U, Y, ie, re, J, Re, Ge) {
            if (!(U && U.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Ze = Le.get(U).__webglFramebuffer;
            if (U.isWebGLCubeRenderTarget && Ge !== void 0 && (Ze = Ze[Ge]),
            Ze) {
                fe.bindFramebuffer(k.FRAMEBUFFER, Ze);
                try {
                    const qe = U.texture
                      , st = qe.format
                      , lt = qe.type;
                    if (!Pe.textureFormatReadable(st))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!Pe.textureTypeReadable(lt))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    if (Y >= 0 && Y <= U.width - re && ie >= 0 && ie <= U.height - J) {
                        const it = k.createBuffer();
                        k.bindBuffer(k.PIXEL_PACK_BUFFER, it),
                        k.bufferData(k.PIXEL_PACK_BUFFER, Re.byteLength, k.STREAM_READ),
                        k.readPixels(Y, ie, re, J, pt.convert(st), pt.convert(lt), 0),
                        k.flush();
                        const Lt = k.fenceSync(k.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        await f7(k, Lt, 4);
                        try {
                            k.bindBuffer(k.PIXEL_PACK_BUFFER, it),
                            k.getBufferSubData(k.PIXEL_PACK_BUFFER, 0, Re)
                        } finally {
                            k.deleteBuffer(it),
                            k.deleteSync(Lt)
                        }
                        return Re
                    }
                } finally {
                    const qe = A !== null ? Le.get(A).__webglFramebuffer : null;
                    fe.bindFramebuffer(k.FRAMEBUFFER, qe)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(U, Y=null, ie=0) {
            U.isTexture !== !0 && (console.warn("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
            Y = arguments[0] || null,
            U = arguments[1]);
            const re = Math.pow(2, -ie)
              , J = Math.floor(U.image.width * re)
              , Re = Math.floor(U.image.height * re)
              , Ge = Y !== null ? Y.x : 0
              , Ze = Y !== null ? Y.y : 0;
            Be.setTexture2D(U, 0),
            k.copyTexSubImage2D(k.TEXTURE_2D, ie, 0, 0, Ge, Ze, J, Re),
            fe.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(U, Y, ie=null, re=null, J=0) {
            U.isTexture !== !0 && (console.warn("WebGLRenderer: copyTextureToTexture function signature has changed."),
            re = arguments[0] || null,
            U = arguments[1],
            Y = arguments[2],
            J = arguments[3] || 0,
            ie = null);
            let Re, Ge, Ze, qe, st, lt;
            ie !== null ? (Re = ie.max.x - ie.min.x,
            Ge = ie.max.y - ie.min.y,
            Ze = ie.min.x,
            qe = ie.min.y) : (Re = U.image.width,
            Ge = U.image.height,
            Ze = 0,
            qe = 0),
            re !== null ? (st = re.x,
            lt = re.y) : (st = 0,
            lt = 0);
            const it = pt.convert(Y.format)
              , Lt = pt.convert(Y.type);
            Be.setTexture2D(Y, 0),
            k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL, Y.flipY),
            k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha),
            k.pixelStorei(k.UNPACK_ALIGNMENT, Y.unpackAlignment);
            const Wt = k.getParameter(k.UNPACK_ROW_LENGTH)
              , zt = k.getParameter(k.UNPACK_IMAGE_HEIGHT)
              , tn = k.getParameter(k.UNPACK_SKIP_PIXELS)
              , nt = k.getParameter(k.UNPACK_SKIP_ROWS)
              , Ie = k.getParameter(k.UNPACK_SKIP_IMAGES)
              , jt = U.isCompressedTexture ? U.mipmaps[J] : U.image;
            k.pixelStorei(k.UNPACK_ROW_LENGTH, jt.width),
            k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, jt.height),
            k.pixelStorei(k.UNPACK_SKIP_PIXELS, Ze),
            k.pixelStorei(k.UNPACK_SKIP_ROWS, qe),
            U.isDataTexture ? k.texSubImage2D(k.TEXTURE_2D, J, st, lt, Re, Ge, it, Lt, jt.data) : U.isCompressedTexture ? k.compressedTexSubImage2D(k.TEXTURE_2D, J, st, lt, jt.width, jt.height, it, jt.data) : k.texSubImage2D(k.TEXTURE_2D, J, st, lt, Re, Ge, it, Lt, jt),
            k.pixelStorei(k.UNPACK_ROW_LENGTH, Wt),
            k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, zt),
            k.pixelStorei(k.UNPACK_SKIP_PIXELS, tn),
            k.pixelStorei(k.UNPACK_SKIP_ROWS, nt),
            k.pixelStorei(k.UNPACK_SKIP_IMAGES, Ie),
            J === 0 && Y.generateMipmaps && k.generateMipmap(k.TEXTURE_2D),
            fe.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(U, Y, ie=null, re=null, J=0) {
            U.isTexture !== !0 && (console.warn("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
            ie = arguments[0] || null,
            re = arguments[1] || null,
            U = arguments[2],
            Y = arguments[3],
            J = arguments[4] || 0);
            let Re, Ge, Ze, qe, st, lt, it, Lt, Wt;
            const zt = U.isCompressedTexture ? U.mipmaps[J] : U.image;
            ie !== null ? (Re = ie.max.x - ie.min.x,
            Ge = ie.max.y - ie.min.y,
            Ze = ie.max.z - ie.min.z,
            qe = ie.min.x,
            st = ie.min.y,
            lt = ie.min.z) : (Re = zt.width,
            Ge = zt.height,
            Ze = zt.depth,
            qe = 0,
            st = 0,
            lt = 0),
            re !== null ? (it = re.x,
            Lt = re.y,
            Wt = re.z) : (it = 0,
            Lt = 0,
            Wt = 0);
            const tn = pt.convert(Y.format)
              , nt = pt.convert(Y.type);
            let Ie;
            if (Y.isData3DTexture)
                Be.setTexture3D(Y, 0),
                Ie = k.TEXTURE_3D;
            else if (Y.isDataArrayTexture || Y.isCompressedArrayTexture)
                Be.setTexture2DArray(Y, 0),
                Ie = k.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL, Y.flipY),
            k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha),
            k.pixelStorei(k.UNPACK_ALIGNMENT, Y.unpackAlignment);
            const jt = k.getParameter(k.UNPACK_ROW_LENGTH)
              , ht = k.getParameter(k.UNPACK_IMAGE_HEIGHT)
              , Xt = k.getParameter(k.UNPACK_SKIP_PIXELS)
              , ai = k.getParameter(k.UNPACK_SKIP_ROWS)
              , pn = k.getParameter(k.UNPACK_SKIP_IMAGES);
            k.pixelStorei(k.UNPACK_ROW_LENGTH, zt.width),
            k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, zt.height),
            k.pixelStorei(k.UNPACK_SKIP_PIXELS, qe),
            k.pixelStorei(k.UNPACK_SKIP_ROWS, st),
            k.pixelStorei(k.UNPACK_SKIP_IMAGES, lt),
            U.isDataTexture || U.isData3DTexture ? k.texSubImage3D(Ie, J, it, Lt, Wt, Re, Ge, Ze, tn, nt, zt.data) : Y.isCompressedArrayTexture ? k.compressedTexSubImage3D(Ie, J, it, Lt, Wt, Re, Ge, Ze, tn, zt.data) : k.texSubImage3D(Ie, J, it, Lt, Wt, Re, Ge, Ze, tn, nt, zt),
            k.pixelStorei(k.UNPACK_ROW_LENGTH, jt),
            k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, ht),
            k.pixelStorei(k.UNPACK_SKIP_PIXELS, Xt),
            k.pixelStorei(k.UNPACK_SKIP_ROWS, ai),
            k.pixelStorei(k.UNPACK_SKIP_IMAGES, pn),
            J === 0 && Y.generateMipmaps && k.generateMipmap(Ie),
            fe.unbindTexture()
        }
        ,
        this.initRenderTarget = function(U) {
            Le.get(U).__webglFramebuffer === void 0 && Be.setupRenderTarget(U)
        }
        ,
        this.initTexture = function(U) {
            U.isCubeTexture ? Be.setTextureCube(U, 0) : U.isData3DTexture ? Be.setTexture3D(U, 0) : U.isDataArrayTexture || U.isCompressedArrayTexture ? Be.setTexture2DArray(U, 0) : Be.setTexture2D(U, 0),
            fe.unbindTexture()
        }
        ,
        this.resetState = function() {
            O = 0,
            R = 0,
            A = null,
            fe.reset(),
            Mt.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return Tr
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === Qp ? "display-p3" : "srgb",
        t.unpackColorSpace = kt.workingColorSpace === Du ? "display-p3" : "srgb"
    }
}
class im {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new Oe(e),
        this.density = t
    }
    clone() {
        return new im(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class rm {
    constructor(e, t=1, i=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Oe(e),
        this.near = t,
        this.far = i
    }
    clone() {
        return new rm(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class ip extends It {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Ri,
        this.environmentIntensity = 1,
        this.environmentRotation = new Ri,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
class sm {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = cu,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = Ai()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return dx("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.stride,
        i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ai()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , i = new this.constructor(t,this.stride);
        return i.setUsage(this.usage),
        i
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ai()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const Jn = new B;
class Ho {
    constructor(e, t, i, r=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            Jn.fromBufferAttribute(this, t),
            Jn.applyMatrix4(e),
            this.setXYZ(t, Jn.x, Jn.y, Jn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Jn.fromBufferAttribute(this, t),
            Jn.applyNormalMatrix(e),
            this.setXYZ(t, Jn.x, Jn.y, Jn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Jn.fromBufferAttribute(this, t),
            Jn.transformDirection(e),
            this.setXYZ(t, Jn.x, Jn.y, Jn.z);
        return this
    }
    getComponent(e, t) {
        let i = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (i = ti(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = _t(i, this.array)),
        this.data.array[e * this.data.stride + this.offset + t] = i,
        this
    }
    setX(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = _t(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = ti(t, this.array)),
        t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array),
        r = _t(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = _t(t, this.array),
        i = _t(i, this.array),
        r = _t(r, this.array),
        s = _t(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return new Vt(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Ho(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class Mx extends Fn {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let Da;
const lc = new B
  , Ua = new B
  , Fa = new B
  , ka = new he
  , cc = new he
  , Vb = new ct
  , Ed = new B
  , uc = new B
  , Cd = new B
  , OS = new he
  , Pg = new he
  , DS = new he;
class Hb extends It {
    constructor(e=new Mx) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        Da === void 0) {
            Da = new St;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , i = new sm(t,5);
            Da.setIndex([0, 1, 2, 0, 2, 3]),
            Da.setAttribute("position", new Ho(i,3,0,!1)),
            Da.setAttribute("uv", new Ho(i,2,3,!1))
        }
        this.geometry = Da,
        this.material = e,
        this.center = new he(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        Ua.setFromMatrixScale(this.matrixWorld),
        Vb.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        Fa.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Ua.multiplyScalar(-Fa.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i),
        r = Math.sin(i));
        const o = this.center;
        Td(Ed.set(-.5, -.5, 0), Fa, o, Ua, r, s),
        Td(uc.set(.5, -.5, 0), Fa, o, Ua, r, s),
        Td(Cd.set(.5, .5, 0), Fa, o, Ua, r, s),
        OS.set(0, 0),
        Pg.set(1, 0),
        DS.set(1, 1);
        let l = e.ray.intersectTriangle(Ed, uc, Cd, !1, lc);
        if (l === null && (Td(uc.set(-.5, .5, 0), Fa, o, Ua, r, s),
        Pg.set(0, 1),
        l = e.ray.intersectTriangle(Ed, Cd, uc, !1, lc),
        l === null))
            return;
        const u = e.ray.origin.distanceTo(lc);
        u < e.near || u > e.far || t.push({
            distance: u,
            point: lc.clone(),
            uv: Ci.getInterpolation(lc, Ed, uc, Cd, OS, Pg, DS, new he),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function Td(n, e, t, i, r, s) {
    ka.subVectors(n, t).addScalar(.5).multiply(i),
    r !== void 0 ? (cc.x = s * ka.x - r * ka.y,
    cc.y = r * ka.x + s * ka.y) : cc.copy(ka),
    n.copy(e),
    n.x += cc.x,
    n.y += cc.y,
    n.applyMatrix4(Vb)
}
const Ad = new B
  , US = new B;
class Gb extends It {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, i=0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++)
            ;
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1,
            r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis),
                e < s)
                    break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            Ad.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(Ad);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            Ad.setFromMatrixPosition(e.matrixWorld),
            US.setFromMatrixPosition(this.matrixWorld);
            const i = Ad.distanceTo(US) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1,
            s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis),
                i >= o)
                    t[r - 1].object.visible = !1,
                    t[r].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = r - 1; r < s; r++)
                t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const FS = new B
  , kS = new Bt
  , BS = new Bt
  , wD = new B
  , zS = new ct
  , Rd = new B
  , Ig = new Yn
  , VS = new ct
  , Lg = new El;
class Wb extends Sn {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = N1,
        this.bindMatrix = new ct,
        this.bindMatrixInverse = new ct,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new si),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, Rd),
            this.boundingBox.expandByPoint(Rd)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new Yn),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, Rd),
            this.boundingSphere.expandByPoint(Rd)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const i = this.material
          , r = this.matrixWorld;
        i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        Ig.copy(this.boundingSphere),
        Ig.applyMatrix4(r),
        e.ray.intersectsSphere(Ig) !== !1 && (VS.copy(r).invert(),
        Lg.copy(e.ray).applyMatrix4(VS),
        !(this.boundingBox !== null && Lg.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Lg)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Bt
          , t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === N1 ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === db ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton
          , r = this.geometry;
        kS.fromBufferAttribute(r.attributes.skinIndex, e),
        BS.fromBufferAttribute(r.attributes.skinWeight, e),
        FS.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = BS.getComponent(s);
            if (o !== 0) {
                const l = kS.getComponent(s);
                zS.multiplyMatrices(i.bones[l].matrixWorld, i.boneInverses[l]),
                t.addScaledVector(wD.copy(FS).applyMatrix4(zS), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class wx extends It {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Ir extends en {
    constructor(e=null, t=1, i=1, r, s, o, l, u, f=Ln, d=Ln, h, m) {
        super(null, o, l, u, f, d, r, s, h, m),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const HS = new ct
  , bD = new ct;
class om {
    constructor(e=[], t=[]) {
        this.uuid = Ai(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++)
                this.boneInverses.push(new ct)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new ct;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , i = this.boneMatrices
          , r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const l = e[s] ? e[s].matrixWorld : bD;
            HS.multiplyMatrices(l, t[s]),
            HS.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new om(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Ir(t,e,e,qn,ii);
        return i.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = i,
        this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e)
                return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new wx),
            this.bones.push(o),
            this.boneInverses.push(new ct().fromArray(e.boneInverses[i]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const l = i[r];
            e.boneInverses.push(l.toArray())
        }
        return e
    }
}
class ml extends Vt {
    constructor(e, t, i, r=1) {
        super(e, t, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const Ba = new ct
  , GS = new ct
  , Pd = []
  , WS = new si
  , ED = new ct
  , fc = new Sn
  , dc = new Yn;
class jb extends Sn {
    constructor(e, t, i) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new ml(new Float32Array(i * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = i,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let r = 0; r < i; r++)
            this.setMatrixAt(r, ED)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new si),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Ba),
            WS.copy(e.boundingBox).applyMatrix4(Ba),
            this.boundingBox.union(WS)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new Yn),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Ba),
            dc.copy(e.boundingSphere).applyMatrix4(Ba),
            this.boundingSphere.union(dc)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const i = t.morphTargetInfluences
          , r = this.morphTexture.source.data.data
          , s = i.length + 1
          , o = e * s + 1;
        for (let l = 0; l < i.length; l++)
            i[l] = r[o + l]
    }
    raycast(e, t) {
        const i = this.matrixWorld
          , r = this.count;
        if (fc.geometry = this.geometry,
        fc.material = this.material,
        fc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        dc.copy(this.boundingSphere),
        dc.applyMatrix4(i),
        e.ray.intersectsSphere(dc) !== !1))
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, Ba),
                GS.multiplyMatrices(i, Ba),
                fc.matrixWorld = GS,
                fc.raycast(e, Pd);
                for (let o = 0, l = Pd.length; o < l; o++) {
                    const u = Pd[o];
                    u.instanceId = s,
                    u.object = this,
                    t.push(u)
                }
                Pd.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new ml(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const i = t.morphTargetInfluences
          , r = i.length + 1;
        this.morphTexture === null && (this.morphTexture = new Ir(new Float32Array(r * this.count),r,this.count,Yp,ii));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let f = 0; f < i.length; f++)
            o += i[f];
        const l = this.geometry.morphTargetsRelative ? 1 : 1 - o
          , u = r * e;
        s[u] = l,
        s.set(i, u + 1)
    }
    updateMorphTargets() {}
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this.morphTexture !== null && (this.morphTexture.dispose(),
        this.morphTexture = null),
        this
    }
}
function CD(n, e) {
    return n.z - e.z
}
function TD(n, e) {
    return e.z - n.z
}
class AD {
    constructor() {
        this.index = 0,
        this.pool = [],
        this.list = []
    }
    push(e, t, i) {
        const r = this.pool
          , s = this.list;
        this.index >= r.length && r.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
        });
        const o = r[this.index];
        s.push(o),
        this.index++,
        o.start = e.start,
        o.count = e.count,
        o.z = t,
        o.index = i
    }
    reset() {
        this.list.length = 0,
        this.index = 0
    }
}
const Rs = new ct
  , Ng = new ct
  , RD = new ct
  , PD = new Oe(1,1,1)
  , jS = new ct
  , Og = new ku
  , Id = new si
  , vo = new Yn
  , hc = new B
  , XS = new B
  , ID = new B
  , Dg = new AD
  , jn = new Sn
  , Ld = [];
function LD(n, e, t=0) {
    const i = e.itemSize;
    if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
        const r = n.count;
        for (let s = 0; s < r; s++)
            for (let o = 0; o < i; o++)
                e.setComponent(s + t, o, n.getComponent(s, o))
    } else
        e.array.set(n.array, t * i);
    e.needsUpdate = !0
}
class Xb extends Sn {
    get maxInstanceCount() {
        return this._maxInstanceCount
    }
    constructor(e, t, i=t * 2, r) {
        super(new St, r),
        this.isBatchedMesh = !0,
        this.perObjectFrustumCulled = !0,
        this.sortObjects = !0,
        this.boundingBox = null,
        this.boundingSphere = null,
        this.customSort = null,
        this._drawInfo = [],
        this._drawRanges = [],
        this._reservedRanges = [],
        this._bounds = [],
        this._maxInstanceCount = e,
        this._maxVertexCount = t,
        this._maxIndexCount = i,
        this._geometryInitialized = !1,
        this._geometryCount = 0,
        this._multiDrawCounts = new Int32Array(e),
        this._multiDrawStarts = new Int32Array(e),
        this._multiDrawCount = 0,
        this._multiDrawInstances = null,
        this._visibilityChanged = !0,
        this._matricesTexture = null,
        this._indirectTexture = null,
        this._colorsTexture = null,
        this._initMatricesTexture(),
        this._initIndirectTexture()
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxInstanceCount * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4)
          , i = new Ir(t,e,e,qn,ii);
        this._matricesTexture = i
    }
    _initIndirectTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Uint32Array(e * e)
          , i = new Ir(t,e,e,Ou,as);
        this._indirectTexture = i
    }
    _initColorsTexture() {
        let e = Math.sqrt(this._maxIndexCount);
        e = Math.ceil(e);
        const t = new Float32Array(e * e * 4).fill(1)
          , i = new Ir(t,e,e,qn,ii);
        i.colorSpace = kt.workingColorSpace,
        this._colorsTexture = i
    }
    _initializeGeometry(e) {
        const t = this.geometry
          , i = this._maxVertexCount
          , r = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const s in e.attributes) {
                const o = e.getAttribute(s)
                  , {array: l, itemSize: u, normalized: f} = o
                  , d = new l.constructor(i * u)
                  , h = new Vt(d,u,f);
                t.setAttribute(s, h)
            }
            if (e.getIndex() !== null) {
                const s = i > 65535 ? new Uint32Array(r) : new Uint16Array(r);
                t.setIndex(new Vt(s,1))
            }
            this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex())
            throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const i in t.attributes) {
            if (!e.hasAttribute(i))
                throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
            const r = e.getAttribute(i)
              , s = t.getAttribute(i);
            if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
                throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    setCustomSort(e) {
        return this.customSort = e,
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new si);
        const e = this._geometryCount
          , t = this.boundingBox
          , i = this._drawInfo;
        t.makeEmpty();
        for (let r = 0; r < e; r++) {
            if (i[r].active === !1)
                continue;
            const s = i[r].geometryIndex;
            this.getMatrixAt(r, Rs),
            this.getBoundingBoxAt(s, Id).applyMatrix4(Rs),
            t.union(Id)
        }
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Yn);
        const e = this.boundingSphere
          , t = this._drawInfo;
        e.makeEmpty();
        for (let i = 0, r = t.length; i < r; i++) {
            if (t[i].active === !1)
                continue;
            const s = t[i].geometryIndex;
            this.getMatrixAt(i, Rs),
            this.getBoundingSphereAt(s, vo).applyMatrix4(Rs),
            e.union(vo)
        }
    }
    addInstance(e) {
        if (this._drawInfo.length >= this._maxInstanceCount)
            throw new Error("BatchedMesh: Maximum item count reached.");
        this._drawInfo.push({
            visible: !0,
            active: !0,
            geometryIndex: e
        });
        const t = this._drawInfo.length - 1
          , i = this._matricesTexture
          , r = i.image.data;
        RD.toArray(r, t * 16),
        i.needsUpdate = !0;
        const s = this._colorsTexture;
        return s && (PD.toArray(s.image.data, t * 4),
        s.needsUpdate = !0),
        t
    }
    addGeometry(e, t=-1, i=-1) {
        if (this._initializeGeometry(e),
        this._validateGeometry(e),
        this._drawInfo.length >= this._maxInstanceCount)
            throw new Error("BatchedMesh: Maximum item count reached.");
        const r = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1
        };
        let s = null;
        const o = this._reservedRanges
          , l = this._drawRanges
          , u = this._bounds;
        this._geometryCount !== 0 && (s = o[o.length - 1]),
        t === -1 ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t,
        s === null ? r.vertexStart = 0 : r.vertexStart = s.vertexStart + s.vertexCount;
        const f = e.getIndex()
          , d = f !== null;
        if (d && (i === -1 ? r.indexCount = f.count : r.indexCount = i,
        s === null ? r.indexStart = 0 : r.indexStart = s.indexStart + s.indexCount),
        r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount)
            throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        const h = this._geometryCount;
        return this._geometryCount++,
        o.push(r),
        l.push({
            start: d ? r.indexStart : r.vertexStart,
            count: -1
        }),
        u.push({
            boxInitialized: !1,
            box: new si,
            sphereInitialized: !1,
            sphere: new Yn
        }),
        this.setGeometryAt(h, e),
        h
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount)
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(t);
        const i = this.geometry
          , r = i.getIndex() !== null
          , s = i.getIndex()
          , o = t.getIndex()
          , l = this._reservedRanges[e];
        if (r && o.count > l.indexCount || t.attributes.position.count > l.vertexCount)
            throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        const u = l.vertexStart
          , f = l.vertexCount;
        for (const g in i.attributes) {
            const x = t.getAttribute(g)
              , S = i.getAttribute(g);
            LD(x, S, u);
            const _ = x.itemSize;
            for (let v = x.count, M = f; v < M; v++) {
                const w = u + v;
                for (let E = 0; E < _; E++)
                    S.setComponent(w, E, 0)
            }
            S.needsUpdate = !0,
            S.addUpdateRange(u * _, f * _)
        }
        if (r) {
            const g = l.indexStart;
            for (let x = 0; x < o.count; x++)
                s.setX(g + x, u + o.getX(x));
            for (let x = o.count, S = l.indexCount; x < S; x++)
                s.setX(g + x, u);
            s.needsUpdate = !0,
            s.addUpdateRange(g, l.indexCount)
        }
        const d = this._bounds[e];
        t.boundingBox !== null ? (d.box.copy(t.boundingBox),
        d.boxInitialized = !0) : d.boxInitialized = !1,
        t.boundingSphere !== null ? (d.sphere.copy(t.boundingSphere),
        d.sphereInitialized = !0) : d.sphereInitialized = !1;
        const h = this._drawRanges[e]
          , m = t.getAttribute("position");
        return h.count = r ? o.count : m.count,
        this._visibilityChanged = !0,
        e
    }
    getBoundingBoxAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const i = this._bounds[e]
          , r = i.box
          , s = this.geometry;
        if (i.boxInitialized === !1) {
            r.makeEmpty();
            const o = s.index
              , l = s.attributes.position
              , u = this._drawRanges[e];
            for (let f = u.start, d = u.start + u.count; f < d; f++) {
                let h = f;
                o && (h = o.getX(h)),
                r.expandByPoint(hc.fromBufferAttribute(l, h))
            }
            i.boxInitialized = !0
        }
        return t.copy(r),
        t
    }
    getBoundingSphereAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const i = this._bounds[e]
          , r = i.sphere
          , s = this.geometry;
        if (i.sphereInitialized === !1) {
            r.makeEmpty(),
            this.getBoundingBoxAt(e, Id),
            Id.getCenter(r.center);
            const o = s.index
              , l = s.attributes.position
              , u = this._drawRanges[e];
            let f = 0;
            for (let d = u.start, h = u.start + u.count; d < h; d++) {
                let m = d;
                o && (m = o.getX(m)),
                hc.fromBufferAttribute(l, m),
                f = Math.max(f, r.center.distanceToSquared(hc))
            }
            r.radius = Math.sqrt(f),
            i.sphereInitialized = !0
        }
        return t.copy(r),
        t
    }
    setMatrixAt(e, t) {
        const i = this._drawInfo
          , r = this._matricesTexture
          , s = this._matricesTexture.image.data;
        return e >= i.length || i[e].active === !1 ? this : (t.toArray(s, e * 16),
        r.needsUpdate = !0,
        this)
    }
    getMatrixAt(e, t) {
        const i = this._drawInfo
          , r = this._matricesTexture.image.data;
        return e >= i.length || i[e].active === !1 ? null : t.fromArray(r, e * 16)
    }
    setColorAt(e, t) {
        this._colorsTexture === null && this._initColorsTexture();
        const i = this._colorsTexture
          , r = this._colorsTexture.image.data
          , s = this._drawInfo;
        return e >= s.length || s[e].active === !1 ? this : (t.toArray(r, e * 4),
        i.needsUpdate = !0,
        this)
    }
    getColorAt(e, t) {
        const i = this._colorsTexture.image.data
          , r = this._drawInfo;
        return e >= r.length || r[e].active === !1 ? null : t.fromArray(i, e * 4)
    }
    setVisibleAt(e, t) {
        const i = this._drawInfo;
        return e >= i.length || i[e].active === !1 || i[e].visible === t ? this : (i[e].visible = t,
        this._visibilityChanged = !0,
        this)
    }
    getVisibleAt(e) {
        const t = this._drawInfo;
        return e >= t.length || t[e].active === !1 ? !1 : t[e].visible
    }
    raycast(e, t) {
        const i = this._drawInfo
          , r = this._drawRanges
          , s = this.matrixWorld
          , o = this.geometry;
        jn.material = this.material,
        jn.geometry.index = o.index,
        jn.geometry.attributes = o.attributes,
        jn.geometry.boundingBox === null && (jn.geometry.boundingBox = new si),
        jn.geometry.boundingSphere === null && (jn.geometry.boundingSphere = new Yn);
        for (let l = 0, u = i.length; l < u; l++) {
            if (!i[l].visible || !i[l].active)
                continue;
            const f = i[l].geometryIndex
              , d = r[f];
            jn.geometry.setDrawRange(d.start, d.count),
            this.getMatrixAt(l, jn.matrixWorld).premultiply(s),
            this.getBoundingBoxAt(f, jn.geometry.boundingBox),
            this.getBoundingSphereAt(f, jn.geometry.boundingSphere),
            jn.raycast(e, Ld);
            for (let h = 0, m = Ld.length; h < m; h++) {
                const g = Ld[h];
                g.object = this,
                g.batchId = l,
                t.push(g)
            }
            Ld.length = 0
        }
        jn.material = null,
        jn.geometry.index = null,
        jn.geometry.attributes = {},
        jn.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e),
        this.geometry = e.geometry.clone(),
        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
        this.sortObjects = e.sortObjects,
        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
        this._drawRanges = e._drawRanges.map(t => ({
            ...t
        })),
        this._reservedRanges = e._reservedRanges.map(t => ({
            ...t
        })),
        this._drawInfo = e._drawInfo.map(t => ({
            ...t
        })),
        this._bounds = e._bounds.map(t => ({
            boxInitialized: t.boxInitialized,
            box: t.box.clone(),
            sphereInitialized: t.sphereInitialized,
            sphere: t.sphere.clone()
        })),
        this._maxInstanceCount = e._maxInstanceCount,
        this._maxVertexCount = e._maxVertexCount,
        this._maxIndexCount = e._maxIndexCount,
        this._geometryInitialized = e._geometryInitialized,
        this._geometryCount = e._geometryCount,
        this._multiDrawCounts = e._multiDrawCounts.slice(),
        this._multiDrawStarts = e._multiDrawStarts.slice(),
        this._matricesTexture = e._matricesTexture.clone(),
        this._matricesTexture.image.data = this._matricesTexture.image.slice(),
        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
        this._colorsTexture.image.data = this._colorsTexture.image.slice()),
        this
    }
    dispose() {
        return this.geometry.dispose(),
        this._matricesTexture.dispose(),
        this._matricesTexture = null,
        this._indirectTexture.dispose(),
        this._indirectTexture = null,
        this._colorsTexture !== null && (this._colorsTexture.dispose(),
        this._colorsTexture = null),
        this
    }
    onBeforeRender(e, t, i, r, s) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
            return;
        const o = r.getIndex()
          , l = o === null ? 1 : o.array.BYTES_PER_ELEMENT
          , u = this._drawInfo
          , f = this._multiDrawStarts
          , d = this._multiDrawCounts
          , h = this._drawRanges
          , m = this.perObjectFrustumCulled
          , g = this._indirectTexture
          , x = g.image.data;
        m && (jS.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld),
        Og.setFromProjectionMatrix(jS, e.coordinateSystem));
        let S = 0;
        if (this.sortObjects) {
            Ng.copy(this.matrixWorld).invert(),
            hc.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Ng),
            XS.set(0, 0, -1).transformDirection(i.matrixWorld).transformDirection(Ng);
            for (let M = 0, w = u.length; M < w; M++)
                if (u[M].visible && u[M].active) {
                    const E = u[M].geometryIndex;
                    this.getMatrixAt(M, Rs),
                    this.getBoundingSphereAt(E, vo).applyMatrix4(Rs);
                    let O = !1;
                    if (m && (O = !Og.intersectsSphere(vo)),
                    !O) {
                        const R = ID.subVectors(vo.center, hc).dot(XS);
                        Dg.push(h[E], R, M)
                    }
                }
            const _ = Dg.list
              , v = this.customSort;
            v === null ? _.sort(s.transparent ? TD : CD) : v.call(this, _, i);
            for (let M = 0, w = _.length; M < w; M++) {
                const E = _[M];
                f[S] = E.start * l,
                d[S] = E.count,
                x[S] = E.index,
                S++
            }
            Dg.reset()
        } else
            for (let _ = 0, v = u.length; _ < v; _++)
                if (u[_].visible && u[_].active) {
                    const M = u[_].geometryIndex;
                    let w = !1;
                    if (m && (this.getMatrixAt(_, Rs),
                    this.getBoundingSphereAt(M, vo).applyMatrix4(Rs),
                    w = !Og.intersectsSphere(vo)),
                    !w) {
                        const E = h[M];
                        f[S] = E.start * l,
                        d[S] = E.count,
                        x[S] = _,
                        S++
                    }
                }
        g.needsUpdate = !0,
        this._multiDrawCount = S,
        this._visibilityChanged = !1
    }
    onBeforeShadow(e, t, i, r, s, o) {
        this.onBeforeRender(e, null, r, s, o)
    }
}
class oi extends Fn {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const rp = new B
  , sp = new B
  , $S = new ct
  , pc = new El
  , Nd = new Yn
  , Ug = new B
  , qS = new B;
class Ws extends It {
    constructor(e=new St, t=new oi) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [0];
            for (let r = 1, s = t.count; r < s; r++)
                rp.fromBufferAttribute(t, r - 1),
                sp.fromBufferAttribute(t, r),
                i[r] = i[r - 1],
                i[r] += rp.distanceTo(sp);
            e.setAttribute("lineDistance", new Je(i,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Line.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Nd.copy(i.boundingSphere),
        Nd.applyMatrix4(r),
        Nd.radius += s,
        e.ray.intersectsSphere(Nd) === !1)
            return;
        $S.copy(r).invert(),
        pc.copy(e.ray).applyMatrix4($S);
        const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , u = l * l
          , f = this.isLineSegments ? 2 : 1
          , d = i.index
          , m = i.attributes.position;
        if (d !== null) {
            const g = Math.max(0, o.start)
              , x = Math.min(d.count, o.start + o.count);
            for (let S = g, _ = x - 1; S < _; S += f) {
                const v = d.getX(S)
                  , M = d.getX(S + 1)
                  , w = Od(this, e, pc, u, v, M);
                w && t.push(w)
            }
            if (this.isLineLoop) {
                const S = d.getX(x - 1)
                  , _ = d.getX(g)
                  , v = Od(this, e, pc, u, S, _);
                v && t.push(v)
            }
        } else {
            const g = Math.max(0, o.start)
              , x = Math.min(m.count, o.start + o.count);
            for (let S = g, _ = x - 1; S < _; S += f) {
                const v = Od(this, e, pc, u, S, S + 1);
                v && t.push(v)
            }
            if (this.isLineLoop) {
                const S = Od(this, e, pc, u, x - 1, g);
                S && t.push(S)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const l = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[l] = s
                }
            }
        }
    }
}
function Od(n, e, t, i, r, s) {
    const o = n.geometry.attributes.position;
    if (rp.fromBufferAttribute(o, r),
    sp.fromBufferAttribute(o, s),
    t.distanceSqToSegment(rp, sp, Ug, qS) > i)
        return;
    Ug.applyMatrix4(n.matrixWorld);
    const u = e.ray.origin.distanceTo(Ug);
    if (!(u < e.near || u > e.far))
        return {
            distance: u,
            point: qS.clone().applyMatrix4(n.matrixWorld),
            index: r,
            face: null,
            faceIndex: null,
            object: n
        }
}
const YS = new B
  , ZS = new B;
class Fr extends Ws {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                YS.fromBufferAttribute(t, r),
                ZS.fromBufferAttribute(t, r + 1),
                i[r] = r === 0 ? 0 : i[r - 1],
                i[r + 1] = i[r] + YS.distanceTo(ZS);
            e.setAttribute("lineDistance", new Je(i,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class $b extends Ws {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class bx extends Fn {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const KS = new ct
  , B1 = new El
  , Dd = new Yn
  , Ud = new B;
class qb extends It {
    constructor(e=new St, t=new bx) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Dd.copy(i.boundingSphere),
        Dd.applyMatrix4(r),
        Dd.radius += s,
        e.ray.intersectsSphere(Dd) === !1)
            return;
        KS.copy(r).invert(),
        B1.copy(e.ray).applyMatrix4(KS);
        const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , u = l * l
          , f = i.index
          , h = i.attributes.position;
        if (f !== null) {
            const m = Math.max(0, o.start)
              , g = Math.min(f.count, o.start + o.count);
            for (let x = m, S = g; x < S; x++) {
                const _ = f.getX(x);
                Ud.fromBufferAttribute(h, _),
                JS(Ud, _, u, r, e, t, this)
            }
        } else {
            const m = Math.max(0, o.start)
              , g = Math.min(h.count, o.start + o.count);
            for (let x = m, S = g; x < S; x++)
                Ud.fromBufferAttribute(h, x),
                JS(Ud, x, u, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const l = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[l] = s
                }
            }
        }
    }
}
function JS(n, e, t, i, r, s, o) {
    const l = B1.distanceSqToPoint(n);
    if (l < t) {
        const u = new B;
        B1.closestPointToPoint(n, u),
        u.applyMatrix4(i);
        const f = r.ray.origin.distanceTo(u);
        if (f < r.near || f > r.far)
            return;
        s.push({
            distance: f,
            distanceToRay: Math.sqrt(l),
            point: u,
            index: e,
            face: null,
            object: o
        })
    }
}
class ND extends en {
    constructor(e, t, i, r, s, o, l, u, f) {
        super(e, t, i, r, s, o, l, u, f),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : ln,
        this.magFilter = s !== void 0 ? s : ln,
        this.generateMipmaps = !1;
        const d = this;
        function h() {
            d.needsUpdate = !0,
            e.requestVideoFrameCallback(h)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(h)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class OD extends en {
    constructor(e, t) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.magFilter = Ln,
        this.minFilter = Ln,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class am extends en {
    constructor(e, t, i, r, s, o, l, u, f, d, h, m) {
        super(null, o, l, u, f, d, r, s, h, m),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class DD extends am {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o),
        this.isCompressedArrayTexture = !0,
        this.image.depth = r,
        this.wrapR = Xi,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class UD extends am {
    constructor(e, t, i) {
        super(void 0, e[0].width, e[0].height, t, i, os),
        this.isCompressedCubeTexture = !0,
        this.isCubeTexture = !0,
        this.image = e
    }
}
class FD extends en {
    constructor(e, t, i, r, s, o, l, u, f) {
        super(e, t, i, r, s, o, l, u, f),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class hr {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            i = this.getPoint(o / e),
            s += i.distanceTo(r),
            t.push(s),
            r = i;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let l = 0, u = s - 1, f;
        for (; l <= u; )
            if (r = Math.floor(l + (u - l) / 2),
            f = i[r] - o,
            f < 0)
                l = r + 1;
            else if (f > 0)
                u = r - 1;
            else {
                u = r;
                break
            }
        if (r = u,
        i[r] === o)
            return r / (s - 1);
        const d = i[r]
          , m = i[r + 1] - d
          , g = (o - d) / m;
        return (r + g) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4
          , s = e + 1e-4;
        r < 0 && (r = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(r)
          , l = this.getPoint(s)
          , u = t || (o.isVector2 ? new he : new B);
        return u.copy(l).sub(o).normalize(),
        u
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new B
          , r = []
          , s = []
          , o = []
          , l = new B
          , u = new ct;
        for (let g = 0; g <= e; g++) {
            const x = g / e;
            r[g] = this.getTangentAt(x, new B)
        }
        s[0] = new B,
        o[0] = new B;
        let f = Number.MAX_VALUE;
        const d = Math.abs(r[0].x)
          , h = Math.abs(r[0].y)
          , m = Math.abs(r[0].z);
        d <= f && (f = d,
        i.set(1, 0, 0)),
        h <= f && (f = h,
        i.set(0, 1, 0)),
        m <= f && i.set(0, 0, 1),
        l.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], l),
        o[0].crossVectors(r[0], s[0]);
        for (let g = 1; g <= e; g++) {
            if (s[g] = s[g - 1].clone(),
            o[g] = o[g - 1].clone(),
            l.crossVectors(r[g - 1], r[g]),
            l.length() > Number.EPSILON) {
                l.normalize();
                const x = Math.acos(an(r[g - 1].dot(r[g]), -1, 1));
                s[g].applyMatrix4(u.makeRotationAxis(l, x))
            }
            o[g].crossVectors(r[g], s[g])
        }
        if (t === !0) {
            let g = Math.acos(an(s[0].dot(s[e]), -1, 1));
            g /= e,
            r[0].dot(l.crossVectors(s[0], s[e])) > 0 && (g = -g);
            for (let x = 1; x <= e; x++)
                s[x].applyMatrix4(u.makeRotationAxis(r[x], g * x)),
                o[x].crossVectors(r[x], s[x])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class lm extends hr {
    constructor(e=0, t=0, i=1, r=1, s=0, o=Math.PI * 2, l=!1, u=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = i,
        this.yRadius = r,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = l,
        this.aRotation = u
    }
    getPoint(e, t=new he) {
        const i = t
          , r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += r;
        for (; s > r; )
            s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r),
        this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const l = this.aStartAngle + e * s;
        let u = this.aX + this.xRadius * Math.cos(l)
          , f = this.aY + this.yRadius * Math.sin(l);
        if (this.aRotation !== 0) {
            const d = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , m = u - this.aX
              , g = f - this.aY;
            u = m * d - g * h + this.aX,
            f = m * h + g * d + this.aY
        }
        return i.set(u, f)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class Yb extends lm {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function Ex() {
    let n = 0
      , e = 0
      , t = 0
      , i = 0;
    function r(s, o, l, u) {
        n = s,
        e = l,
        t = -3 * s + 3 * o - 2 * l - u,
        i = 2 * s - 2 * o + l + u
    }
    return {
        initCatmullRom: function(s, o, l, u, f) {
            r(o, l, f * (l - s), f * (u - o))
        },
        initNonuniformCatmullRom: function(s, o, l, u, f, d, h) {
            let m = (o - s) / f - (l - s) / (f + d) + (l - o) / d
              , g = (l - o) / d - (u - o) / (d + h) + (u - l) / h;
            m *= d,
            g *= d,
            r(o, l, m, g)
        },
        calc: function(s) {
            const o = s * s
              , l = o * s;
            return n + e * s + t * o + i * l
        }
    }
}
const Fd = new B
  , Fg = new Ex
  , kg = new Ex
  , Bg = new Ex;
class Zb extends hr {
    constructor(e=[], t=!1, i="centripetal", r=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = i,
        this.tension = r
    }
    getPoint(e, t=new B) {
        const i = t
          , r = this.points
          , s = r.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let l = Math.floor(o)
          , u = o - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s : u === 0 && l === s - 1 && (l = s - 2,
        u = 1);
        let f, d;
        this.closed || l > 0 ? f = r[(l - 1) % s] : (Fd.subVectors(r[0], r[1]).add(r[0]),
        f = Fd);
        const h = r[l % s]
          , m = r[(l + 1) % s];
        if (this.closed || l + 2 < s ? d = r[(l + 2) % s] : (Fd.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]),
        d = Fd),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const g = this.curveType === "chordal" ? .5 : .25;
            let x = Math.pow(f.distanceToSquared(h), g)
              , S = Math.pow(h.distanceToSquared(m), g)
              , _ = Math.pow(m.distanceToSquared(d), g);
            S < 1e-4 && (S = 1),
            x < 1e-4 && (x = S),
            _ < 1e-4 && (_ = S),
            Fg.initNonuniformCatmullRom(f.x, h.x, m.x, d.x, x, S, _),
            kg.initNonuniformCatmullRom(f.y, h.y, m.y, d.y, x, S, _),
            Bg.initNonuniformCatmullRom(f.z, h.z, m.z, d.z, x, S, _)
        } else
            this.curveType === "catmullrom" && (Fg.initCatmullRom(f.x, h.x, m.x, d.x, this.tension),
            kg.initCatmullRom(f.y, h.y, m.y, d.y, this.tension),
            Bg.initCatmullRom(f.z, h.z, m.z, d.z, this.tension));
        return i.set(Fg.calc(u), kg.calc(u), Bg.calc(u)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new B().fromArray(r))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function QS(n, e, t, i, r) {
    const s = (i - e) * .5
      , o = (r - t) * .5
      , l = n * n
      , u = n * l;
    return (2 * t - 2 * i + s + o) * u + (-3 * t + 3 * i - 2 * s - o) * l + s * n + t
}
function kD(n, e) {
    const t = 1 - n;
    return t * t * e
}
function BD(n, e) {
    return 2 * (1 - n) * n * e
}
function zD(n, e) {
    return n * n * e
}
function Fc(n, e, t, i) {
    return kD(n, e) + BD(n, t) + zD(n, i)
}
function VD(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function HD(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function GD(n, e) {
    return 3 * (1 - n) * n * n * e
}
function WD(n, e) {
    return n * n * n * e
}
function kc(n, e, t, i, r) {
    return VD(n, e) + HD(n, t) + GD(n, i) + WD(n, r)
}
class Cx extends hr {
    constructor(e=new he, t=new he, i=new he, r=new he) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new he) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , l = this.v3;
        return i.set(kc(e, r.x, s.x, o.x, l.x), kc(e, r.y, s.y, o.y, l.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class Kb extends hr {
    constructor(e=new B, t=new B, i=new B, r=new B) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new B) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , l = this.v3;
        return i.set(kc(e, r.x, s.x, o.x, l.x), kc(e, r.y, s.y, o.y, l.y), kc(e, r.z, s.z, o.z, l.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class Tx extends hr {
    constructor(e=new he, t=new he) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new he) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new he) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Jb extends hr {
    constructor(e=new B, t=new B) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new B) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new B) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Ax extends hr {
    constructor(e=new he, t=new he, i=new he) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new he) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(Fc(e, r.x, s.x, o.x), Fc(e, r.y, s.y, o.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Rx extends hr {
    constructor(e=new B, t=new B, i=new B) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new B) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(Fc(e, r.x, s.x, o.x), Fc(e, r.y, s.y, o.y), Fc(e, r.z, s.z, o.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Px extends hr {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new he) {
        const i = t
          , r = this.points
          , s = (r.length - 1) * e
          , o = Math.floor(s)
          , l = s - o
          , u = r[o === 0 ? o : o - 1]
          , f = r[o]
          , d = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(QS(l, u.x, f.x, d.x, h.x), QS(l, u.y, f.y, d.y, h.y)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new he().fromArray(r))
        }
        return this
    }
}
var op = Object.freeze({
    __proto__: null,
    ArcCurve: Yb,
    CatmullRomCurve3: Zb,
    CubicBezierCurve: Cx,
    CubicBezierCurve3: Kb,
    EllipseCurve: lm,
    LineCurve: Tx,
    LineCurve3: Jb,
    QuadraticBezierCurve: Ax,
    QuadraticBezierCurve3: Rx,
    SplineCurve: Px
});
class Qb extends hr {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new op[i](t,e))
        }
        return this
    }
    getPoint(e, t) {
        const i = e * this.getLength()
          , r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i
                  , l = this.curves[s]
                  , u = l.getLength()
                  , f = u === 0 ? 0 : 1 - o / u;
                return l.getPointAt(f, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            t += this.curves[i].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r]
              , l = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , u = o.getPoints(l);
            for (let f = 0; f < u.length; f++) {
                const d = u[f];
                i && i.equals(d) || (t.push(d),
                i = d)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new op[r.type]().fromJSON(r))
        }
        return this
    }
}
class du extends Qb {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new he,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const i = new Tx(this.currentPoint.clone(),new he(e,t));
        return this.curves.push(i),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new Ax(this.currentPoint.clone(),new he(e,t),new he(i,r));
        return this.curves.push(s),
        this.currentPoint.set(i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const l = new Cx(this.currentPoint.clone(),new he(e,t),new he(i,r),new he(s,o));
        return this.curves.push(l),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , i = new Px(t);
        return this.curves.push(i),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, i, r, s, o) {
        const l = this.currentPoint.x
          , u = this.currentPoint.y;
        return this.absarc(e + l, t + u, i, r, s, o),
        this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o),
        this
    }
    ellipse(e, t, i, r, s, o, l, u) {
        const f = this.currentPoint.x
          , d = this.currentPoint.y;
        return this.absellipse(e + f, t + d, i, r, s, o, l, u),
        this
    }
    absellipse(e, t, i, r, s, o, l, u) {
        const f = new lm(e,t,i,r,s,o,l,u);
        if (this.curves.length > 0) {
            const h = f.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(f);
        const d = f.getPoint(1);
        return this.currentPoint.copy(d),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class Bu extends St {
    constructor(e=[new he(0,-.5), new he(.5,0), new he(0,.5)], t=12, i=0, r=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        },
        t = Math.floor(t),
        r = an(r, 0, Math.PI * 2);
        const s = []
          , o = []
          , l = []
          , u = []
          , f = []
          , d = 1 / t
          , h = new B
          , m = new he
          , g = new B
          , x = new B
          , S = new B;
        let _ = 0
          , v = 0;
        for (let M = 0; M <= e.length - 1; M++)
            switch (M) {
            case 0:
                _ = e[M + 1].x - e[M].x,
                v = e[M + 1].y - e[M].y,
                g.x = v * 1,
                g.y = -_,
                g.z = v * 0,
                S.copy(g),
                g.normalize(),
                u.push(g.x, g.y, g.z);
                break;
            case e.length - 1:
                u.push(S.x, S.y, S.z);
                break;
            default:
                _ = e[M + 1].x - e[M].x,
                v = e[M + 1].y - e[M].y,
                g.x = v * 1,
                g.y = -_,
                g.z = v * 0,
                x.copy(g),
                g.x += S.x,
                g.y += S.y,
                g.z += S.z,
                g.normalize(),
                u.push(g.x, g.y, g.z),
                S.copy(x)
            }
        for (let M = 0; M <= t; M++) {
            const w = i + M * d * r
              , E = Math.sin(w)
              , O = Math.cos(w);
            for (let R = 0; R <= e.length - 1; R++) {
                h.x = e[R].x * E,
                h.y = e[R].y,
                h.z = e[R].x * O,
                o.push(h.x, h.y, h.z),
                m.x = M / t,
                m.y = R / (e.length - 1),
                l.push(m.x, m.y);
                const A = u[3 * R + 0] * E
                  , F = u[3 * R + 1]
                  , I = u[3 * R + 0] * O;
                f.push(A, F, I)
            }
        }
        for (let M = 0; M < t; M++)
            for (let w = 0; w < e.length - 1; w++) {
                const E = w + M * e.length
                  , O = E
                  , R = E + e.length
                  , A = E + e.length + 1
                  , F = E + 1;
                s.push(O, R, F),
                s.push(A, F, R)
            }
        this.setIndex(s),
        this.setAttribute("position", new Je(o,3)),
        this.setAttribute("uv", new Je(l,2)),
        this.setAttribute("normal", new Je(f,3))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Bu(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class cm extends Bu {
    constructor(e=1, t=1, i=4, r=8) {
        const s = new du;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5),
        super(s.getPoints(i), r),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            length: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new cm(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class um extends St {
    constructor(e=1, t=32, i=0, r=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        },
        t = Math.max(3, t);
        const s = []
          , o = []
          , l = []
          , u = []
          , f = new B
          , d = new he;
        o.push(0, 0, 0),
        l.push(0, 0, 1),
        u.push(.5, .5);
        for (let h = 0, m = 3; h <= t; h++,
        m += 3) {
            const g = i + h / t * r;
            f.x = e * Math.cos(g),
            f.y = e * Math.sin(g),
            o.push(f.x, f.y, f.z),
            l.push(0, 0, 1),
            d.x = (o[m] / e + 1) / 2,
            d.y = (o[m + 1] / e + 1) / 2,
            u.push(d.x, d.y)
        }
        for (let h = 1; h <= t; h++)
            s.push(h, h + 1, 0);
        this.setIndex(s),
        this.setAttribute("position", new Je(o,3)),
        this.setAttribute("normal", new Je(l,3)),
        this.setAttribute("uv", new Je(u,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new um(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class Al extends St {
    constructor(e=1, t=1, i=1, r=32, s=1, o=!1, l=0, u=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: l,
            thetaLength: u
        };
        const f = this;
        r = Math.floor(r),
        s = Math.floor(s);
        const d = []
          , h = []
          , m = []
          , g = [];
        let x = 0;
        const S = []
          , _ = i / 2;
        let v = 0;
        M(),
        o === !1 && (e > 0 && w(!0),
        t > 0 && w(!1)),
        this.setIndex(d),
        this.setAttribute("position", new Je(h,3)),
        this.setAttribute("normal", new Je(m,3)),
        this.setAttribute("uv", new Je(g,2));
        function M() {
            const E = new B
              , O = new B;
            let R = 0;
            const A = (t - e) / i;
            for (let F = 0; F <= s; F++) {
                const I = []
                  , P = F / s
                  , D = P * (t - e) + e;
                for (let W = 0; W <= r; W++) {
                    const X = W / r
                      , G = X * u + l
                      , q = Math.sin(G)
                      , K = Math.cos(G);
                    O.x = D * q,
                    O.y = -P * i + _,
                    O.z = D * K,
                    h.push(O.x, O.y, O.z),
                    E.set(q, A, K).normalize(),
                    m.push(E.x, E.y, E.z),
                    g.push(X, 1 - P),
                    I.push(x++)
                }
                S.push(I)
            }
            for (let F = 0; F < r; F++)
                for (let I = 0; I < s; I++) {
                    const P = S[I][F]
                      , D = S[I + 1][F]
                      , W = S[I + 1][F + 1]
                      , X = S[I][F + 1];
                    d.push(P, D, X),
                    d.push(D, W, X),
                    R += 6
                }
            f.addGroup(v, R, 0),
            v += R
        }
        function w(E) {
            const O = x
              , R = new he
              , A = new B;
            let F = 0;
            const I = E === !0 ? e : t
              , P = E === !0 ? 1 : -1;
            for (let W = 1; W <= r; W++)
                h.push(0, _ * P, 0),
                m.push(0, P, 0),
                g.push(.5, .5),
                x++;
            const D = x;
            for (let W = 0; W <= r; W++) {
                const G = W / r * u + l
                  , q = Math.cos(G)
                  , K = Math.sin(G);
                A.x = I * K,
                A.y = _ * P,
                A.z = I * q,
                h.push(A.x, A.y, A.z),
                m.push(0, P, 0),
                R.x = q * .5 + .5,
                R.y = K * .5 * P + .5,
                g.push(R.x, R.y),
                x++
            }
            for (let W = 0; W < r; W++) {
                const X = O + W
                  , G = D + W;
                E === !0 ? d.push(G, G + 1, X) : d.push(G + 1, G, X),
                F += 3
            }
            f.addGroup(v, F, E === !0 ? 1 : 2),
            v += F
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Al(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class fm extends Al {
    constructor(e=1, t=1, i=32, r=1, s=!1, o=0, l=Math.PI * 2) {
        super(0, e, t, i, r, s, o, l),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: l
        }
    }
    static fromJSON(e) {
        return new fm(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Ys extends St {
    constructor(e=[], t=[], i=1, r=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = []
          , o = [];
        l(r),
        f(i),
        d(),
        this.setAttribute("position", new Je(s,3)),
        this.setAttribute("normal", new Je(s.slice(),3)),
        this.setAttribute("uv", new Je(o,2)),
        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function l(M) {
            const w = new B
              , E = new B
              , O = new B;
            for (let R = 0; R < t.length; R += 3)
                g(t[R + 0], w),
                g(t[R + 1], E),
                g(t[R + 2], O),
                u(w, E, O, M)
        }
        function u(M, w, E, O) {
            const R = O + 1
              , A = [];
            for (let F = 0; F <= R; F++) {
                A[F] = [];
                const I = M.clone().lerp(E, F / R)
                  , P = w.clone().lerp(E, F / R)
                  , D = R - F;
                for (let W = 0; W <= D; W++)
                    W === 0 && F === R ? A[F][W] = I : A[F][W] = I.clone().lerp(P, W / D)
            }
            for (let F = 0; F < R; F++)
                for (let I = 0; I < 2 * (R - F) - 1; I++) {
                    const P = Math.floor(I / 2);
                    I % 2 === 0 ? (m(A[F][P + 1]),
                    m(A[F + 1][P]),
                    m(A[F][P])) : (m(A[F][P + 1]),
                    m(A[F + 1][P + 1]),
                    m(A[F + 1][P]))
                }
        }
        function f(M) {
            const w = new B;
            for (let E = 0; E < s.length; E += 3)
                w.x = s[E + 0],
                w.y = s[E + 1],
                w.z = s[E + 2],
                w.normalize().multiplyScalar(M),
                s[E + 0] = w.x,
                s[E + 1] = w.y,
                s[E + 2] = w.z
        }
        function d() {
            const M = new B;
            for (let w = 0; w < s.length; w += 3) {
                M.x = s[w + 0],
                M.y = s[w + 1],
                M.z = s[w + 2];
                const E = _(M) / 2 / Math.PI + .5
                  , O = v(M) / Math.PI + .5;
                o.push(E, 1 - O)
            }
            x(),
            h()
        }
        function h() {
            for (let M = 0; M < o.length; M += 6) {
                const w = o[M + 0]
                  , E = o[M + 2]
                  , O = o[M + 4]
                  , R = Math.max(w, E, O)
                  , A = Math.min(w, E, O);
                R > .9 && A < .1 && (w < .2 && (o[M + 0] += 1),
                E < .2 && (o[M + 2] += 1),
                O < .2 && (o[M + 4] += 1))
            }
        }
        function m(M) {
            s.push(M.x, M.y, M.z)
        }
        function g(M, w) {
            const E = M * 3;
            w.x = e[E + 0],
            w.y = e[E + 1],
            w.z = e[E + 2]
        }
        function x() {
            const M = new B
              , w = new B
              , E = new B
              , O = new B
              , R = new he
              , A = new he
              , F = new he;
            for (let I = 0, P = 0; I < s.length; I += 9,
            P += 6) {
                M.set(s[I + 0], s[I + 1], s[I + 2]),
                w.set(s[I + 3], s[I + 4], s[I + 5]),
                E.set(s[I + 6], s[I + 7], s[I + 8]),
                R.set(o[P + 0], o[P + 1]),
                A.set(o[P + 2], o[P + 3]),
                F.set(o[P + 4], o[P + 5]),
                O.copy(M).add(w).add(E).divideScalar(3);
                const D = _(O);
                S(R, P + 0, M, D),
                S(A, P + 2, w, D),
                S(F, P + 4, E, D)
            }
        }
        function S(M, w, E, O) {
            O < 0 && M.x === 1 && (o[w] = M.x - 1),
            E.x === 0 && E.z === 0 && (o[w] = O / 2 / Math.PI + .5)
        }
        function _(M) {
            return Math.atan2(M.z, -M.x)
        }
        function v(M) {
            return Math.atan2(-M.y, Math.sqrt(M.x * M.x + M.z * M.z))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ys(e.vertices,e.indices,e.radius,e.details)
    }
}
class dm extends Ys {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = 1 / i
          , s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r]
          , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new dm(e.radius,e.detail)
    }
}
const kd = new B
  , Bd = new B
  , zg = new B
  , zd = new Ci;
class eE extends St {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const r = Math.pow(10, 4)
              , s = Math.cos(Uo * t)
              , o = e.getIndex()
              , l = e.getAttribute("position")
              , u = o ? o.count : l.count
              , f = [0, 0, 0]
              , d = ["a", "b", "c"]
              , h = new Array(3)
              , m = {}
              , g = [];
            for (let x = 0; x < u; x += 3) {
                o ? (f[0] = o.getX(x),
                f[1] = o.getX(x + 1),
                f[2] = o.getX(x + 2)) : (f[0] = x,
                f[1] = x + 1,
                f[2] = x + 2);
                const {a: S, b: _, c: v} = zd;
                if (S.fromBufferAttribute(l, f[0]),
                _.fromBufferAttribute(l, f[1]),
                v.fromBufferAttribute(l, f[2]),
                zd.getNormal(zg),
                h[0] = `${Math.round(S.x * r)},${Math.round(S.y * r)},${Math.round(S.z * r)}`,
                h[1] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`,
                h[2] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`,
                !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let M = 0; M < 3; M++) {
                        const w = (M + 1) % 3
                          , E = h[M]
                          , O = h[w]
                          , R = zd[d[M]]
                          , A = zd[d[w]]
                          , F = `${E}_${O}`
                          , I = `${O}_${E}`;
                        I in m && m[I] ? (zg.dot(m[I].normal) <= s && (g.push(R.x, R.y, R.z),
                        g.push(A.x, A.y, A.z)),
                        m[I] = null) : F in m || (m[F] = {
                            index0: f[M],
                            index1: f[w],
                            normal: zg.clone()
                        })
                    }
            }
            for (const x in m)
                if (m[x]) {
                    const {index0: S, index1: _} = m[x];
                    kd.fromBufferAttribute(l, S),
                    Bd.fromBufferAttribute(l, _),
                    g.push(kd.x, kd.y, kd.z),
                    g.push(Bd.x, Bd.y, Bd.z)
                }
            this.setAttribute("position", new Je(g,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
class ko extends du {
    constructor(e) {
        super(e),
        this.uuid = Ai(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++)
            t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new du().fromJSON(r))
        }
        return this
    }
}
const jD = {
    triangulate: function(n, e, t=2) {
        const i = e && e.length
          , r = i ? e[0] * t : n.length;
        let s = tE(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let l, u, f, d, h, m, g;
        if (i && (s = ZD(n, e, s, t)),
        n.length > 80 * t) {
            l = f = n[0],
            u = d = n[1];
            for (let x = t; x < r; x += t)
                h = n[x],
                m = n[x + 1],
                h < l && (l = h),
                m < u && (u = m),
                h > f && (f = h),
                m > d && (d = m);
            g = Math.max(f - l, d - u),
            g = g !== 0 ? 32767 / g : 0
        }
        return hu(s, o, t, l, u, g, 0),
        o
    }
};
function tE(n, e, t, i, r) {
    let s, o;
    if (r === aU(n, e, t, i) > 0)
        for (s = e; s < t; s += i)
            o = eM(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i)
            o = eM(s, n[s], n[s + 1], o);
    return o && hm(o, o.next) && (mu(o),
    o = o.next),
    o
}
function Go(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, i;
    do
        if (i = !1,
        !t.steiner && (hm(t, t.next) || Qt(t.prev, t, t.next) === 0)) {
            if (mu(t),
            t = e = t.prev,
            t === t.next)
                break;
            i = !0
        } else
            t = t.next;
    while (i || t !== e);
    return e
}
function hu(n, e, t, i, r, s, o) {
    if (!n)
        return;
    !o && s && tU(n, i, r, s);
    let l = n, u, f;
    for (; n.prev !== n.next; ) {
        if (u = n.prev,
        f = n.next,
        s ? $D(n, i, r, s) : XD(n)) {
            e.push(u.i / t | 0),
            e.push(n.i / t | 0),
            e.push(f.i / t | 0),
            mu(n),
            n = f.next,
            l = f.next;
            continue
        }
        if (n = f,
        n === l) {
            o ? o === 1 ? (n = qD(Go(n), e, t),
            hu(n, e, t, i, r, s, 2)) : o === 2 && YD(n, e, t, i, r, s) : hu(Go(n), e, t, i, r, s, 1);
            break
        }
    }
}
function XD(n) {
    const e = n.prev
      , t = n
      , i = n.next;
    if (Qt(e, t, i) >= 0)
        return !1;
    const r = e.x
      , s = t.x
      , o = i.x
      , l = e.y
      , u = t.y
      , f = i.y
      , d = r < s ? r < o ? r : o : s < o ? s : o
      , h = l < u ? l < f ? l : f : u < f ? u : f
      , m = r > s ? r > o ? r : o : s > o ? s : o
      , g = l > u ? l > f ? l : f : u > f ? u : f;
    let x = i.next;
    for (; x !== e; ) {
        if (x.x >= d && x.x <= m && x.y >= h && x.y <= g && Ya(r, l, s, u, o, f, x.x, x.y) && Qt(x.prev, x, x.next) >= 0)
            return !1;
        x = x.next
    }
    return !0
}
function $D(n, e, t, i) {
    const r = n.prev
      , s = n
      , o = n.next;
    if (Qt(r, s, o) >= 0)
        return !1;
    const l = r.x
      , u = s.x
      , f = o.x
      , d = r.y
      , h = s.y
      , m = o.y
      , g = l < u ? l < f ? l : f : u < f ? u : f
      , x = d < h ? d < m ? d : m : h < m ? h : m
      , S = l > u ? l > f ? l : f : u > f ? u : f
      , _ = d > h ? d > m ? d : m : h > m ? h : m
      , v = z1(g, x, e, t, i)
      , M = z1(S, _, e, t, i);
    let w = n.prevZ
      , E = n.nextZ;
    for (; w && w.z >= v && E && E.z <= M; ) {
        if (w.x >= g && w.x <= S && w.y >= x && w.y <= _ && w !== r && w !== o && Ya(l, d, u, h, f, m, w.x, w.y) && Qt(w.prev, w, w.next) >= 0 || (w = w.prevZ,
        E.x >= g && E.x <= S && E.y >= x && E.y <= _ && E !== r && E !== o && Ya(l, d, u, h, f, m, E.x, E.y) && Qt(E.prev, E, E.next) >= 0))
            return !1;
        E = E.nextZ
    }
    for (; w && w.z >= v; ) {
        if (w.x >= g && w.x <= S && w.y >= x && w.y <= _ && w !== r && w !== o && Ya(l, d, u, h, f, m, w.x, w.y) && Qt(w.prev, w, w.next) >= 0)
            return !1;
        w = w.prevZ
    }
    for (; E && E.z <= M; ) {
        if (E.x >= g && E.x <= S && E.y >= x && E.y <= _ && E !== r && E !== o && Ya(l, d, u, h, f, m, E.x, E.y) && Qt(E.prev, E, E.next) >= 0)
            return !1;
        E = E.nextZ
    }
    return !0
}
function qD(n, e, t) {
    let i = n;
    do {
        const r = i.prev
          , s = i.next.next;
        !hm(r, s) && nE(r, i, i.next, s) && pu(r, s) && pu(s, r) && (e.push(r.i / t | 0),
        e.push(i.i / t | 0),
        e.push(s.i / t | 0),
        mu(i),
        mu(i.next),
        i = n = s),
        i = i.next
    } while (i !== n);
    return Go(i)
}
function YD(n, e, t, i, r, s) {
    let o = n;
    do {
        let l = o.next.next;
        for (; l !== o.prev; ) {
            if (o.i !== l.i && rU(o, l)) {
                let u = iE(o, l);
                o = Go(o, o.next),
                u = Go(u, u.next),
                hu(o, e, t, i, r, s, 0),
                hu(u, e, t, i, r, s, 0);
                return
            }
            l = l.next
        }
        o = o.next
    } while (o !== n)
}
function ZD(n, e, t, i) {
    const r = [];
    let s, o, l, u, f;
    for (s = 0,
    o = e.length; s < o; s++)
        l = e[s] * i,
        u = s < o - 1 ? e[s + 1] * i : n.length,
        f = tE(n, l, u, i, !1),
        f === f.next && (f.steiner = !0),
        r.push(iU(f));
    for (r.sort(KD),
    s = 0; s < r.length; s++)
        t = JD(r[s], t);
    return t
}
function KD(n, e) {
    return n.x - e.x
}
function JD(n, e) {
    const t = QD(n, e);
    if (!t)
        return e;
    const i = iE(t, n);
    return Go(i, i.next),
    Go(t, t.next)
}
function QD(n, e) {
    let t = e, i = -1 / 0, r;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const m = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (m <= s && m > i && (i = m,
            r = t.x < t.next.x ? t : t.next,
            m === s))
                return r
        }
        t = t.next
    } while (t !== e);
    if (!r)
        return null;
    const l = r
      , u = r.x
      , f = r.y;
    let d = 1 / 0, h;
    t = r;
    do
        s >= t.x && t.x >= u && s !== t.x && Ya(o < f ? s : i, o, u, f, o < f ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x),
        pu(t, n) && (h < d || h === d && (t.x > r.x || t.x === r.x && eU(r, t))) && (r = t,
        d = h)),
        t = t.next;
    while (t !== l);
    return r
}
function eU(n, e) {
    return Qt(n.prev, n, e.prev) < 0 && Qt(e.next, n, n.next) < 0
}
function tU(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = z1(r.x, r.y, e, t, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== n);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    nU(r)
}
function nU(n) {
    let e, t, i, r, s, o, l, u, f = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            i = t,
            l = 0,
            e = 0; e < f && (l++,
            i = i.nextZ,
            !!i); e++)
                ;
            for (u = f; l > 0 || u > 0 && i; )
                l !== 0 && (u === 0 || !i || t.z <= i.z) ? (r = t,
                t = t.nextZ,
                l--) : (r = i,
                i = i.nextZ,
                u--),
                s ? s.nextZ = r : n = r,
                r.prevZ = s,
                s = r;
            t = i
        }
        s.nextZ = null,
        f *= 2
    } while (o > 1);
    return n
}
function z1(n, e, t, i, r) {
    return n = (n - t) * r | 0,
    e = (e - i) * r | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function iU(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function Ya(n, e, t, i, r, s, o, l) {
    return (r - o) * (e - l) >= (n - o) * (s - l) && (n - o) * (i - l) >= (t - o) * (e - l) && (t - o) * (s - l) >= (r - o) * (i - l)
}
function rU(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !sU(n, e) && (pu(n, e) && pu(e, n) && oU(n, e) && (Qt(n.prev, n, e.prev) || Qt(n, e.prev, e)) || hm(n, e) && Qt(n.prev, n, n.next) > 0 && Qt(e.prev, e, e.next) > 0)
}
function Qt(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function hm(n, e) {
    return n.x === e.x && n.y === e.y
}
function nE(n, e, t, i) {
    const r = Hd(Qt(n, e, t))
      , s = Hd(Qt(n, e, i))
      , o = Hd(Qt(t, i, n))
      , l = Hd(Qt(t, i, e));
    return !!(r !== s && o !== l || r === 0 && Vd(n, t, e) || s === 0 && Vd(n, i, e) || o === 0 && Vd(t, n, i) || l === 0 && Vd(t, e, i))
}
function Vd(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function Hd(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function sU(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && nE(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function pu(n, e) {
    return Qt(n.prev, n, n.next) < 0 ? Qt(n, e, n.next) >= 0 && Qt(n, n.prev, e) >= 0 : Qt(n, e, n.prev) < 0 || Qt(n, n.next, e) < 0
}
function oU(n, e) {
    let t = n
      , i = !1;
    const r = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i),
        t = t.next;
    while (t !== n);
    return i
}
function iE(n, e) {
    const t = new V1(n.i,n.x,n.y)
      , i = new V1(e.i,e.x,e.y)
      , r = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = r,
    r.prev = t,
    i.next = t,
    t.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function eM(n, e, t, i) {
    const r = new V1(n,e,t);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function mu(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function V1(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function aU(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i)
        r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return r
}
class Lr {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return Lr.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = []
          , r = []
          , s = [];
        tM(e),
        nM(i, e);
        let o = e.length;
        t.forEach(tM);
        for (let u = 0; u < t.length; u++)
            r.push(o),
            o += t[u].length,
            nM(i, t[u]);
        const l = jD.triangulate(i, r);
        for (let u = 0; u < l.length; u += 3)
            s.push(l.slice(u, u + 3));
        return s
    }
}
function tM(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function nM(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class pm extends St {
    constructor(e=new ko([new he(.5,.5), new he(-.5,.5), new he(-.5,-.5), new he(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const i = this
          , r = []
          , s = [];
        for (let l = 0, u = e.length; l < u; l++) {
            const f = e[l];
            o(f)
        }
        this.setAttribute("position", new Je(r,3)),
        this.setAttribute("uv", new Je(s,2)),
        this.computeVertexNormals();
        function o(l) {
            const u = []
              , f = t.curveSegments !== void 0 ? t.curveSegments : 12
              , d = t.steps !== void 0 ? t.steps : 1
              , h = t.depth !== void 0 ? t.depth : 1;
            let m = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , g = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , x = t.bevelSize !== void 0 ? t.bevelSize : g - .1
              , S = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , _ = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const v = t.extrudePath
              , M = t.UVGenerator !== void 0 ? t.UVGenerator : lU;
            let w, E = !1, O, R, A, F;
            v && (w = v.getSpacedPoints(d),
            E = !0,
            m = !1,
            O = v.computeFrenetFrames(d, !1),
            R = new B,
            A = new B,
            F = new B),
            m || (_ = 0,
            g = 0,
            x = 0,
            S = 0);
            const I = l.extractPoints(f);
            let P = I.shape;
            const D = I.holes;
            if (!Lr.isClockWise(P)) {
                P = P.reverse();
                for (let k = 0, pe = D.length; k < pe; k++) {
                    const ye = D[k];
                    Lr.isClockWise(ye) && (D[k] = ye.reverse())
                }
            }
            const X = Lr.triangulateShape(P, D)
              , G = P;
            for (let k = 0, pe = D.length; k < pe; k++) {
                const ye = D[k];
                P = P.concat(ye)
            }
            function q(k, pe, ye) {
                return pe || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                k.clone().addScaledVector(pe, ye)
            }
            const K = P.length
              , oe = X.length;
            function z(k, pe, ye) {
                let Pe, fe, $e;
                const Le = k.x - pe.x
                  , Be = k.y - pe.y
                  , H = ye.x - k.x
                  , L = ye.y - k.y
                  , te = Le * Le + Be * Be
                  , _e = Le * L - Be * H;
                if (Math.abs(_e) > Number.EPSILON) {
                    const ge = Math.sqrt(te)
                      , ve = Math.sqrt(H * H + L * L)
                      , Ke = pe.x - Be / ge
                      , we = pe.y + Le / ge
                      , He = ye.x - L / ve
                      , ft = ye.y + H / ve
                      , Ee = ((He - Ke) * L - (ft - we) * H) / (Le * L - Be * H);
                    Pe = Ke + Le * Ee - k.x,
                    fe = we + Be * Ee - k.y;
                    const We = Pe * Pe + fe * fe;
                    if (We <= 2)
                        return new he(Pe,fe);
                    $e = Math.sqrt(We / 2)
                } else {
                    let ge = !1;
                    Le > Number.EPSILON ? H > Number.EPSILON && (ge = !0) : Le < -Number.EPSILON ? H < -Number.EPSILON && (ge = !0) : Math.sign(Be) === Math.sign(L) && (ge = !0),
                    ge ? (Pe = -Be,
                    fe = Le,
                    $e = Math.sqrt(te)) : (Pe = Le,
                    fe = Be,
                    $e = Math.sqrt(te / 2))
                }
                return new he(Pe / $e,fe / $e)
            }
            const ee = [];
            for (let k = 0, pe = G.length, ye = pe - 1, Pe = k + 1; k < pe; k++,
            ye++,
            Pe++)
                ye === pe && (ye = 0),
                Pe === pe && (Pe = 0),
                ee[k] = z(G[k], G[ye], G[Pe]);
            const Q = [];
            let ce, be = ee.concat();
            for (let k = 0, pe = D.length; k < pe; k++) {
                const ye = D[k];
                ce = [];
                for (let Pe = 0, fe = ye.length, $e = fe - 1, Le = Pe + 1; Pe < fe; Pe++,
                $e++,
                Le++)
                    $e === fe && ($e = 0),
                    Le === fe && (Le = 0),
                    ce[Pe] = z(ye[Pe], ye[$e], ye[Le]);
                Q.push(ce),
                be = be.concat(ce)
            }
            for (let k = 0; k < _; k++) {
                const pe = k / _
                  , ye = g * Math.cos(pe * Math.PI / 2)
                  , Pe = x * Math.sin(pe * Math.PI / 2) + S;
                for (let fe = 0, $e = G.length; fe < $e; fe++) {
                    const Le = q(G[fe], ee[fe], Pe);
                    Me(Le.x, Le.y, -ye)
                }
                for (let fe = 0, $e = D.length; fe < $e; fe++) {
                    const Le = D[fe];
                    ce = Q[fe];
                    for (let Be = 0, H = Le.length; Be < H; Be++) {
                        const L = q(Le[Be], ce[Be], Pe);
                        Me(L.x, L.y, -ye)
                    }
                }
            }
            const Ue = x + S;
            for (let k = 0; k < K; k++) {
                const pe = m ? q(P[k], be[k], Ue) : P[k];
                E ? (A.copy(O.normals[0]).multiplyScalar(pe.x),
                R.copy(O.binormals[0]).multiplyScalar(pe.y),
                F.copy(w[0]).add(A).add(R),
                Me(F.x, F.y, F.z)) : Me(pe.x, pe.y, 0)
            }
            for (let k = 1; k <= d; k++)
                for (let pe = 0; pe < K; pe++) {
                    const ye = m ? q(P[pe], be[pe], Ue) : P[pe];
                    E ? (A.copy(O.normals[k]).multiplyScalar(ye.x),
                    R.copy(O.binormals[k]).multiplyScalar(ye.y),
                    F.copy(w[k]).add(A).add(R),
                    Me(F.x, F.y, F.z)) : Me(ye.x, ye.y, h / d * k)
                }
            for (let k = _ - 1; k >= 0; k--) {
                const pe = k / _
                  , ye = g * Math.cos(pe * Math.PI / 2)
                  , Pe = x * Math.sin(pe * Math.PI / 2) + S;
                for (let fe = 0, $e = G.length; fe < $e; fe++) {
                    const Le = q(G[fe], ee[fe], Pe);
                    Me(Le.x, Le.y, h + ye)
                }
                for (let fe = 0, $e = D.length; fe < $e; fe++) {
                    const Le = D[fe];
                    ce = Q[fe];
                    for (let Be = 0, H = Le.length; Be < H; Be++) {
                        const L = q(Le[Be], ce[Be], Pe);
                        E ? Me(L.x, L.y + w[d - 1].y, w[d - 1].x + ye) : Me(L.x, L.y, h + ye)
                    }
                }
            }
            se(),
            ue();
            function se() {
                const k = r.length / 3;
                if (m) {
                    let pe = 0
                      , ye = K * pe;
                    for (let Pe = 0; Pe < oe; Pe++) {
                        const fe = X[Pe];
                        Ye(fe[2] + ye, fe[1] + ye, fe[0] + ye)
                    }
                    pe = d + _ * 2,
                    ye = K * pe;
                    for (let Pe = 0; Pe < oe; Pe++) {
                        const fe = X[Pe];
                        Ye(fe[0] + ye, fe[1] + ye, fe[2] + ye)
                    }
                } else {
                    for (let pe = 0; pe < oe; pe++) {
                        const ye = X[pe];
                        Ye(ye[2], ye[1], ye[0])
                    }
                    for (let pe = 0; pe < oe; pe++) {
                        const ye = X[pe];
                        Ye(ye[0] + K * d, ye[1] + K * d, ye[2] + K * d)
                    }
                }
                i.addGroup(k, r.length / 3 - k, 0)
            }
            function ue() {
                const k = r.length / 3;
                let pe = 0;
                Te(G, pe),
                pe += G.length;
                for (let ye = 0, Pe = D.length; ye < Pe; ye++) {
                    const fe = D[ye];
                    Te(fe, pe),
                    pe += fe.length
                }
                i.addGroup(k, r.length / 3 - k, 1)
            }
            function Te(k, pe) {
                let ye = k.length;
                for (; --ye >= 0; ) {
                    const Pe = ye;
                    let fe = ye - 1;
                    fe < 0 && (fe = k.length - 1);
                    for (let $e = 0, Le = d + _ * 2; $e < Le; $e++) {
                        const Be = K * $e
                          , H = K * ($e + 1)
                          , L = pe + Pe + Be
                          , te = pe + fe + Be
                          , _e = pe + fe + H
                          , ge = pe + Pe + H;
                        Qe(L, te, _e, ge)
                    }
                }
            }
            function Me(k, pe, ye) {
                u.push(k),
                u.push(pe),
                u.push(ye)
            }
            function Ye(k, pe, ye) {
                ze(k),
                ze(pe),
                ze(ye);
                const Pe = r.length / 3
                  , fe = M.generateTopUV(i, r, Pe - 3, Pe - 2, Pe - 1);
                ke(fe[0]),
                ke(fe[1]),
                ke(fe[2])
            }
            function Qe(k, pe, ye, Pe) {
                ze(k),
                ze(pe),
                ze(Pe),
                ze(pe),
                ze(ye),
                ze(Pe);
                const fe = r.length / 3
                  , $e = M.generateSideWallUV(i, r, fe - 6, fe - 3, fe - 2, fe - 1);
                ke($e[0]),
                ke($e[1]),
                ke($e[3]),
                ke($e[1]),
                ke($e[2]),
                ke($e[3])
            }
            function ze(k) {
                r.push(u[k * 3 + 0]),
                r.push(u[k * 3 + 1]),
                r.push(u[k * 3 + 2])
            }
            function ke(k) {
                s.push(k.x),
                s.push(k.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , i = this.parameters.options;
        return cU(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const l = t[e.shapes[s]];
            i.push(l)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new op[r.type]().fromJSON(r)),
        new pm(i,e.options)
    }
}
const lU = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , l = e[i * 3]
          , u = e[i * 3 + 1]
          , f = e[r * 3]
          , d = e[r * 3 + 1];
        return [new he(s,o), new he(l,u), new he(f,d)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3]
          , l = e[t * 3 + 1]
          , u = e[t * 3 + 2]
          , f = e[i * 3]
          , d = e[i * 3 + 1]
          , h = e[i * 3 + 2]
          , m = e[r * 3]
          , g = e[r * 3 + 1]
          , x = e[r * 3 + 2]
          , S = e[s * 3]
          , _ = e[s * 3 + 1]
          , v = e[s * 3 + 2];
        return Math.abs(l - d) < Math.abs(o - f) ? [new he(o,1 - u), new he(f,1 - h), new he(m,1 - x), new he(S,1 - v)] : [new he(l,1 - u), new he(d,1 - h), new he(g,1 - x), new he(_,1 - v)]
    }
};
function cU(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class mm extends Ys {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]
          , s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new mm(e.radius,e.detail)
    }
}
class zu extends Ys {
    constructor(e=1, t=0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new zu(e.radius,e.detail)
    }
}
class gm extends St {
    constructor(e=.5, t=1, i=32, r=1, s=0, o=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        },
        i = Math.max(3, i),
        r = Math.max(1, r);
        const l = []
          , u = []
          , f = []
          , d = [];
        let h = e;
        const m = (t - e) / r
          , g = new B
          , x = new he;
        for (let S = 0; S <= r; S++) {
            for (let _ = 0; _ <= i; _++) {
                const v = s + _ / i * o;
                g.x = h * Math.cos(v),
                g.y = h * Math.sin(v),
                u.push(g.x, g.y, g.z),
                f.push(0, 0, 1),
                x.x = (g.x / t + 1) / 2,
                x.y = (g.y / t + 1) / 2,
                d.push(x.x, x.y)
            }
            h += m
        }
        for (let S = 0; S < r; S++) {
            const _ = S * (i + 1);
            for (let v = 0; v < i; v++) {
                const M = v + _
                  , w = M
                  , E = M + i + 1
                  , O = M + i + 2
                  , R = M + 1;
                l.push(w, E, R),
                l.push(E, O, R)
            }
        }
        this.setIndex(l),
        this.setAttribute("position", new Je(u,3)),
        this.setAttribute("normal", new Je(f,3)),
        this.setAttribute("uv", new Je(d,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new gm(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class vm extends St {
    constructor(e=new ko([new he(0,.5), new he(-.5,-.5), new he(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = []
          , r = []
          , s = []
          , o = [];
        let l = 0
          , u = 0;
        if (Array.isArray(e) === !1)
            f(e);
        else
            for (let d = 0; d < e.length; d++)
                f(e[d]),
                this.addGroup(l, u, d),
                l += u,
                u = 0;
        this.setIndex(i),
        this.setAttribute("position", new Je(r,3)),
        this.setAttribute("normal", new Je(s,3)),
        this.setAttribute("uv", new Je(o,2));
        function f(d) {
            const h = r.length / 3
              , m = d.extractPoints(t);
            let g = m.shape;
            const x = m.holes;
            Lr.isClockWise(g) === !1 && (g = g.reverse());
            for (let _ = 0, v = x.length; _ < v; _++) {
                const M = x[_];
                Lr.isClockWise(M) === !0 && (x[_] = M.reverse())
            }
            const S = Lr.triangulateShape(g, x);
            for (let _ = 0, v = x.length; _ < v; _++) {
                const M = x[_];
                g = g.concat(M)
            }
            for (let _ = 0, v = g.length; _ < v; _++) {
                const M = g[_];
                r.push(M.x, M.y, 0),
                s.push(0, 0, 1),
                o.push(M.x, M.y)
            }
            for (let _ = 0, v = S.length; _ < v; _++) {
                const M = S[_]
                  , w = M[0] + h
                  , E = M[1] + h
                  , O = M[2] + h;
                i.push(w, E, O),
                u += 3
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return uU(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new vm(i,e.curveSegments)
    }
}
function uU(n, e) {
    if (e.shapes = [],
    Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        }
    else
        e.shapes.push(n.uuid);
    return e
}
class Vu extends St {
    constructor(e=1, t=32, i=16, r=0, s=Math.PI * 2, o=0, l=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: l
        },
        t = Math.max(3, Math.floor(t)),
        i = Math.max(2, Math.floor(i));
        const u = Math.min(o + l, Math.PI);
        let f = 0;
        const d = []
          , h = new B
          , m = new B
          , g = []
          , x = []
          , S = []
          , _ = [];
        for (let v = 0; v <= i; v++) {
            const M = []
              , w = v / i;
            let E = 0;
            v === 0 && o === 0 ? E = .5 / t : v === i && u === Math.PI && (E = -.5 / t);
            for (let O = 0; O <= t; O++) {
                const R = O / t;
                h.x = -e * Math.cos(r + R * s) * Math.sin(o + w * l),
                h.y = e * Math.cos(o + w * l),
                h.z = e * Math.sin(r + R * s) * Math.sin(o + w * l),
                x.push(h.x, h.y, h.z),
                m.copy(h).normalize(),
                S.push(m.x, m.y, m.z),
                _.push(R + E, 1 - w),
                M.push(f++)
            }
            d.push(M)
        }
        for (let v = 0; v < i; v++)
            for (let M = 0; M < t; M++) {
                const w = d[v][M + 1]
                  , E = d[v][M]
                  , O = d[v + 1][M]
                  , R = d[v + 1][M + 1];
                (v !== 0 || o > 0) && g.push(w, E, R),
                (v !== i - 1 || u < Math.PI) && g.push(E, O, R)
            }
        this.setIndex(g),
        this.setAttribute("position", new Je(x,3)),
        this.setAttribute("normal", new Je(S,3)),
        this.setAttribute("uv", new Je(_,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Vu(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class xm extends Ys {
    constructor(e=1, t=0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new xm(e.radius,e.detail)
    }
}
class _m extends St {
    constructor(e=1, t=.4, i=12, r=48, s=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const o = []
          , l = []
          , u = []
          , f = []
          , d = new B
          , h = new B
          , m = new B;
        for (let g = 0; g <= i; g++)
            for (let x = 0; x <= r; x++) {
                const S = x / r * s
                  , _ = g / i * Math.PI * 2;
                h.x = (e + t * Math.cos(_)) * Math.cos(S),
                h.y = (e + t * Math.cos(_)) * Math.sin(S),
                h.z = t * Math.sin(_),
                l.push(h.x, h.y, h.z),
                d.x = e * Math.cos(S),
                d.y = e * Math.sin(S),
                m.subVectors(h, d).normalize(),
                u.push(m.x, m.y, m.z),
                f.push(x / r),
                f.push(g / i)
            }
        for (let g = 1; g <= i; g++)
            for (let x = 1; x <= r; x++) {
                const S = (r + 1) * g + x - 1
                  , _ = (r + 1) * (g - 1) + x - 1
                  , v = (r + 1) * (g - 1) + x
                  , M = (r + 1) * g + x;
                o.push(S, _, M),
                o.push(_, v, M)
            }
        this.setIndex(o),
        this.setAttribute("position", new Je(l,3)),
        this.setAttribute("normal", new Je(u,3)),
        this.setAttribute("uv", new Je(f,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new _m(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class ym extends St {
    constructor(e=1, t=.4, i=64, r=8, s=2, o=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const l = []
          , u = []
          , f = []
          , d = []
          , h = new B
          , m = new B
          , g = new B
          , x = new B
          , S = new B
          , _ = new B
          , v = new B;
        for (let w = 0; w <= i; ++w) {
            const E = w / i * s * Math.PI * 2;
            M(E, s, o, e, g),
            M(E + .01, s, o, e, x),
            _.subVectors(x, g),
            v.addVectors(x, g),
            S.crossVectors(_, v),
            v.crossVectors(S, _),
            S.normalize(),
            v.normalize();
            for (let O = 0; O <= r; ++O) {
                const R = O / r * Math.PI * 2
                  , A = -t * Math.cos(R)
                  , F = t * Math.sin(R);
                h.x = g.x + (A * v.x + F * S.x),
                h.y = g.y + (A * v.y + F * S.y),
                h.z = g.z + (A * v.z + F * S.z),
                u.push(h.x, h.y, h.z),
                m.subVectors(h, g).normalize(),
                f.push(m.x, m.y, m.z),
                d.push(w / i),
                d.push(O / r)
            }
        }
        for (let w = 1; w <= i; w++)
            for (let E = 1; E <= r; E++) {
                const O = (r + 1) * (w - 1) + (E - 1)
                  , R = (r + 1) * w + (E - 1)
                  , A = (r + 1) * w + E
                  , F = (r + 1) * (w - 1) + E;
                l.push(O, R, F),
                l.push(R, A, F)
            }
        this.setIndex(l),
        this.setAttribute("position", new Je(u,3)),
        this.setAttribute("normal", new Je(f,3)),
        this.setAttribute("uv", new Je(d,2));
        function M(w, E, O, R, A) {
            const F = Math.cos(w)
              , I = Math.sin(w)
              , P = O / E * w
              , D = Math.cos(P);
            A.x = R * (2 + D) * .5 * F,
            A.y = R * (2 + D) * I * .5,
            A.z = R * Math.sin(P) * .5
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new ym(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class Sm extends St {
    constructor(e=new Rx(new B(-1,-1,0),new B(-1,1,0),new B(1,1,0)), t=64, i=1, r=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const l = new B
          , u = new B
          , f = new he;
        let d = new B;
        const h = []
          , m = []
          , g = []
          , x = [];
        S(),
        this.setIndex(x),
        this.setAttribute("position", new Je(h,3)),
        this.setAttribute("normal", new Je(m,3)),
        this.setAttribute("uv", new Je(g,2));
        function S() {
            for (let w = 0; w < t; w++)
                _(w);
            _(s === !1 ? t : 0),
            M(),
            v()
        }
        function _(w) {
            d = e.getPointAt(w / t, d);
            const E = o.normals[w]
              , O = o.binormals[w];
            for (let R = 0; R <= r; R++) {
                const A = R / r * Math.PI * 2
                  , F = Math.sin(A)
                  , I = -Math.cos(A);
                u.x = I * E.x + F * O.x,
                u.y = I * E.y + F * O.y,
                u.z = I * E.z + F * O.z,
                u.normalize(),
                m.push(u.x, u.y, u.z),
                l.x = d.x + i * u.x,
                l.y = d.y + i * u.y,
                l.z = d.z + i * u.z,
                h.push(l.x, l.y, l.z)
            }
        }
        function v() {
            for (let w = 1; w <= t; w++)
                for (let E = 1; E <= r; E++) {
                    const O = (r + 1) * (w - 1) + (E - 1)
                      , R = (r + 1) * w + (E - 1)
                      , A = (r + 1) * w + E
                      , F = (r + 1) * (w - 1) + E;
                    x.push(O, R, F),
                    x.push(R, A, F)
                }
        }
        function M() {
            for (let w = 0; w <= t; w++)
                for (let E = 0; E <= r; E++)
                    f.x = w / t,
                    f.y = E / r,
                    g.push(f.x, f.y)
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new Sm(new op[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class rE extends St {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , i = new Set
              , r = new B
              , s = new B;
            if (e.index !== null) {
                const o = e.attributes.position
                  , l = e.index;
                let u = e.groups;
                u.length === 0 && (u = [{
                    start: 0,
                    count: l.count,
                    materialIndex: 0
                }]);
                for (let f = 0, d = u.length; f < d; ++f) {
                    const h = u[f]
                      , m = h.start
                      , g = h.count;
                    for (let x = m, S = m + g; x < S; x += 3)
                        for (let _ = 0; _ < 3; _++) {
                            const v = l.getX(x + _)
                              , M = l.getX(x + (_ + 1) % 3);
                            r.fromBufferAttribute(o, v),
                            s.fromBufferAttribute(o, M),
                            iM(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let l = 0, u = o.count / 3; l < u; l++)
                    for (let f = 0; f < 3; f++) {
                        const d = 3 * l + f
                          , h = 3 * l + (f + 1) % 3;
                        r.fromBufferAttribute(o, d),
                        s.fromBufferAttribute(o, h),
                        iM(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new Je(t,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
function iM(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`
      , r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i),
    t.add(r),
    !0)
}
var rM = Object.freeze({
    __proto__: null,
    BoxGeometry: $o,
    CapsuleGeometry: cm,
    CircleGeometry: um,
    ConeGeometry: fm,
    CylinderGeometry: Al,
    DodecahedronGeometry: dm,
    EdgesGeometry: eE,
    ExtrudeGeometry: pm,
    IcosahedronGeometry: mm,
    LatheGeometry: Bu,
    OctahedronGeometry: zu,
    PlaneGeometry: Cl,
    PolyhedronGeometry: Ys,
    RingGeometry: gm,
    ShapeGeometry: vm,
    SphereGeometry: Vu,
    TetrahedronGeometry: xm,
    TorusGeometry: _m,
    TorusKnotGeometry: ym,
    TubeGeometry: Sm,
    WireframeGeometry: rE
});
class sE extends Fn {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new Oe(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class oE extends Yi {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class Ix extends Fn {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Oe(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = $s,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class aE extends Ix {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new he(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return an(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Oe(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Oe(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Oe(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.dispersion = e.dispersion,
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class lE extends Fn {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Oe(16777215),
        this.specular = new Oe(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = $s,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.combine = Nu,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class cE extends Fn {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = $s,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class uE extends Fn {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = $s,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class fE extends Fn {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = $s,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ri,
        this.combine = Nu,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class dE extends Fn {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Oe(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = $s,
        this.normalScale = new he(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class hE extends oi {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function Io(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function pE(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function mE(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length
      , i = new Array(t);
    for (let r = 0; r !== t; ++r)
        i[r] = r;
    return i.sort(e),
    i
}
function H1(n, e, t) {
    const i = n.length
      , r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const l = t[s] * e;
        for (let u = 0; u !== e; ++u)
            r[o++] = n[l + u]
    }
    return r
}
function Lx(n, e, t, i) {
    let r = 1
      , s = n[0];
    for (; s !== void 0 && s[i] === void 0; )
        s = n[r++];
    if (s === void 0)
        return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[r++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[r++];
            while (s !== void 0);
        else
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[r++];
            while (s !== void 0)
}
function fU(n, e, t, i, r=30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let u = 0; u < s.tracks.length; ++u) {
        const f = s.tracks[u]
          , d = f.getValueSize()
          , h = []
          , m = [];
        for (let g = 0; g < f.times.length; ++g) {
            const x = f.times[g] * r;
            if (!(x < t || x >= i)) {
                h.push(f.times[g]);
                for (let S = 0; S < d; ++S)
                    m.push(f.values[g * d + S])
            }
        }
        h.length !== 0 && (f.times = Io(h, f.times.constructor),
        f.values = Io(m, f.values.constructor),
        o.push(f))
    }
    s.tracks = o;
    let l = 1 / 0;
    for (let u = 0; u < s.tracks.length; ++u)
        l > s.tracks[u].times[0] && (l = s.tracks[u].times[0]);
    for (let u = 0; u < s.tracks.length; ++u)
        s.tracks[u].shift(-1 * l);
    return s.resetDuration(),
    s
}
function dU(n, e=0, t=n, i=30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length
      , s = e / i;
    for (let o = 0; o < r; ++o) {
        const l = t.tracks[o]
          , u = l.ValueTypeName;
        if (u === "bool" || u === "string")
            continue;
        const f = n.tracks.find(function(v) {
            return v.name === l.name && v.ValueTypeName === u
        });
        if (f === void 0)
            continue;
        let d = 0;
        const h = l.getValueSize();
        l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = h / 3);
        let m = 0;
        const g = f.getValueSize();
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = g / 3);
        const x = l.times.length - 1;
        let S;
        if (s <= l.times[0]) {
            const v = d
              , M = h - d;
            S = l.values.slice(v, M)
        } else if (s >= l.times[x]) {
            const v = x * h + d
              , M = v + h - d;
            S = l.values.slice(v, M)
        } else {
            const v = l.createInterpolant()
              , M = d
              , w = h - d;
            v.evaluate(s),
            S = v.resultBuffer.slice(M, w)
        }
        u === "quaternion" && new mi().fromArray(S).normalize().conjugate().toArray(S);
        const _ = f.times.length;
        for (let v = 0; v < _; ++v) {
            const M = v * g + m;
            if (u === "quaternion")
                mi.multiplyQuaternionsFlat(f.values, M, S, 0, f.values, M);
            else {
                const w = g - m * 2;
                for (let E = 0; E < w; ++E)
                    f.values[M + E] -= S[E]
            }
        }
    }
    return n.blendMode = cx,
    n
}
const hU = {
    convertArray: Io,
    isTypedArray: pE,
    getKeyframeOrder: mE,
    sortedArray: H1,
    flattenJSON: Lx,
    subclip: fU,
    makeClipAdditive: dU
};
class Hu {
    constructor(e, t, i, r) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = r !== void 0 ? r : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex
          , r = t[i]
          , s = t[i - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < r)) {
                        for (let l = i + 2; ; ) {
                            if (r === void 0) {
                                if (e < s)
                                    break i;
                                return i = t.length,
                                this._cachedIndex = i,
                                this.copySampleValue_(i - 1)
                            }
                            if (i === l)
                                break;
                            if (s = r,
                            r = t[++i],
                            e < r)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const l = t[1];
                        e < l && (i = 2,
                        s = l);
                        for (let u = i - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (i === u)
                                break;
                            if (r = s,
                            s = t[--i - 1],
                            e >= s)
                                break t
                        }
                        o = i,
                        i = 0;
                        break n
                    }
                    break e
                }
                for (; i < o; ) {
                    const l = i + o >>> 1;
                    e < t[l] ? o = l : i = l + 1
                }
                if (r = t[i],
                s = t[i - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (r === void 0)
                    return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r;
        for (let o = 0; o !== r; ++o)
            t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class gE extends Hu {
    constructor(e, t, i, r) {
        super(e, t, i, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: Ao,
            endingEnd: Ao
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , l = r[s]
          , u = r[o];
        if (l === void 0)
            switch (this.getSettings_().endingStart) {
            case Ro:
                s = e,
                l = 2 * t - i;
                break;
            case su:
                s = r.length - 2,
                l = t + r[s] - r[s + 1];
                break;
            default:
                s = e,
                l = i
            }
        if (u === void 0)
            switch (this.getSettings_().endingEnd) {
            case Ro:
                o = e,
                u = 2 * i - t;
                break;
            case su:
                o = 1,
                u = i + r[1] - r[0];
                break;
            default:
                o = e - 1,
                u = t
            }
        const f = (i - t) * .5
          , d = this.valueSize;
        this._weightPrev = f / (t - l),
        this._weightNext = f / (u - i),
        this._offsetPrev = s * d,
        this._offsetNext = o * d
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , l = this.valueSize
          , u = e * l
          , f = u - l
          , d = this._offsetPrev
          , h = this._offsetNext
          , m = this._weightPrev
          , g = this._weightNext
          , x = (i - t) / (r - t)
          , S = x * x
          , _ = S * x
          , v = -m * _ + 2 * m * S - m * x
          , M = (1 + m) * _ + (-1.5 - 2 * m) * S + (-.5 + m) * x + 1
          , w = (-1 - g) * _ + (1.5 + g) * S + .5 * x
          , E = g * _ - g * S;
        for (let O = 0; O !== l; ++O)
            s[O] = v * o[d + O] + M * o[f + O] + w * o[u + O] + E * o[h + O];
        return s
    }
}
class Nx extends Hu {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , l = this.valueSize
          , u = e * l
          , f = u - l
          , d = (i - t) / (r - t)
          , h = 1 - d;
        for (let m = 0; m !== l; ++m)
            s[m] = o[f + m] * h + o[u + m] * d;
        return s
    }
}
class vE extends Hu {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class pr {
    constructor(e, t, i, r) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Io(t, this.TimeBufferType),
        this.values = Io(i, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON)
            i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: Io(e.times, Array),
                values: Io(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new vE(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new Nx(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new gE(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case ru:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case np:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case dh:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return ru;
        case this.InterpolantFactoryMethodLinear:
            return np;
        case this.InterpolantFactoryMethodSmooth:
            return dh
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times
          , r = i.length;
        let s = 0
          , o = r - 1;
        for (; s !== r && i[s] < e; )
            ++s;
        for (; o !== -1 && i[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const l = this.getValueSize();
            this.times = i.slice(s, o),
            this.values = this.values.slice(s * l, o * l)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const i = this.times
          , r = this.values
          , s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let l = 0; l !== s; l++) {
            const u = i[l];
            if (typeof u == "number" && isNaN(u)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, l, u),
                e = !1;
                break
            }
            if (o !== null && o > u) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, l, u, o),
                e = !1;
                break
            }
            o = u
        }
        if (r !== void 0 && pE(r))
            for (let l = 0, u = r.length; l !== u; ++l) {
                const f = r[l];
                if (isNaN(f)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, f),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.getValueSize()
          , r = this.getInterpolation() === dh
          , s = e.length - 1;
        let o = 1;
        for (let l = 1; l < s; ++l) {
            let u = !1;
            const f = e[l]
              , d = e[l + 1];
            if (f !== d && (l !== 1 || f !== e[0]))
                if (r)
                    u = !0;
                else {
                    const h = l * i
                      , m = h - i
                      , g = h + i;
                    for (let x = 0; x !== i; ++x) {
                        const S = t[h + x];
                        if (S !== t[m + x] || S !== t[g + x]) {
                            u = !0;
                            break
                        }
                    }
                }
            if (u) {
                if (l !== o) {
                    e[o] = e[l];
                    const h = l * i
                      , m = o * i;
                    for (let g = 0; g !== i; ++g)
                        t[m + g] = t[h + g]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let l = s * i, u = o * i, f = 0; f !== i; ++f)
                t[u + f] = t[l + f];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * i)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.constructor
          , r = new i(this.name,e,t);
        return r.createInterpolant = this.createInterpolant,
        r
    }
}
pr.prototype.TimeBufferType = Float32Array;
pr.prototype.ValueBufferType = Float32Array;
pr.prototype.DefaultInterpolation = np;
class Yo extends pr {
    constructor(e, t, i) {
        super(e, t, i)
    }
}
Yo.prototype.ValueTypeName = "bool";
Yo.prototype.ValueBufferType = Array;
Yo.prototype.DefaultInterpolation = ru;
Yo.prototype.InterpolantFactoryMethodLinear = void 0;
Yo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ox extends pr {
}
Ox.prototype.ValueTypeName = "color";
class gu extends pr {
}
gu.prototype.ValueTypeName = "number";
class xE extends Hu {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , l = this.valueSize
          , u = (i - t) / (r - t);
        let f = e * l;
        for (let d = f + l; f !== d; f += 4)
            mi.slerpFlat(s, 0, o, f - l, o, f, u);
        return s
    }
}
class Gu extends pr {
    InterpolantFactoryMethodLinear(e) {
        return new xE(this.times,this.values,this.getValueSize(),e)
    }
}
Gu.prototype.ValueTypeName = "quaternion";
Gu.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zo extends pr {
    constructor(e, t, i) {
        super(e, t, i)
    }
}
Zo.prototype.ValueTypeName = "string";
Zo.prototype.ValueBufferType = Array;
Zo.prototype.DefaultInterpolation = ru;
Zo.prototype.InterpolantFactoryMethodLinear = void 0;
Zo.prototype.InterpolantFactoryMethodSmooth = void 0;
class vu extends pr {
}
vu.prototype.ValueTypeName = "vector";
class xu {
    constructor(e="", t=-1, i=[], r=Jp) {
        this.name = e,
        this.tracks = i,
        this.duration = t,
        this.blendMode = r,
        this.uuid = Ai(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , i = e.tracks
          , r = 1 / (e.fps || 1);
        for (let o = 0, l = i.length; o !== l; ++o)
            t.push(mU(i[o]).scale(r));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , i = e.tracks
          , r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = i.length; s !== o; ++s)
            t.push(pr.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length
          , o = [];
        for (let l = 0; l < s; l++) {
            let u = []
              , f = [];
            u.push((l + s - 1) % s, l, (l + 1) % s),
            f.push(0, 1, 0);
            const d = mE(u);
            u = H1(u, 1, d),
            f = H1(f, 1, d),
            !r && u[0] === 0 && (u.push(s),
            f.push(f[0])),
            o.push(new gu(".morphTargetInfluences[" + t[l].name + "]",u,f).scale(1 / i))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t)
                return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let l = 0, u = e.length; l < u; l++) {
            const f = e[l]
              , d = f.name.match(s);
            if (d && d.length > 1) {
                const h = d[1];
                let m = r[h];
                m || (r[h] = m = []),
                m.push(f)
            }
        }
        const o = [];
        for (const l in r)
            o.push(this.CreateFromMorphTargetSequence(l, r[l], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const i = function(h, m, g, x, S) {
            if (g.length !== 0) {
                const _ = []
                  , v = [];
                Lx(g, _, v, x),
                _.length !== 0 && S.push(new h(m,_,v))
            }
        }
          , r = []
          , s = e.name || "default"
          , o = e.fps || 30
          , l = e.blendMode;
        let u = e.length || -1;
        const f = e.hierarchy || [];
        for (let h = 0; h < f.length; h++) {
            const m = f[h].keys;
            if (!(!m || m.length === 0))
                if (m[0].morphTargets) {
                    const g = {};
                    let x;
                    for (x = 0; x < m.length; x++)
                        if (m[x].morphTargets)
                            for (let S = 0; S < m[x].morphTargets.length; S++)
                                g[m[x].morphTargets[S]] = -1;
                    for (const S in g) {
                        const _ = []
                          , v = [];
                        for (let M = 0; M !== m[x].morphTargets.length; ++M) {
                            const w = m[x];
                            _.push(w.time),
                            v.push(w.morphTarget === S ? 1 : 0)
                        }
                        r.push(new gu(".morphTargetInfluence[" + S + "]",_,v))
                    }
                    u = g.length * o
                } else {
                    const g = ".bones[" + t[h].name + "]";
                    i(vu, g + ".position", m, "pos", r),
                    i(Gu, g + ".quaternion", m, "rot", r),
                    i(vu, g + ".scale", m, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s,u,r,l)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function pU(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return gu;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return vu;
    case "color":
        return Ox;
    case "quaternion":
        return Gu;
    case "bool":
    case "boolean":
        return Yo;
    case "string":
        return Zo
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function mU(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = pU(n.type);
    if (n.times === void 0) {
        const t = []
          , i = [];
        Lx(n.keys, t, i, "value"),
        n.times = t,
        n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const ns = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class Dx {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, l = 0, u;
        const f = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(d) {
            l++,
            s === !1 && r.onStart !== void 0 && r.onStart(d, o, l),
            s = !0
        }
        ,
        this.itemEnd = function(d) {
            o++,
            r.onProgress !== void 0 && r.onProgress(d, o, l),
            o === l && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(d) {
            r.onError !== void 0 && r.onError(d)
        }
        ,
        this.resolveURL = function(d) {
            return u ? u(d) : d
        }
        ,
        this.setURLModifier = function(d) {
            return u = d,
            this
        }
        ,
        this.addHandler = function(d, h) {
            return f.push(d, h),
            this
        }
        ,
        this.removeHandler = function(d) {
            const h = f.indexOf(d);
            return h !== -1 && f.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(d) {
            for (let h = 0, m = f.length; h < m; h += 2) {
                const g = f[h]
                  , x = f[h + 1];
                if (g.global && (g.lastIndex = 0),
                g.test(d))
                    return x
            }
            return null
        }
    }
}
const _E = new Dx;
class vi {
    constructor(e) {
        this.manager = e !== void 0 ? e : _E,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
vi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Jr = {};
class gU extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class ls extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = ns.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (Jr[e] !== void 0) {
            Jr[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        Jr[e] = [],
        Jr[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , l = this.mimeType
          , u = this.responseType;
        fetch(o).then(f => {
            if (f.status === 200 || f.status === 0) {
                if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
                    return f;
                const d = Jr[e]
                  , h = f.body.getReader()
                  , m = f.headers.get("X-File-Size") || f.headers.get("Content-Length")
                  , g = m ? parseInt(m) : 0
                  , x = g !== 0;
                let S = 0;
                const _ = new ReadableStream({
                    start(v) {
                        M();
                        function M() {
                            h.read().then( ({done: w, value: E}) => {
                                if (w)
                                    v.close();
                                else {
                                    S += E.byteLength;
                                    const O = new ProgressEvent("progress",{
                                        lengthComputable: x,
                                        loaded: S,
                                        total: g
                                    });
                                    for (let R = 0, A = d.length; R < A; R++) {
                                        const F = d[R];
                                        F.onProgress && F.onProgress(O)
                                    }
                                    v.enqueue(E),
                                    M()
                                }
                            }
                            , w => {
                                v.error(w)
                            }
                            )
                        }
                    }
                });
                return new Response(_)
            } else
                throw new gU(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,f)
        }
        ).then(f => {
            switch (u) {
            case "arraybuffer":
                return f.arrayBuffer();
            case "blob":
                return f.blob();
            case "document":
                return f.text().then(d => new DOMParser().parseFromString(d, l));
            case "json":
                return f.json();
            default:
                if (l === void 0)
                    return f.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(l)
                      , m = h && h[1] ? h[1].toLowerCase() : void 0
                      , g = new TextDecoder(m);
                    return f.arrayBuffer().then(x => g.decode(x))
                }
            }
        }
        ).then(f => {
            ns.add(e, f);
            const d = Jr[e];
            delete Jr[e];
            for (let h = 0, m = d.length; h < m; h++) {
                const g = d[h];
                g.onLoad && g.onLoad(f)
            }
        }
        ).catch(f => {
            const d = Jr[e];
            if (d === void 0)
                throw this.manager.itemError(e),
                f;
            delete Jr[e];
            for (let h = 0, m = d.length; h < m; h++) {
                const g = d[h];
                g.onError && g.onError(f)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class vU extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new ls(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(l) {
            try {
                t(s.parse(JSON.parse(l)))
            } catch (u) {
                r ? r(u) : console.error(u),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = xu.parse(e[i]);
            t.push(r)
        }
        return t
    }
}
class xU extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = []
          , l = new am
          , u = new ls(this.manager);
        u.setPath(this.path),
        u.setResponseType("arraybuffer"),
        u.setRequestHeader(this.requestHeader),
        u.setWithCredentials(s.withCredentials);
        let f = 0;
        function d(h) {
            u.load(e[h], function(m) {
                const g = s.parse(m, !0);
                o[h] = {
                    width: g.width,
                    height: g.height,
                    format: g.format,
                    mipmaps: g.mipmaps
                },
                f += 1,
                f === 6 && (g.mipmapCount === 1 && (l.minFilter = ln),
                l.image = o,
                l.format = g.format,
                l.needsUpdate = !0,
                t && t(l))
            }, i, r)
        }
        if (Array.isArray(e))
            for (let h = 0, m = e.length; h < m; ++h)
                d(h);
        else
            u.load(e, function(h) {
                const m = s.parse(h, !0);
                if (m.isCubemap) {
                    const g = m.mipmaps.length / m.mipmapCount;
                    for (let x = 0; x < g; x++) {
                        o[x] = {
                            mipmaps: []
                        };
                        for (let S = 0; S < m.mipmapCount; S++)
                            o[x].mipmaps.push(m.mipmaps[x * m.mipmapCount + S]),
                            o[x].format = m.format,
                            o[x].width = m.width,
                            o[x].height = m.height
                    }
                    l.image = o
                } else
                    l.image.width = m.width,
                    l.image.height = m.height,
                    l.mipmaps = m.mipmaps;
                m.mipmapCount === 1 && (l.minFilter = ln),
                l.format = m.format,
                l.needsUpdate = !0,
                t && t(l)
            }, i, r);
        return l
    }
}
class _u extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = ns.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const l = fu("img");
        function u() {
            d(),
            ns.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function f(h) {
            d(),
            r && r(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function d() {
            l.removeEventListener("load", u, !1),
            l.removeEventListener("error", f, !1)
        }
        return l.addEventListener("load", u, !1),
        l.addEventListener("error", f, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        l.src = e,
        l
    }
}
class _U extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new Fu;
        s.colorSpace = Hi;
        const o = new _u(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let l = 0;
        function u(f) {
            o.load(e[f], function(d) {
                s.images[f] = d,
                l++,
                l === 6 && (s.needsUpdate = !0,
                t && t(s))
            }, void 0, r)
        }
        for (let f = 0; f < e.length; ++f)
            u(f);
        return s
    }
}
class yU extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Ir
          , l = new ls(this.manager);
        return l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setPath(this.path),
        l.setWithCredentials(s.withCredentials),
        l.load(e, function(u) {
            let f;
            try {
                f = s.parse(u)
            } catch (d) {
                if (r !== void 0)
                    r(d);
                else {
                    console.error(d);
                    return
                }
            }
            f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width,
            o.image.height = f.height,
            o.image.data = f.data),
            o.wrapS = f.wrapS !== void 0 ? f.wrapS : Xi,
            o.wrapT = f.wrapT !== void 0 ? f.wrapT : Xi,
            o.magFilter = f.magFilter !== void 0 ? f.magFilter : ln,
            o.minFilter = f.minFilter !== void 0 ? f.minFilter : ln,
            o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1,
            f.colorSpace !== void 0 && (o.colorSpace = f.colorSpace),
            f.flipY !== void 0 && (o.flipY = f.flipY),
            f.format !== void 0 && (o.format = f.format),
            f.type !== void 0 && (o.type = f.type),
            f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps,
            o.minFilter = Cr),
            f.mipmapCount === 1 && (o.minFilter = ln),
            f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, f)
        }, i, r),
        o
    }
}
class SU extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new en
          , o = new _u(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(l) {
            s.image = l,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
class Zs extends It {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Oe(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
class yE extends Zs {
    constructor(e, t, i) {
        super(e, i),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(It.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Oe(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const Vg = new ct
  , sM = new B
  , oM = new B;
class Ux {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new he(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new ct,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new ku,
        this._frameExtents = new he(1,1),
        this._viewportCount = 1,
        this._viewports = [new Bt(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        sM.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(sM),
        oM.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(oM),
        t.updateMatrixWorld(),
        Vg.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Vg),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(Vg)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class MU extends Ux {
    constructor() {
        super(new yn(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , i = hl * 2 * e.angle * this.focus
          , r = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i,
        t.aspect = r,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class SE extends Zs {
    constructor(e, t, i=0, r=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(It.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new It,
        this.distance = i,
        this.angle = r,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new MU
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const aM = new ct
  , mc = new B
  , Hg = new B;
class wU extends Ux {
    constructor() {
        super(new yn(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new he(4,2),
        this._viewportCount = 6,
        this._viewports = [new Bt(2,1,1,1), new Bt(0,1,1,1), new Bt(3,1,1,1), new Bt(1,1,1,1), new Bt(3,0,1,1), new Bt(1,0,1,1)],
        this._cubeDirections = [new B(1,0,0), new B(-1,0,0), new B(0,0,1), new B(0,0,-1), new B(0,1,0), new B(0,-1,0)],
        this._cubeUps = [new B(0,1,0), new B(0,1,0), new B(0,1,0), new B(0,1,0), new B(0,0,1), new B(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const i = this.camera
          , r = this.matrix
          , s = e.distance || i.far;
        s !== i.far && (i.far = s,
        i.updateProjectionMatrix()),
        mc.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(mc),
        Hg.copy(i.position),
        Hg.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(Hg),
        i.updateMatrixWorld(),
        r.makeTranslation(-mc.x, -mc.y, -mc.z),
        aM.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(aM)
    }
}
class ME extends Zs {
    constructor(e, t, i=0, r=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = r,
        this.shadow = new wU
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class bU extends Ux {
    constructor() {
        super(new qo(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class wE extends Zs {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(It.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new It,
        this.shadow = new bU
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class bE extends Zs {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class EE extends Zs {
    constructor(e, t, i=10, r=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = i,
        this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class CE {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new B)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * r),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * i),
        t.addScaledVector(o[4], 1.092548 * (i * r)),
        t.addScaledVector(o[5], 1.092548 * (r * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (i * s)),
        t.addScaledVector(o[8], .546274 * (i * i - r * r)),
        t
    }
    getIrradianceAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * r),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * i),
        t.addScaledVector(o[4], 2 * .429043 * i * r),
        t.addScaledVector(o[5], 2 * .429043 * r * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * i * s),
        t.addScaledVector(o[8], .429043 * (i * i - r * r)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e=[], t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z;
        t[0] = .282095,
        t[1] = .488603 * r,
        t[2] = .488603 * s,
        t[3] = .488603 * i,
        t[4] = 1.092548 * i * r,
        t[5] = 1.092548 * r * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * i * s,
        t[8] = .546274 * (i * i - r * r)
    }
}
class TE extends Zs {
    constructor(e=new CE, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class Mm extends vi {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, i, r) {
        const s = this
          , o = new ls(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(l) {
            try {
                t(s.parse(JSON.parse(l)))
            } catch (u) {
                r ? r(u) : console.error(u),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;
        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s),
            t[s]
        }
        const r = Mm.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid),
        e.name !== void 0 && (r.name = e.name),
        e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
        e.roughness !== void 0 && (r.roughness = e.roughness),
        e.metalness !== void 0 && (r.metalness = e.metalness),
        e.sheen !== void 0 && (r.sheen = e.sheen),
        e.sheenColor !== void 0 && (r.sheenColor = new Oe().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive),
        e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (r.shininess = e.shininess),
        e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness),
        e.dispersion !== void 0 && (r.dispersion = e.dispersion),
        e.iridescence !== void 0 && (r.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (r.transmission = e.transmission),
        e.thickness !== void 0 && (r.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor),
        e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
        e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation),
        e.fog !== void 0 && (r.fog = e.fog),
        e.flatShading !== void 0 && (r.flatShading = e.flatShading),
        e.blending !== void 0 && (r.blending = e.blending),
        e.combine !== void 0 && (r.combine = e.combine),
        e.side !== void 0 && (r.side = e.side),
        e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (r.opacity = e.opacity),
        e.transparent !== void 0 && (r.transparent = e.transparent),
        e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
        e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
        e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
        e.depthTest !== void 0 && (r.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
        e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
        e.blendDst !== void 0 && (r.blendDst = e.blendDst),
        e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
        e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
        e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
        e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha),
        e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor),
        e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
        e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
        e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
        e.wireframe !== void 0 && (r.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (r.rotation = e.rotation),
        e.linewidth !== void 0 && (r.linewidth = e.linewidth),
        e.dashSize !== void 0 && (r.dashSize = e.dashSize),
        e.gapSize !== void 0 && (r.gapSize = e.gapSize),
        e.scale !== void 0 && (r.scale = e.scale),
        e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (r.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (r.visible = e.visible),
        e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
        e.userData !== void 0 && (r.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {},
                o.type) {
                case "t":
                    r.uniforms[s].value = i(o.value);
                    break;
                case "c":
                    r.uniforms[s].value = new Oe().setHex(o.value);
                    break;
                case "v2":
                    r.uniforms[s].value = new he().fromArray(o.value);
                    break;
                case "v3":
                    r.uniforms[s].value = new B().fromArray(o.value);
                    break;
                case "v4":
                    r.uniforms[s].value = new Bt().fromArray(o.value);
                    break;
                case "m3":
                    r.uniforms[s].value = new xt().fromArray(o.value);
                    break;
                case "m4":
                    r.uniforms[s].value = new ct().fromArray(o.value);
                    break;
                default:
                    r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines),
        e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const s in e.extensions)
                r.extensions[s] = e.extensions[s];
        if (e.lights !== void 0 && (r.lights = e.lights),
        e.clipping !== void 0 && (r.clipping = e.clipping),
        e.size !== void 0 && (r.size = e.size),
        e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (r.map = i(e.map)),
        e.matcap !== void 0 && (r.matcap = i(e.matcap)),
        e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
        e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
        e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
        e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
            r.normalScale = new he().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)),
        e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
        e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
        e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
        e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)),
        e.envMap !== void 0 && (r.envMap = i(e.envMap)),
        e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation),
        e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
        e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
        e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
        e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new he().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)),
        e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
        e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
        e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
        r
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: sE,
            SpriteMaterial: Mx,
            RawShaderMaterial: oE,
            ShaderMaterial: Yi,
            PointsMaterial: bx,
            MeshPhysicalMaterial: aE,
            MeshStandardMaterial: Ix,
            MeshPhongMaterial: lE,
            MeshToonMaterial: cE,
            MeshNormalMaterial: uE,
            MeshLambertMaterial: fE,
            MeshDepthMaterial: yx,
            MeshDistanceMaterial: Sx,
            MeshBasicMaterial: qs,
            MeshMatcapMaterial: dE,
            LineDashedMaterial: hE,
            LineBasicMaterial: oi,
            Material: Fn
        };
        return new t[e]
    }
}
class G1 {
    static decodeText(e) {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
        typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++)
            t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class AE extends St {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class RE extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new ls(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(l) {
            try {
                t(s.parse(JSON.parse(l)))
            } catch (u) {
                r ? r(u) : console.error(u),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {}
          , i = {};
        function r(g, x) {
            if (t[x] !== void 0)
                return t[x];
            const _ = g.interleavedBuffers[x]
              , v = s(g, _.buffer)
              , M = Xa(_.type, v)
              , w = new sm(M,_.stride);
            return w.uuid = _.uuid,
            t[x] = w,
            w
        }
        function s(g, x) {
            if (i[x] !== void 0)
                return i[x];
            const _ = g.arrayBuffers[x]
              , v = new Uint32Array(_).buffer;
            return i[x] = v,
            v
        }
        const o = e.isInstancedBufferGeometry ? new AE : new St
          , l = e.data.index;
        if (l !== void 0) {
            const g = Xa(l.type, l.array);
            o.setIndex(new Vt(g,1))
        }
        const u = e.data.attributes;
        for (const g in u) {
            const x = u[g];
            let S;
            if (x.isInterleavedBufferAttribute) {
                const _ = r(e.data, x.data);
                S = new Ho(_,x.itemSize,x.offset,x.normalized)
            } else {
                const _ = Xa(x.type, x.array)
                  , v = x.isInstancedBufferAttribute ? ml : Vt;
                S = new v(_,x.itemSize,x.normalized)
            }
            x.name !== void 0 && (S.name = x.name),
            x.usage !== void 0 && S.setUsage(x.usage),
            o.setAttribute(g, S)
        }
        const f = e.data.morphAttributes;
        if (f)
            for (const g in f) {
                const x = f[g]
                  , S = [];
                for (let _ = 0, v = x.length; _ < v; _++) {
                    const M = x[_];
                    let w;
                    if (M.isInterleavedBufferAttribute) {
                        const E = r(e.data, M.data);
                        w = new Ho(E,M.itemSize,M.offset,M.normalized)
                    } else {
                        const E = Xa(M.type, M.array);
                        w = new Vt(E,M.itemSize,M.normalized)
                    }
                    M.name !== void 0 && (w.name = M.name),
                    S.push(w)
                }
                o.morphAttributes[g] = S
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let g = 0, x = h.length; g !== x; ++g) {
                const S = h[g];
                o.addGroup(S.start, S.count, S.materialIndex)
            }
        const m = e.data.boundingSphere;
        if (m !== void 0) {
            const g = new B;
            m.center !== void 0 && g.fromArray(m.center),
            o.boundingSphere = new Yn(g,m.radius)
        }
        return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o
    }
}
class EU extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = this.path === "" ? G1.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const l = new ls(this.manager);
        l.setPath(this.path),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(u) {
            let f = null;
            try {
                f = JSON.parse(u)
            } catch (h) {
                r !== void 0 && r(h),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
                return
            }
            const d = f.metadata;
            if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(f, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this
          , r = this.path === "" ? G1.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new ls(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t)
          , l = JSON.parse(o)
          , u = l.metadata;
        if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(l)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations)
          , r = this.parseShapes(e.shapes)
          , s = this.parseGeometries(e.geometries, r)
          , o = this.parseImages(e.images, function() {
            t !== void 0 && t(f)
        })
          , l = this.parseTextures(e.textures, o)
          , u = this.parseMaterials(e.materials, l)
          , f = this.parseObject(e.object, s, u, l, i)
          , d = this.parseSkeletons(e.skeletons, f);
        if (this.bindSkeletons(f, d),
        this.bindLightTargets(f),
        t !== void 0) {
            let h = !1;
            for (const m in o)
                if (o[m].data instanceof HTMLImageElement) {
                    h = !0;
                    break
                }
            h === !1 && t(f)
        }
        return f
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , r = this.parseGeometries(e.geometries, i)
          , s = await this.parseImagesAsync(e.images)
          , o = this.parseTextures(e.textures, s)
          , l = this.parseMaterials(e.materials, o)
          , u = this.parseObject(e.object, r, l, o, t)
          , f = this.parseSkeletons(e.skeletons, u);
        return this.bindSkeletons(u, f),
        this.bindLightTargets(u),
        u
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new ko().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {}
          , r = {};
        if (t.traverse(function(s) {
            s.isBone && (r[s.uuid] = s)
        }),
        e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const l = new om().fromJSON(e[s], r);
                i[l.uuid] = l
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new RE;
            for (let s = 0, o = e.length; s < o; s++) {
                let l;
                const u = e[s];
                switch (u.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    l = r.parse(u);
                    break;
                default:
                    u.type in rM ? l = rM[u.type].fromJSON(u, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${u.type}"`)
                }
                l.uuid = u.uuid,
                u.name !== void 0 && (l.name = u.name),
                u.userData !== void 0 && (l.userData = u.userData),
                i[u.uuid] = l
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {}
          , r = {};
        if (e !== void 0) {
            const s = new Mm;
            s.setTextures(t);
            for (let o = 0, l = e.length; o < l; o++) {
                const u = e[o];
                i[u.uuid] === void 0 && (i[u.uuid] = s.parse(u)),
                r[u.uuid] = i[u.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i]
                  , s = xu.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this
          , r = {};
        let s;
        function o(u) {
            return i.manager.itemStart(u),
            s.load(u, function() {
                i.manager.itemEnd(u)
            }, void 0, function() {
                i.manager.itemError(u),
                i.manager.itemEnd(u)
            })
        }
        function l(u) {
            if (typeof u == "string") {
                const f = u
                  , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
                return o(d)
            } else
                return u.data ? {
                    data: Xa(u.type, u.data),
                    width: u.width,
                    height: u.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const u = new Dx(t);
            s = new _u(u),
            s.setCrossOrigin(this.crossOrigin);
            for (let f = 0, d = e.length; f < d; f++) {
                const h = e[f]
                  , m = h.url;
                if (Array.isArray(m)) {
                    const g = [];
                    for (let x = 0, S = m.length; x < S; x++) {
                        const _ = m[x]
                          , v = l(_);
                        v !== null && (v instanceof HTMLImageElement ? g.push(v) : g.push(new Ir(v.data,v.width,v.height)))
                    }
                    r[h.uuid] = new Po(g)
                } else {
                    const g = l(h.url);
                    r[h.uuid] = new Po(g)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this
          , i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const l = o
                  , u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
                return await r.loadAsync(u)
            } else
                return o.data ? {
                    data: Xa(o.type, o.data),
                    width: o.width,
                    height: o.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new _u(this.manager),
            r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, l = e.length; o < l; o++) {
                const u = e[o]
                  , f = u.url;
                if (Array.isArray(f)) {
                    const d = [];
                    for (let h = 0, m = f.length; h < m; h++) {
                        const g = f[h]
                          , x = await s(g);
                        x !== null && (x instanceof HTMLImageElement ? d.push(x) : d.push(new Ir(x.data,x.width,x.height)))
                    }
                    i[u.uuid] = new Po(d)
                } else {
                    const d = await s(u.url);
                    i[u.uuid] = new Po(d)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
            o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const l = e[s];
                l.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
                t[l.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", l.image);
                const u = t[l.image]
                  , f = u.data;
                let d;
                Array.isArray(f) ? (d = new Fu,
                f.length === 6 && (d.needsUpdate = !0)) : (f && f.data ? d = new Ir : d = new en,
                f && (d.needsUpdate = !0)),
                d.source = u,
                d.uuid = l.uuid,
                l.name !== void 0 && (d.name = l.name),
                l.mapping !== void 0 && (d.mapping = i(l.mapping, CU)),
                l.channel !== void 0 && (d.channel = l.channel),
                l.offset !== void 0 && d.offset.fromArray(l.offset),
                l.repeat !== void 0 && d.repeat.fromArray(l.repeat),
                l.center !== void 0 && d.center.fromArray(l.center),
                l.rotation !== void 0 && (d.rotation = l.rotation),
                l.wrap !== void 0 && (d.wrapS = i(l.wrap[0], lM),
                d.wrapT = i(l.wrap[1], lM)),
                l.format !== void 0 && (d.format = l.format),
                l.internalFormat !== void 0 && (d.internalFormat = l.internalFormat),
                l.type !== void 0 && (d.type = l.type),
                l.colorSpace !== void 0 && (d.colorSpace = l.colorSpace),
                l.minFilter !== void 0 && (d.minFilter = i(l.minFilter, cM)),
                l.magFilter !== void 0 && (d.magFilter = i(l.magFilter, cM)),
                l.anisotropy !== void 0 && (d.anisotropy = l.anisotropy),
                l.flipY !== void 0 && (d.flipY = l.flipY),
                l.generateMipmaps !== void 0 && (d.generateMipmaps = l.generateMipmaps),
                l.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = l.premultiplyAlpha),
                l.unpackAlignment !== void 0 && (d.unpackAlignment = l.unpackAlignment),
                l.compareFunction !== void 0 && (d.compareFunction = l.compareFunction),
                l.userData !== void 0 && (d.userData = l.userData),
                r[l.uuid] = d
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;
        function l(m) {
            return t[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", m),
            t[m]
        }
        function u(m) {
            if (m !== void 0) {
                if (Array.isArray(m)) {
                    const g = [];
                    for (let x = 0, S = m.length; x < S; x++) {
                        const _ = m[x];
                        i[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", _),
                        g.push(i[_])
                    }
                    return g
                }
                return i[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", m),
                i[m]
            }
        }
        function f(m) {
            return r[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", m),
            r[m]
        }
        let d, h;
        switch (e.type) {
        case "Scene":
            o = new ip,
            e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Oe(e.background) : o.background = f(e.background)),
            e.environment !== void 0 && (o.environment = f(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new rm(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new im(e.fog.color,e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
            e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity),
            e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation),
            e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity),
            e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
            break;
        case "PerspectiveCamera":
            o = new yn(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new qo(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new bE(e.color,e.intensity);
            break;
        case "DirectionalLight":
            o = new wE(e.color,e.intensity),
            o.target = e.target || "";
            break;
        case "PointLight":
            o = new ME(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            o = new EE(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            o = new SE(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),
            o.target = e.target || "";
            break;
        case "HemisphereLight":
            o = new yE(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            o = new TE().fromJSON(e);
            break;
        case "SkinnedMesh":
            d = l(e.geometry),
            h = u(e.material),
            o = new Wb(d,h),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            d = l(e.geometry),
            h = u(e.material),
            o = new Sn(d,h);
            break;
        case "InstancedMesh":
            d = l(e.geometry),
            h = u(e.material);
            const m = e.count
              , g = e.instanceMatrix
              , x = e.instanceColor;
            o = new jb(d,h,m),
            o.instanceMatrix = new ml(new Float32Array(g.array),16),
            x !== void 0 && (o.instanceColor = new ml(new Float32Array(x.array),x.itemSize));
            break;
        case "BatchedMesh":
            d = l(e.geometry),
            h = u(e.material),
            o = new Xb(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,h),
            o.geometry = d,
            o.perObjectFrustumCulled = e.perObjectFrustumCulled,
            o.sortObjects = e.sortObjects,
            o._drawRanges = e.drawRanges,
            o._reservedRanges = e.reservedRanges,
            o._visibility = e.visibility,
            o._active = e.active,
            o._bounds = e.bounds.map(S => {
                const _ = new si;
                _.min.fromArray(S.boxMin),
                _.max.fromArray(S.boxMax);
                const v = new Yn;
                return v.radius = S.sphereRadius,
                v.center.fromArray(S.sphereCenter),
                {
                    boxInitialized: S.boxInitialized,
                    box: _,
                    sphereInitialized: S.sphereInitialized,
                    sphere: v
                }
            }
            ),
            o._maxInstanceCount = e.maxInstanceCount,
            o._maxVertexCount = e.maxVertexCount,
            o._maxIndexCount = e.maxIndexCount,
            o._geometryInitialized = e.geometryInitialized,
            o._geometryCount = e.geometryCount,
            o._matricesTexture = f(e.matricesTexture.uuid),
            e.colorsTexture !== void 0 && (o._colorsTexture = f(e.colorsTexture.uuid));
            break;
        case "LOD":
            o = new Gb;
            break;
        case "Line":
            o = new Ws(l(e.geometry),u(e.material));
            break;
        case "LineLoop":
            o = new $b(l(e.geometry),u(e.material));
            break;
        case "LineSegments":
            o = new Fr(l(e.geometry),u(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new qb(l(e.geometry),u(e.material));
            break;
        case "Sprite":
            o = new Hb(u(e.material));
            break;
        case "Group":
            o = new qa;
            break;
        case "Bone":
            o = new wx;
            break;
        default:
            o = new It
        }
        if (o.uuid = e.uuid,
        e.name !== void 0 && (o.name = e.name),
        e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position),
        e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && o.scale.fromArray(e.scale)),
        e.up !== void 0 && o.up.fromArray(e.up),
        e.castShadow !== void 0 && (o.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.intensity !== void 0 && (o.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (o.visible = e.visible),
        e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
        e.userData !== void 0 && (o.userData = e.userData),
        e.layers !== void 0 && (o.layers.mask = e.layers),
        e.children !== void 0) {
            const m = e.children;
            for (let g = 0; g < m.length; g++)
                o.add(this.parseObject(m[g], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const m = e.animations;
            for (let g = 0; g < m.length; g++) {
                const x = m[g];
                o.animations.push(s[x])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const m = e.levels;
            for (let g = 0; g < m.length; g++) {
                const x = m[g]
                  , S = o.getObjectByProperty("uuid", x.object);
                S !== void 0 && o.addLevel(S, x.distance, x.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
    bindLightTargets(e) {
        e.traverse(function(t) {
            if (t.isDirectionalLight || t.isSpotLight) {
                const i = t.target
                  , r = e.getObjectByProperty("uuid", i);
                r !== void 0 ? t.target = r : t.target = new It
            }
        })
    }
}
const CU = {
    UVMapping: jp,
    CubeReflectionMapping: os,
    CubeRefractionMapping: Gs,
    EquirectangularReflectionMapping: eu,
    EquirectangularRefractionMapping: tu,
    CubeUVReflectionMapping: bl
}
  , lM = {
    RepeatWrapping: nu,
    ClampToEdgeWrapping: Xi,
    MirroredRepeatWrapping: iu
}
  , cM = {
    NearestFilter: Ln,
    NearestMipmapNearestFilter: Qv,
    NearestMipmapLinearFilter: ja,
    LinearFilter: ln,
    LinearMipmapNearestFilter: Pc,
    LinearMipmapLinearFilter: Cr
};
class TU extends vi {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = ns.get(e);
        if (o !== void 0) {
            if (s.manager.itemStart(e),
            o.then) {
                o.then(f => {
                    t && t(f),
                    s.manager.itemEnd(e)
                }
                ).catch(f => {
                    r && r(f)
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o
        }
        const l = {};
        l.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        l.headers = this.requestHeader;
        const u = fetch(e, l).then(function(f) {
            return f.blob()
        }).then(function(f) {
            return createImageBitmap(f, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(f) {
            return ns.add(e, f),
            t && t(f),
            s.manager.itemEnd(e),
            f
        }).catch(function(f) {
            r && r(f),
            ns.remove(e),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        });
        ns.add(e, u),
        s.manager.itemStart(e)
    }
}
let Gd;
class Fx {
    static getContext() {
        return Gd === void 0 && (Gd = new (window.AudioContext || window.webkitAudioContext)),
        Gd
    }
    static setContext(e) {
        Gd = e
    }
}
class AU extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new ls(this.manager);
        o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(u) {
            try {
                const f = u.slice(0);
                Fx.getContext().decodeAudioData(f, function(h) {
                    t(h)
                }).catch(l)
            } catch (f) {
                l(f)
            }
        }, i, r);
        function l(u) {
            r ? r(u) : console.error(u),
            s.manager.itemError(e)
        }
    }
}
const uM = new ct
  , fM = new ct
  , xo = new ct;
class RU {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new yn,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new yn,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            xo.copy(e.projectionMatrix);
            const r = t.eyeSep / 2
              , s = r * t.near / t.focus
              , o = t.near * Math.tan(Uo * t.fov * .5) / t.zoom;
            let l, u;
            fM.elements[12] = -r,
            uM.elements[12] = r,
            l = -o * t.aspect + s,
            u = o * t.aspect + s,
            xo.elements[0] = 2 * t.near / (u - l),
            xo.elements[8] = (u + l) / (u - l),
            this.cameraL.projectionMatrix.copy(xo),
            l = -o * t.aspect - s,
            u = o * t.aspect - s,
            xo.elements[0] = 2 * t.near / (u - l),
            xo.elements[8] = (u + l) / (u - l),
            this.cameraR.projectionMatrix.copy(xo)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(fM),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(uM)
    }
}
class kx {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = dM(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = dM();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function dM() {
    return (typeof performance > "u" ? Date : performance).now()
}
const _o = new B
  , hM = new mi
  , PU = new B
  , yo = new B;
class IU extends It {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = Fx.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new kx
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , i = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(_o, hM, PU),
        yo.set(0, 0, -1).applyQuaternion(hM),
        t.positionX) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(_o.x, r),
            t.positionY.linearRampToValueAtTime(_o.y, r),
            t.positionZ.linearRampToValueAtTime(_o.z, r),
            t.forwardX.linearRampToValueAtTime(yo.x, r),
            t.forwardY.linearRampToValueAtTime(yo.y, r),
            t.forwardZ.linearRampToValueAtTime(yo.z, r),
            t.upX.linearRampToValueAtTime(i.x, r),
            t.upY.linearRampToValueAtTime(i.y, r),
            t.upZ.linearRampToValueAtTime(i.z, r)
        } else
            t.setPosition(_o.x, _o.y, _o.z),
            t.setOrientation(yo.x, yo.y, yo.z, i.x, i.y, i.z)
    }
}
class PE extends It {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source !== null && (this.source.stop(),
        this.source.onended = null),
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        return this.detune = e,
        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
        this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const So = new B
  , pM = new mi
  , LU = new B
  , Mo = new B;
class NU extends PE {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    connect() {
        super.connect(),
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, i) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = i,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(So, pM, LU),
        Mo.set(0, 0, 1).applyQuaternion(pM);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(So.x, i),
            t.positionY.linearRampToValueAtTime(So.y, i),
            t.positionZ.linearRampToValueAtTime(So.z, i),
            t.orientationX.linearRampToValueAtTime(Mo.x, i),
            t.orientationY.linearRampToValueAtTime(Mo.y, i),
            t.orientationZ.linearRampToValueAtTime(Mo.z, i)
        } else
            t.setPosition(So.x, So.y, So.z),
            t.setOrientation(Mo.x, Mo.y, Mo.z)
    }
}
class OU {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++)
            e += t[i];
        return e / t.length
    }
}
class IE {
    constructor(e, t, i) {
        this.binding = e,
        this.valueSize = i;
        let r, s, o;
        switch (t) {
        case "quaternion":
            r = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(i * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            r = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(i * 5);
            break;
        default:
            r = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = r,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer
          , r = this.valueSize
          , s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let l = 0; l !== r; ++l)
                i[s + l] = i[l];
            o = t
        } else {
            o += t;
            const l = t / o;
            this._mixBufferRegion(i, s, 0, l, r)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , i = this.valueSize
          , r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, r, 0, e, i),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , i = this.buffer
          , r = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , l = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const u = t * this._origIndex;
            this._mixBufferRegion(i, r, u, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let u = t, f = t + t; u !== f; ++u)
            if (i[u] !== i[u + t]) {
                l.setValue(i, r);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , i = this.valueSize
          , r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s)
            t[s] = t[r + s % i];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let i = e; i < t; i++)
            this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++)
            this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, r, s) {
        if (r >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[i + o]
    }
    _slerp(e, t, i, r) {
        mi.slerpFlat(e, t, e, t, e, i, r)
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        mi.multiplyQuaternionsFlat(e, o, e, t, e, i),
        mi.slerpFlat(e, t, e, t, e, o, r)
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let l = 0; l !== s; ++l) {
            const u = t + l;
            e[u] = e[u] * o + e[i + l] * r
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const l = t + o;
            e[l] = e[l] + e[i + o] * r
        }
    }
}
const Bx = "\\[\\]\\.:\\/"
  , DU = new RegExp("[" + Bx + "]","g")
  , zx = "[^" + Bx + "]"
  , UU = "[^" + Bx.replace("\\.", "") + "]"
  , FU = /((?:WC+[\/:])*)/.source.replace("WC", zx)
  , kU = /(WCOD+)?/.source.replace("WCOD", UU)
  , BU = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", zx)
  , zU = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", zx)
  , VU = new RegExp("^" + FU + kU + BU + zU + "$")
  , HU = ["material", "materials", "bones", "map"];
class GU {
    constructor(e, t, i) {
        const r = i || Pt.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_
          , r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
            i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].unbind()
    }
}
class Pt {
    constructor(e, t, i) {
        this.path = t,
        this.parsedPath = i || Pt.parseTrackName(t),
        this.node = Pt.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new Pt.Composite(e,t,i) : new Pt(e,t,i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(DU, "")
    }
    static parseTrackName(e) {
        const t = VU.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            HU.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r),
            i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0)
                return i
        }
        if (e.children) {
            const i = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const l = s[o];
                    if (l.name === t || l.uuid === t)
                        return l;
                    const u = i(l.children);
                    if (u)
                        return u
                }
                return null
            }
              , r = i(e.children);
            if (r)
                return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , i = t.objectName
          , r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = Pt.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (i) {
            let f = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let d = 0; d < e.length; d++)
                    if (e[d].name === f) {
                        f = d;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (f !== void 0) {
                if (e[f] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[f]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const f = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + r + " but it wasn't found.", e);
            return
        }
        let l = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? l = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (l = this.Versioning.MatrixWorldNeedsUpdate);
        let u = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            u = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (u = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (u = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[u],
        this.setValue = this.SetterByBindingTypeAndVersioning[u][l]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Pt.Composite = GU;
Pt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Pt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Pt.prototype.GetterByBindingType = [Pt.prototype._getValue_direct, Pt.prototype._getValue_array, Pt.prototype._getValue_arrayElement, Pt.prototype._getValue_toArray];
Pt.prototype.SetterByBindingTypeAndVersioning = [[Pt.prototype._setValue_direct, Pt.prototype._setValue_direct_setNeedsUpdate, Pt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Pt.prototype._setValue_array, Pt.prototype._setValue_array_setNeedsUpdate, Pt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Pt.prototype._setValue_arrayElement, Pt.prototype._setValue_arrayElement_setNeedsUpdate, Pt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Pt.prototype._setValue_fromArray, Pt.prototype._setValue_fromArray_setNeedsUpdate, Pt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class WU {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = Ai(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i)
            e[arguments[i].uuid] = i;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._paths
          , r = this._parsedPaths
          , s = this._bindings
          , o = s.length;
        let l, u = e.length, f = this.nCachedObjects_;
        for (let d = 0, h = arguments.length; d !== h; ++d) {
            const m = arguments[d]
              , g = m.uuid;
            let x = t[g];
            if (x === void 0) {
                x = u++,
                t[g] = x,
                e.push(m);
                for (let S = 0, _ = o; S !== _; ++S)
                    s[S].push(new Pt(m,i[S],r[S]))
            } else if (x < f) {
                l = e[x];
                const S = --f
                  , _ = e[S];
                t[_.uuid] = x,
                e[x] = _,
                t[g] = S,
                e[S] = m;
                for (let v = 0, M = o; v !== M; ++v) {
                    const w = s[v]
                      , E = w[S];
                    let O = w[x];
                    w[x] = E,
                    O === void 0 && (O = new Pt(m,i[v],r[v])),
                    w[S] = O
                }
            } else
                e[x] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = f
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, l = arguments.length; o !== l; ++o) {
            const u = arguments[o]
              , f = u.uuid
              , d = t[f];
            if (d !== void 0 && d >= s) {
                const h = s++
                  , m = e[h];
                t[m.uuid] = d,
                e[d] = m,
                t[f] = h,
                e[h] = u;
                for (let g = 0, x = r; g !== x; ++g) {
                    const S = i[g]
                      , _ = S[h]
                      , v = S[d];
                    S[d] = _,
                    S[h] = v
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_
          , o = e.length;
        for (let l = 0, u = arguments.length; l !== u; ++l) {
            const f = arguments[l]
              , d = f.uuid
              , h = t[d];
            if (h !== void 0)
                if (delete t[d],
                h < s) {
                    const m = --s
                      , g = e[m]
                      , x = --o
                      , S = e[x];
                    t[g.uuid] = h,
                    e[h] = g,
                    t[S.uuid] = m,
                    e[m] = S,
                    e.pop();
                    for (let _ = 0, v = r; _ !== v; ++_) {
                        const M = i[_]
                          , w = M[m]
                          , E = M[x];
                        M[h] = w,
                        M[m] = E,
                        M.pop()
                    }
                } else {
                    const m = --o
                      , g = e[m];
                    m > 0 && (t[g.uuid] = h),
                    e[h] = g,
                    e.pop();
                    for (let x = 0, S = r; x !== S; ++x) {
                        const _ = i[x];
                        _[h] = _[m],
                        _.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0)
            return s[r];
        const o = this._paths
          , l = this._parsedPaths
          , u = this._objects
          , f = u.length
          , d = this.nCachedObjects_
          , h = new Array(f);
        r = s.length,
        i[e] = r,
        o.push(e),
        l.push(t),
        s.push(h);
        for (let m = d, g = u.length; m !== g; ++m) {
            const x = u[m];
            h[m] = new Pt(x,e,t)
        }
        return h
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , i = t[e];
        if (i !== void 0) {
            const r = this._paths
              , s = this._parsedPaths
              , o = this._bindings
              , l = o.length - 1
              , u = o[l]
              , f = e[l];
            t[f] = i,
            o[i] = u,
            o.pop(),
            s[i] = s[l],
            s.pop(),
            r[i] = r[l],
            r.pop()
        }
    }
}
class LE {
    constructor(e, t, i=null, r=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i,
        this.blendMode = r;
        const s = t.tracks
          , o = s.length
          , l = new Array(o)
          , u = {
            endingStart: Ao,
            endingEnd: Ao
        };
        for (let f = 0; f !== o; ++f) {
            const d = s[f].createInterpolant(null);
            l[f] = d,
            d.settings = u
        }
        this._interpolantSettings = u,
        this._interpolants = l,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = pb,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        i) {
            const r = this._clip.duration
              , s = e._clip.duration
              , o = s / r
              , l = r / s;
            e.warp(1, o, t),
            this.warp(l, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const r = this._mixer
          , s = r.time
          , o = this.timeScale;
        let l = this._timeScaleInterpolant;
        l === null && (l = r._lendControlInterpolant(),
        this._timeScaleInterpolant = l);
        const u = l.parameterPositions
          , f = l.sampleValues;
        return u[0] = s,
        u[1] = s + i,
        f[0] = e / o,
        f[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const u = (e - s) * i;
            u < 0 || i === 0 ? t = 0 : (this._startTime = null,
            t = i * u)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , l = this._updateWeight(e);
        if (l > 0) {
            const u = this._interpolants
              , f = this._propertyBindings;
            switch (this.blendMode) {
            case cx:
                for (let d = 0, h = u.length; d !== h; ++d)
                    u[d].evaluate(o),
                    f[d].accumulateAdditive(l);
                break;
            case Jp:
            default:
                for (let d = 0, h = u.length; d !== h; ++d)
                    u[d].evaluate(o),
                    f[d].accumulate(r, l)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopFading(),
                r === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , i = this.loop;
        let r = this.time + e
          , s = this._loopCount;
        const o = i === mb;
        if (e === 0)
            return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === hb) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (r >= t)
                    r = t;
                else if (r < 0)
                    r = 0;
                else {
                    this.time = r;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = r,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            r >= t || r < 0) {
                const l = Math.floor(r / t);
                r -= t * l,
                s += Math.abs(l);
                const u = this.repetitions - s;
                if (u <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    r = e > 0 ? t : 0,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (u === 1) {
                        const f = e < 0;
                        this._setEndings(f, !f, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: l
                    })
                }
            } else
                this.time = r;
            if (o && (s & 1) === 1)
                return t - r
        }
        return r
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i ? (r.endingStart = Ro,
        r.endingEnd = Ro) : (e ? r.endingStart = this.zeroSlopeAtStart ? Ro : Ao : r.endingStart = su,
        t ? r.endingEnd = this.zeroSlopeAtEnd ? Ro : Ao : r.endingEnd = su)
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer
          , s = r.time;
        let o = this._weightInterpolant;
        o === null && (o = r._lendControlInterpolant(),
        this._weightInterpolant = o);
        const l = o.parameterPositions
          , u = o.sampleValues;
        return l[0] = s,
        u[0] = t,
        l[1] = s + e,
        u[1] = i,
        this
    }
}
const jU = new Float32Array(1);
class XU extends fs {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root
          , r = e._clip.tracks
          , s = r.length
          , o = e._propertyBindings
          , l = e._interpolants
          , u = i.uuid
          , f = this._bindingsByRootAndName;
        let d = f[u];
        d === void 0 && (d = {},
        f[u] = d);
        for (let h = 0; h !== s; ++h) {
            const m = r[h]
              , g = m.name;
            let x = d[g];
            if (x !== void 0)
                ++x.referenceCount,
                o[h] = x;
            else {
                if (x = o[h],
                x !== void 0) {
                    x._cacheIndex === null && (++x.referenceCount,
                    this._addInactiveBinding(x, u, g));
                    continue
                }
                const S = t && t._propertyBindings[h].binding.parsedPath;
                x = new IE(Pt.create(i, g, S),m.ValueTypeName,m.getValueSize()),
                ++x.referenceCount,
                this._addInactiveBinding(x, u, g),
                o[h] = x
            }
            l[h].resultBuffer = x.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid
                  , r = e._clip.uuid
                  , s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, r, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const l = o.knownActions;
            e._byClipCacheIndex = l.length,
            l.push(e)
        }
        e._cacheIndex = r.length,
        r.push(e),
        o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , i = t[t.length - 1]
          , r = e._cacheIndex;
        i._cacheIndex = r,
        t[r] = i,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , l = o[s]
          , u = l.knownActions
          , f = u[u.length - 1]
          , d = e._byClipCacheIndex;
        f._byClipCacheIndex = d,
        u[d] = f,
        u.pop(),
        e._byClipCacheIndex = null;
        const h = l.actionByRoot
          , m = (e._localRoot || this._root).uuid;
        delete h[m],
        u.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = this._nActiveActions++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = --this._nActiveActions
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName
          , s = this._bindings;
        let o = r[t];
        o === void 0 && (o = {},
        r[t] = o),
        o[i] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , i = e.binding
          , r = i.rootNode.uuid
          , s = i.path
          , o = this._bindingsByRootAndName
          , l = o[r]
          , u = t[t.length - 1]
          , f = e._cacheIndex;
        u._cacheIndex = f,
        t[f] = u,
        t.pop(),
        delete l[s],
        Object.keys(l).length === 0 && delete o[r]
    }
    _lendBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = this._nActiveBindings++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = --this._nActiveBindings
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new Nx(new Float32Array(2),new Float32Array(2),1,jU),
        i.__cacheIndex = t,
        e[t] = i),
        i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , i = e.__cacheIndex
          , r = --this._nActiveControlInterpolants
          , s = t[r];
        e.__cacheIndex = r,
        t[r] = e,
        s.__cacheIndex = i,
        t[i] = s
    }
    clipAction(e, t, i) {
        const r = t || this._root
          , s = r.uuid;
        let o = typeof e == "string" ? xu.findByName(r, e) : e;
        const l = o !== null ? o.uuid : e
          , u = this._actionsByClip[l];
        let f = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = Jp),
        u !== void 0) {
            const h = u.actionByRoot[s];
            if (h !== void 0 && h.blendMode === i)
                return h;
            f = u.knownActions[0],
            o === null && (o = f._clip)
        }
        if (o === null)
            return null;
        const d = new LE(this,o,t,i);
        return this._bindAction(d, f),
        this._addInactiveAction(d, l, s),
        d
    }
    existingAction(e, t) {
        const i = t || this._root
          , r = i.uuid
          , s = typeof e == "string" ? xu.findByName(i, e) : e
          , o = s ? s.uuid : e
          , l = this._actionsByClip[o];
        return l !== void 0 && l.actionByRoot[r] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i)
            e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , i = this._nActiveActions
          , r = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let f = 0; f !== i; ++f)
            t[f]._update(r, e, s, o);
        const l = this._bindings
          , u = this._nActiveBindings;
        for (let f = 0; f !== u; ++f)
            l[f].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , i = e.uuid
          , r = this._actionsByClip
          , s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let l = 0, u = o.length; l !== u; ++l) {
                const f = o[l];
                this._deactivateAction(f);
                const d = f._cacheIndex
                  , h = t[t.length - 1];
                f._cacheIndex = null,
                f._byClipCacheIndex = null,
                h._cacheIndex = d,
                t[d] = h,
                t.pop(),
                this._removeInactiveBindingsForAction(f)
            }
            delete r[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , i = this._actionsByClip;
        for (const o in i) {
            const l = i[o].actionByRoot
              , u = l[t];
            u !== void 0 && (this._deactivateAction(u),
            this._removeInactiveAction(u))
        }
        const r = this._bindingsByRootAndName
          , s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const l = s[o];
                l.restoreOriginalState(),
                this._removeInactiveBinding(l)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i),
        this._removeInactiveAction(i))
    }
}
class Vx {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new Vx(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let $U = 0;
class qU extends fs {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: $U++
        }),
        this.name = "",
        this.usage = cu,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = Array.isArray(t[i]) ? t[i] : [t[i]];
            for (let o = 0; o < s.length; o++)
                this.uniforms.push(s[o].clone())
        }
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class YU extends sm {
    constructor(e, t, i=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class ZU {
    constructor(e, t, i, r, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = i,
        this.elementSize = r,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
const mM = new ct;
class NE {
    constructor(e, t, i=0, r=1 / 0) {
        this.ray = new El(e,t),
        this.near = i,
        this.far = r,
        this.camera = null,
        this.layers = new Fo,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    setFromXRController(e) {
        return mM.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(mM),
        this
    }
    intersectObject(e, t=!0, i=[]) {
        return W1(e, this, i, t),
        i.sort(gM),
        i
    }
    intersectObjects(e, t=!0, i=[]) {
        for (let r = 0, s = e.length; r < s; r++)
            W1(e[r], this, i, t);
        return i.sort(gM),
        i
    }
}
function gM(n, e) {
    return n.distance - e.distance
}
function W1(n, e, t, i) {
    let r = !0;
    if (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1),
    r === !0 && i === !0) {
        const s = n.children;
        for (let o = 0, l = s.length; o < l; o++)
            W1(s[o], e, t, !0)
    }
}
class KU {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, i),
        this.phi = Math.acos(an(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class JU {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + i * i),
        this.theta = Math.atan2(e, i),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const vM = new he;
class QU {
    constructor(e=new he(1 / 0,1 / 0), t=new he(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = vM.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, vM).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const xM = new B
  , Wd = new B;
class eF {
    constructor(e=new B, t=new B) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        xM.subVectors(e, this.start),
        Wd.subVectors(this.end, this.start);
        const i = Wd.dot(Wd);
        let s = Wd.dot(xM) / i;
        return t && (s = an(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const _M = new B;
class tF extends It {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const i = new St
          , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, l = 1, u = 32; o < u; o++,
        l++) {
            const f = o / u * Math.PI * 2
              , d = l / u * Math.PI * 2;
            r.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1)
        }
        i.setAttribute("position", new Je(r,3));
        const s = new oi({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Fr(i,s),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        this.parent ? (this.parent.updateWorldMatrix(!0),
        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
        this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        _M.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(_M),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const Ps = new B
  , jd = new ct
  , Gg = new ct;
class nF extends Fr {
    constructor(e) {
        const t = OE(e)
          , i = new St
          , r = []
          , s = []
          , o = new Oe(0,0,1)
          , l = new Oe(0,1,0);
        for (let f = 0; f < t.length; f++) {
            const d = t[f];
            d.parent && d.parent.isBone && (r.push(0, 0, 0),
            r.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(l.r, l.g, l.b))
        }
        i.setAttribute("position", new Je(r,3)),
        i.setAttribute("color", new Je(s,3));
        const u = new oi({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(i, u),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , i = this.geometry
          , r = i.getAttribute("position");
        Gg.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const l = t[s];
            l.parent && l.parent.isBone && (jd.multiplyMatrices(Gg, l.matrixWorld),
            Ps.setFromMatrixPosition(jd),
            r.setXYZ(o, Ps.x, Ps.y, Ps.z),
            jd.multiplyMatrices(Gg, l.parent.matrixWorld),
            Ps.setFromMatrixPosition(jd),
            r.setXYZ(o + 1, Ps.x, Ps.y, Ps.z),
            o += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function OE(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++)
        e.push.apply(e, OE(n.children[t]));
    return e
}
class iF extends Sn {
    constructor(e, t, i) {
        const r = new Vu(t,4,2)
          , s = new qs({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(r, s),
        this.light = e,
        this.color = i,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const rF = new B
  , yM = new Oe
  , SM = new Oe;
class sF extends It {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "HemisphereLightHelper";
        const r = new zu(t);
        r.rotateY(Math.PI * .5),
        this.material = new qs({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute("position")
          , o = new Float32Array(s.count * 3);
        r.setAttribute("color", new Vt(o,3)),
        this.add(new Sn(r,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            yM.copy(this.light.color),
            SM.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? yM : SM;
                t.setXYZ(i, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(rF.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class oF extends Fr {
    constructor(e=10, t=10, i=4473924, r=8947848) {
        i = new Oe(i),
        r = new Oe(r);
        const s = t / 2
          , o = e / t
          , l = e / 2
          , u = []
          , f = [];
        for (let m = 0, g = 0, x = -l; m <= t; m++,
        x += o) {
            u.push(-l, 0, x, l, 0, x),
            u.push(x, 0, -l, x, 0, l);
            const S = m === s ? i : r;
            S.toArray(f, g),
            g += 3,
            S.toArray(f, g),
            g += 3,
            S.toArray(f, g),
            g += 3,
            S.toArray(f, g),
            g += 3
        }
        const d = new St;
        d.setAttribute("position", new Je(u,3)),
        d.setAttribute("color", new Je(f,3));
        const h = new oi({
            vertexColors: !0,
            toneMapped: !1
        });
        super(d, h),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class aF extends Fr {
    constructor(e=10, t=16, i=8, r=64, s=4473924, o=8947848) {
        s = new Oe(s),
        o = new Oe(o);
        const l = []
          , u = [];
        if (t > 1)
            for (let h = 0; h < t; h++) {
                const m = h / t * (Math.PI * 2)
                  , g = Math.sin(m) * e
                  , x = Math.cos(m) * e;
                l.push(0, 0, 0),
                l.push(g, 0, x);
                const S = h & 1 ? s : o;
                u.push(S.r, S.g, S.b),
                u.push(S.r, S.g, S.b)
            }
        for (let h = 0; h < i; h++) {
            const m = h & 1 ? s : o
              , g = e - e / i * h;
            for (let x = 0; x < r; x++) {
                let S = x / r * (Math.PI * 2)
                  , _ = Math.sin(S) * g
                  , v = Math.cos(S) * g;
                l.push(_, 0, v),
                u.push(m.r, m.g, m.b),
                S = (x + 1) / r * (Math.PI * 2),
                _ = Math.sin(S) * g,
                v = Math.cos(S) * g,
                l.push(_, 0, v),
                u.push(m.r, m.g, m.b)
            }
        }
        const f = new St;
        f.setAttribute("position", new Je(l,3)),
        f.setAttribute("color", new Je(u,3));
        const d = new oi({
            vertexColors: !0,
            toneMapped: !1
        });
        super(f, d),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const MM = new B
  , Xd = new B
  , wM = new B;
class lF extends It {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let r = new St;
        r.setAttribute("position", new Je([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const s = new oi({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Ws(r,s),
        this.add(this.lightPlane),
        r = new St,
        r.setAttribute("position", new Je([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Ws(r,s),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        MM.setFromMatrixPosition(this.light.matrixWorld),
        Xd.setFromMatrixPosition(this.light.target.matrixWorld),
        wM.subVectors(Xd, MM),
        this.lightPlane.lookAt(Xd),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Xd),
        this.targetLine.scale.z = wM.length()
    }
}
const $d = new B
  , rn = new Uu;
class cF extends Fr {
    constructor(e) {
        const t = new St
          , i = new oi({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , r = []
          , s = []
          , o = {};
        l("n1", "n2"),
        l("n2", "n4"),
        l("n4", "n3"),
        l("n3", "n1"),
        l("f1", "f2"),
        l("f2", "f4"),
        l("f4", "f3"),
        l("f3", "f1"),
        l("n1", "f1"),
        l("n2", "f2"),
        l("n3", "f3"),
        l("n4", "f4"),
        l("p", "n1"),
        l("p", "n2"),
        l("p", "n3"),
        l("p", "n4"),
        l("u1", "u2"),
        l("u2", "u3"),
        l("u3", "u1"),
        l("c", "t"),
        l("p", "c"),
        l("cn1", "cn2"),
        l("cn3", "cn4"),
        l("cf1", "cf2"),
        l("cf3", "cf4");
        function l(x, S) {
            u(x),
            u(S)
        }
        function u(x) {
            r.push(0, 0, 0),
            s.push(0, 0, 0),
            o[x] === void 0 && (o[x] = []),
            o[x].push(r.length / 3 - 1)
        }
        t.setAttribute("position", new Je(r,3)),
        t.setAttribute("color", new Je(s,3)),
        super(t, i),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
        const f = new Oe(16755200)
          , d = new Oe(16711680)
          , h = new Oe(43775)
          , m = new Oe(16777215)
          , g = new Oe(3355443);
        this.setColors(f, d, h, m, g)
    }
    setColors(e, t, i, r, s) {
        const l = this.geometry.getAttribute("color");
        l.setXYZ(0, e.r, e.g, e.b),
        l.setXYZ(1, e.r, e.g, e.b),
        l.setXYZ(2, e.r, e.g, e.b),
        l.setXYZ(3, e.r, e.g, e.b),
        l.setXYZ(4, e.r, e.g, e.b),
        l.setXYZ(5, e.r, e.g, e.b),
        l.setXYZ(6, e.r, e.g, e.b),
        l.setXYZ(7, e.r, e.g, e.b),
        l.setXYZ(8, e.r, e.g, e.b),
        l.setXYZ(9, e.r, e.g, e.b),
        l.setXYZ(10, e.r, e.g, e.b),
        l.setXYZ(11, e.r, e.g, e.b),
        l.setXYZ(12, e.r, e.g, e.b),
        l.setXYZ(13, e.r, e.g, e.b),
        l.setXYZ(14, e.r, e.g, e.b),
        l.setXYZ(15, e.r, e.g, e.b),
        l.setXYZ(16, e.r, e.g, e.b),
        l.setXYZ(17, e.r, e.g, e.b),
        l.setXYZ(18, e.r, e.g, e.b),
        l.setXYZ(19, e.r, e.g, e.b),
        l.setXYZ(20, e.r, e.g, e.b),
        l.setXYZ(21, e.r, e.g, e.b),
        l.setXYZ(22, e.r, e.g, e.b),
        l.setXYZ(23, e.r, e.g, e.b),
        l.setXYZ(24, t.r, t.g, t.b),
        l.setXYZ(25, t.r, t.g, t.b),
        l.setXYZ(26, t.r, t.g, t.b),
        l.setXYZ(27, t.r, t.g, t.b),
        l.setXYZ(28, t.r, t.g, t.b),
        l.setXYZ(29, t.r, t.g, t.b),
        l.setXYZ(30, t.r, t.g, t.b),
        l.setXYZ(31, t.r, t.g, t.b),
        l.setXYZ(32, i.r, i.g, i.b),
        l.setXYZ(33, i.r, i.g, i.b),
        l.setXYZ(34, i.r, i.g, i.b),
        l.setXYZ(35, i.r, i.g, i.b),
        l.setXYZ(36, i.r, i.g, i.b),
        l.setXYZ(37, i.r, i.g, i.b),
        l.setXYZ(38, r.r, r.g, r.b),
        l.setXYZ(39, r.r, r.g, r.b),
        l.setXYZ(40, s.r, s.g, s.b),
        l.setXYZ(41, s.r, s.g, s.b),
        l.setXYZ(42, s.r, s.g, s.b),
        l.setXYZ(43, s.r, s.g, s.b),
        l.setXYZ(44, s.r, s.g, s.b),
        l.setXYZ(45, s.r, s.g, s.b),
        l.setXYZ(46, s.r, s.g, s.b),
        l.setXYZ(47, s.r, s.g, s.b),
        l.setXYZ(48, s.r, s.g, s.b),
        l.setXYZ(49, s.r, s.g, s.b),
        l.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , i = 1
          , r = 1;
        rn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        dn("c", t, e, rn, 0, 0, -1),
        dn("t", t, e, rn, 0, 0, 1),
        dn("n1", t, e, rn, -i, -r, -1),
        dn("n2", t, e, rn, i, -r, -1),
        dn("n3", t, e, rn, -i, r, -1),
        dn("n4", t, e, rn, i, r, -1),
        dn("f1", t, e, rn, -i, -r, 1),
        dn("f2", t, e, rn, i, -r, 1),
        dn("f3", t, e, rn, -i, r, 1),
        dn("f4", t, e, rn, i, r, 1),
        dn("u1", t, e, rn, i * .7, r * 1.1, -1),
        dn("u2", t, e, rn, -i * .7, r * 1.1, -1),
        dn("u3", t, e, rn, 0, r * 2, -1),
        dn("cf1", t, e, rn, -i, 0, 1),
        dn("cf2", t, e, rn, i, 0, 1),
        dn("cf3", t, e, rn, 0, -r, 1),
        dn("cf4", t, e, rn, 0, r, 1),
        dn("cn1", t, e, rn, -i, 0, -1),
        dn("cn2", t, e, rn, i, 0, -1),
        dn("cn3", t, e, rn, 0, -r, -1),
        dn("cn4", t, e, rn, 0, r, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function dn(n, e, t, i, r, s, o) {
    $d.set(r, s, o).unproject(i);
    const l = e[n];
    if (l !== void 0) {
        const u = t.getAttribute("position");
        for (let f = 0, d = l.length; f < d; f++)
            u.setXYZ(l[f], $d.x, $d.y, $d.z)
    }
}
const qd = new si;
class uF extends Fr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Float32Array(8 * 3)
          , s = new St;
        s.setIndex(new Vt(i,1)),
        s.setAttribute("position", new Vt(r,3)),
        super(s, new oi({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && qd.setFromObject(this.object),
        qd.isEmpty())
            return;
        const t = qd.min
          , i = qd.max
          , r = this.geometry.attributes.position
          , s = r.array;
        s[0] = i.x,
        s[1] = i.y,
        s[2] = i.z,
        s[3] = t.x,
        s[4] = i.y,
        s[5] = i.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = i.z,
        s[9] = i.x,
        s[10] = t.y,
        s[11] = i.z,
        s[12] = i.x,
        s[13] = i.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = i.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = i.x,
        s[22] = t.y,
        s[23] = t.z,
        r.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class fF extends Fr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , s = new St;
        s.setIndex(new Vt(i,1)),
        s.setAttribute("position", new Je(r,3)),
        super(s, new oi({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class dF extends Ws {
    constructor(e, t=1, i=16776960) {
        const r = i
          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , o = new St;
        o.setAttribute("position", new Je(s,3)),
        o.computeBoundingSphere(),
        super(o, new oi({
            color: r,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , u = new St;
        u.setAttribute("position", new Je(l,3)),
        u.computeBoundingSphere(),
        this.add(new Sn(u,new qs({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const bM = new B;
let Yd, Wg;
class hF extends It {
    constructor(e=new B(0,0,1), t=new B(0,0,0), i=1, r=16776960, s=i * .2, o=s * .2) {
        super(),
        this.type = "ArrowHelper",
        Yd === void 0 && (Yd = new St,
        Yd.setAttribute("position", new Je([0, 0, 0, 0, 1, 0],3)),
        Wg = new Al(0,.5,1,5,1),
        Wg.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Ws(Yd,new oi({
            color: r,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Sn(Wg,new qs({
            color: r,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, s, o)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            bM.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(bM, t)
        }
    }
    setLength(e, t=e * .2, i=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class pF extends Fr {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , r = new St;
        r.setAttribute("position", new Je(t,3)),
        r.setAttribute("color", new Je(i,3));
        const s = new oi({
            vertexColors: !0,
            toneMapped: !1
        });
        super(r, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const r = new Oe
          , s = this.geometry.attributes.color.array;
        return r.set(e),
        r.toArray(s, 0),
        r.toArray(s, 3),
        r.set(t),
        r.toArray(s, 6),
        r.toArray(s, 9),
        r.set(i),
        r.toArray(s, 12),
        r.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class mF {
    constructor() {
        this.type = "ShapePath",
        this.color = new Oe,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new du,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(v) {
            const M = [];
            for (let w = 0, E = v.length; w < E; w++) {
                const O = v[w]
                  , R = new ko;
                R.curves = O.curves,
                M.push(R)
            }
            return M
        }
        function i(v, M) {
            const w = M.length;
            let E = !1;
            for (let O = w - 1, R = 0; R < w; O = R++) {
                let A = M[O]
                  , F = M[R]
                  , I = F.x - A.x
                  , P = F.y - A.y;
                if (Math.abs(P) > Number.EPSILON) {
                    if (P < 0 && (A = M[R],
                    I = -I,
                    F = M[O],
                    P = -P),
                    v.y < A.y || v.y > F.y)
                        continue;
                    if (v.y === A.y) {
                        if (v.x === A.x)
                            return !0
                    } else {
                        const D = P * (v.x - A.x) - I * (v.y - A.y);
                        if (D === 0)
                            return !0;
                        if (D < 0)
                            continue;
                        E = !E
                    }
                } else {
                    if (v.y !== A.y)
                        continue;
                    if (F.x <= v.x && v.x <= A.x || A.x <= v.x && v.x <= F.x)
                        return !0
                }
            }
            return E
        }
        const r = Lr.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, l, u;
        const f = [];
        if (s.length === 1)
            return l = s[0],
            u = new ko,
            u.curves = l.curves,
            f.push(u),
            f;
        let d = !r(s[0].getPoints());
        d = e ? !d : d;
        const h = []
          , m = [];
        let g = [], x = 0, S;
        m[x] = void 0,
        g[x] = [];
        for (let v = 0, M = s.length; v < M; v++)
            l = s[v],
            S = l.getPoints(),
            o = r(S),
            o = e ? !o : o,
            o ? (!d && m[x] && x++,
            m[x] = {
                s: new ko,
                p: S
            },
            m[x].s.curves = l.curves,
            d && x++,
            g[x] = []) : g[x].push({
                h: l,
                p: S[0]
            });
        if (!m[0])
            return t(s);
        if (m.length > 1) {
            let v = !1
              , M = 0;
            for (let w = 0, E = m.length; w < E; w++)
                h[w] = [];
            for (let w = 0, E = m.length; w < E; w++) {
                const O = g[w];
                for (let R = 0; R < O.length; R++) {
                    const A = O[R];
                    let F = !0;
                    for (let I = 0; I < m.length; I++)
                        i(A.p, m[I].p) && (w !== I && M++,
                        F ? (F = !1,
                        h[I].push(A)) : v = !0);
                    F && h[w].push(A)
                }
            }
            M > 0 && v === !1 && (g = h)
        }
        let _;
        for (let v = 0, M = m.length; v < M; v++) {
            u = m[v].s,
            f.push(u),
            _ = g[v];
            for (let w = 0, E = _.length; w < E; w++)
                u.holes.push(_[w].h)
        }
        return f
    }
}
class gF extends qi {
    constructor(e=1, t=1, i=1, r={}) {
        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),
        super(e, t, {
            ...r,
            count: i
        }),
        this.isWebGLMultipleRenderTargets = !0
    }
    get texture() {
        return this.textures
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: Gp
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Gp);
const DE = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: Jv,
    AddEquation: Ls,
    AddOperation: sb,
    AdditiveAnimationBlendMode: cx,
    AdditiveBlending: Jc,
    AgXToneMapping: ub,
    AlphaFormat: ix,
    AlwaysCompare: Eb,
    AlwaysDepth: Jw,
    AlwaysStencilFunc: O1,
    AmbientLight: bE,
    AnimationAction: LE,
    AnimationClip: xu,
    AnimationLoader: vU,
    AnimationMixer: XU,
    AnimationObjectGroup: WU,
    AnimationUtils: hU,
    ArcCurve: Yb,
    ArrayCamera: Bb,
    ArrowHelper: hF,
    AttachedBindMode: N1,
    Audio: PE,
    AudioAnalyser: OU,
    AudioContext: Fx,
    AudioListener: IU,
    AudioLoader: AU,
    AxesHelper: pF,
    BackSide: ri,
    BasicDepthPacking: gb,
    BasicShadowMap: Lw,
    BatchedMesh: Xb,
    Bone: wx,
    BooleanKeyframeTrack: Yo,
    Box2: QU,
    Box3: si,
    Box3Helper: fF,
    BoxGeometry: $o,
    BoxHelper: uF,
    BufferAttribute: Vt,
    BufferGeometry: St,
    BufferGeometryLoader: RE,
    ByteType: ex,
    Cache: ns,
    Camera: Uu,
    CameraHelper: cF,
    CanvasTexture: FD,
    CapsuleGeometry: cm,
    CatmullRomCurve3: Zb,
    CineonToneMapping: lb,
    CircleGeometry: um,
    ClampToEdgeWrapping: Xi,
    Clock: kx,
    Color: Oe,
    ColorKeyframeTrack: Ox,
    ColorManagement: kt,
    CompressedArrayTexture: DD,
    CompressedCubeTexture: UD,
    CompressedTexture: am,
    CompressedTextureLoader: xU,
    ConeGeometry: fm,
    ConstantAlphaFactor: Yw,
    ConstantColorFactor: $w,
    CubeCamera: vx,
    CubeReflectionMapping: os,
    CubeRefractionMapping: Gs,
    CubeTexture: Fu,
    CubeTextureLoader: _U,
    CubeUVReflectionMapping: bl,
    CubicBezierCurve: Cx,
    CubicBezierCurve3: Kb,
    CubicInterpolant: gE,
    CullFaceBack: P1,
    CullFaceFront: Iw,
    CullFaceFrontBack: g8,
    CullFaceNone: Pw,
    Curve: hr,
    CurvePath: Qb,
    CustomBlending: Nw,
    CustomToneMapping: cb,
    CylinderGeometry: Al,
    Cylindrical: JU,
    Data3DTexture: hx,
    DataArrayTexture: em,
    DataTexture: Ir,
    DataTextureLoader: yU,
    DataUtils: C7,
    DecrementStencilOp: A8,
    DecrementWrapStencilOp: P8,
    DefaultLoadingManager: _E,
    DepthFormat: Do,
    DepthStencilFormat: Vo,
    DepthTexture: tm,
    DetachedBindMode: db,
    DirectionalLight: wE,
    DirectionalLightHelper: lF,
    DiscreteInterpolant: vE,
    DisplayP3ColorSpace: Qp,
    DodecahedronGeometry: dm,
    DoubleSide: lr,
    DstAlphaFactor: Hw,
    DstColorFactor: Ww,
    DynamicCopyUsage: j8,
    DynamicDrawUsage: B8,
    DynamicReadUsage: H8,
    EdgesGeometry: eE,
    EllipseCurve: lm,
    EqualCompare: Sb,
    EqualDepth: eb,
    EqualStencilFunc: O8,
    EquirectangularReflectionMapping: eu,
    EquirectangularRefractionMapping: tu,
    Euler: Ri,
    EventDispatcher: fs,
    ExtrudeGeometry: pm,
    FileLoader: ls,
    Float16BufferAttribute: L7,
    Float32BufferAttribute: Je,
    FloatType: ii,
    Fog: rm,
    FogExp2: im,
    FramebufferTexture: OD,
    FrontSide: Dr,
    Frustum: ku,
    GLBufferAttribute: ZU,
    GLSL1: $8,
    GLSL3: D1,
    GreaterCompare: Mb,
    GreaterDepth: nb,
    GreaterEqualCompare: bb,
    GreaterEqualDepth: tb,
    GreaterEqualStencilFunc: k8,
    GreaterStencilFunc: U8,
    GridHelper: oF,
    Group: qa,
    HalfFloatType: Xo,
    HemisphereLight: yE,
    HemisphereLightHelper: sF,
    IcosahedronGeometry: mm,
    ImageBitmapLoader: TU,
    ImageLoader: _u,
    ImageUtils: Rb,
    IncrementStencilOp: T8,
    IncrementWrapStencilOp: R8,
    InstancedBufferAttribute: ml,
    InstancedBufferGeometry: AE,
    InstancedInterleavedBuffer: YU,
    InstancedMesh: jb,
    Int16BufferAttribute: P7,
    Int32BufferAttribute: I7,
    Int8BufferAttribute: T7,
    IntType: Xp,
    InterleavedBuffer: sm,
    InterleavedBufferAttribute: Ho,
    Interpolant: Hu,
    InterpolateDiscrete: ru,
    InterpolateLinear: np,
    InterpolateSmooth: dh,
    InvertStencilOp: I8,
    KeepStencilOp: wo,
    KeyframeTrack: pr,
    LOD: Gb,
    LatheGeometry: Bu,
    Layers: Fo,
    LessCompare: yb,
    LessDepth: Qw,
    LessEqualCompare: ux,
    LessEqualDepth: Qc,
    LessEqualStencilFunc: D8,
    LessStencilFunc: N8,
    Light: Zs,
    LightProbe: TE,
    Line: Ws,
    Line3: eF,
    LineBasicMaterial: oi,
    LineCurve: Tx,
    LineCurve3: Jb,
    LineDashedMaterial: hE,
    LineLoop: $b,
    LineSegments: Fr,
    LinearDisplayP3ColorSpace: Du,
    LinearFilter: ln,
    LinearInterpolant: Nx,
    LinearMipMapLinearFilter: y8,
    LinearMipMapNearestFilter: _8,
    LinearMipmapLinearFilter: Cr,
    LinearMipmapNearestFilter: Pc,
    LinearSRGBColorSpace: us,
    LinearToneMapping: ob,
    LinearTransfer: ou,
    Loader: vi,
    LoaderUtils: G1,
    LoadingManager: Dx,
    LoopOnce: hb,
    LoopPingPong: mb,
    LoopRepeat: pb,
    LuminanceAlphaFormat: ox,
    LuminanceFormat: sx,
    MOUSE: p8,
    Material: Fn,
    MaterialLoader: Mm,
    MathUtils: Cb,
    Matrix3: xt,
    Matrix4: ct,
    MaxEquation: Fw,
    Mesh: Sn,
    MeshBasicMaterial: qs,
    MeshDepthMaterial: yx,
    MeshDistanceMaterial: Sx,
    MeshLambertMaterial: fE,
    MeshMatcapMaterial: dE,
    MeshNormalMaterial: uE,
    MeshPhongMaterial: lE,
    MeshPhysicalMaterial: aE,
    MeshStandardMaterial: Ix,
    MeshToonMaterial: cE,
    MinEquation: Uw,
    MirroredRepeatWrapping: iu,
    MixOperation: rb,
    MultiplyBlending: L1,
    MultiplyOperation: Nu,
    NearestFilter: Ln,
    NearestMipMapLinearFilter: x8,
    NearestMipMapNearestFilter: v8,
    NearestMipmapLinearFilter: ja,
    NearestMipmapNearestFilter: Qv,
    NeutralToneMapping: fb,
    NeverCompare: _b,
    NeverDepth: Kw,
    NeverStencilFunc: L8,
    NoBlending: is,
    NoColorSpace: es,
    NoToneMapping: Pr,
    NormalAnimationBlendMode: Jp,
    NormalBlending: Oo,
    NotEqualCompare: wb,
    NotEqualDepth: ib,
    NotEqualStencilFunc: F8,
    NumberKeyframeTrack: gu,
    Object3D: It,
    ObjectLoader: EU,
    ObjectSpaceNormalMap: xb,
    OctahedronGeometry: zu,
    OneFactor: Bw,
    OneMinusConstantAlphaFactor: Zw,
    OneMinusConstantColorFactor: qw,
    OneMinusDstAlphaFactor: Gw,
    OneMinusDstColorFactor: jw,
    OneMinusSrcAlphaFactor: Rh,
    OneMinusSrcColorFactor: Vw,
    OrthographicCamera: qo,
    P3Primaries: lu,
    PCFShadowMap: Wp,
    PCFSoftShadowMap: Rc,
    PMREMGenerator: U1,
    Path: du,
    PerspectiveCamera: yn,
    Plane: Is,
    PlaneGeometry: Cl,
    PlaneHelper: dF,
    PointLight: ME,
    PointLightHelper: iF,
    Points: qb,
    PointsMaterial: bx,
    PolarGridHelper: aF,
    PolyhedronGeometry: Ys,
    PositionalAudio: NU,
    PropertyBinding: Pt,
    PropertyMixer: IE,
    QuadraticBezierCurve: Ax,
    QuadraticBezierCurve3: Rx,
    Quaternion: mi,
    QuaternionKeyframeTrack: Gu,
    QuaternionLinearInterpolant: xE,
    RED_GREEN_RGTC2_Format: ep,
    RED_RGTC1_Format: lx,
    REVISION: Gp,
    RGBADepthPacking: vb,
    RGBAFormat: qn,
    RGBAIntegerFormat: Kp,
    RGBA_ASTC_10x10_Format: qh,
    RGBA_ASTC_10x5_Format: jh,
    RGBA_ASTC_10x6_Format: Xh,
    RGBA_ASTC_10x8_Format: $h,
    RGBA_ASTC_12x10_Format: Yh,
    RGBA_ASTC_12x12_Format: Zh,
    RGBA_ASTC_4x4_Format: Fh,
    RGBA_ASTC_5x4_Format: kh,
    RGBA_ASTC_5x5_Format: Bh,
    RGBA_ASTC_6x5_Format: zh,
    RGBA_ASTC_6x6_Format: Vh,
    RGBA_ASTC_8x5_Format: Hh,
    RGBA_ASTC_8x6_Format: Gh,
    RGBA_ASTC_8x8_Format: Wh,
    RGBA_BPTC_Format: Dc,
    RGBA_ETC2_EAC_Format: Uh,
    RGBA_PVRTC_2BPPV1_Format: Nh,
    RGBA_PVRTC_4BPPV1_Format: Lh,
    RGBA_S3TC_DXT1_Format: Lc,
    RGBA_S3TC_DXT3_Format: Nc,
    RGBA_S3TC_DXT5_Format: Oc,
    RGBFormat: rx,
    RGBIntegerFormat: S8,
    RGB_BPTC_SIGNED_Format: Kh,
    RGB_BPTC_UNSIGNED_Format: Jh,
    RGB_ETC1_Format: Oh,
    RGB_ETC2_Format: Dh,
    RGB_PVRTC_2BPPV1_Format: Ih,
    RGB_PVRTC_4BPPV1_Format: Ph,
    RGB_S3TC_DXT1_Format: Ic,
    RGFormat: ax,
    RGIntegerFormat: Zp,
    RawShaderMaterial: oE,
    Ray: El,
    Raycaster: NE,
    Rec709Primaries: au,
    RectAreaLight: EE,
    RedFormat: Yp,
    RedIntegerFormat: Ou,
    ReinhardToneMapping: ab,
    RenderTarget: Pb,
    RepeatWrapping: nu,
    ReplaceStencilOp: C8,
    ReverseSubtractEquation: Dw,
    RingGeometry: gm,
    SIGNED_RED_GREEN_RGTC2_Format: tp,
    SIGNED_RED_RGTC1_Format: Qh,
    SRGBColorSpace: Hi,
    SRGBTransfer: $t,
    Scene: ip,
    ShaderChunk: yt,
    ShaderLib: ar,
    ShaderMaterial: Yi,
    ShadowMaterial: sE,
    Shape: ko,
    ShapeGeometry: vm,
    ShapePath: mF,
    ShapeUtils: Lr,
    ShortType: tx,
    Skeleton: om,
    SkeletonHelper: nF,
    SkinnedMesh: Wb,
    Source: Po,
    Sphere: Yn,
    SphereGeometry: Vu,
    Spherical: KU,
    SphericalHarmonics3: CE,
    SplineCurve: Px,
    SpotLight: SE,
    SpotLightHelper: tF,
    Sprite: Hb,
    SpriteMaterial: Mx,
    SrcAlphaFactor: Ah,
    SrcAlphaSaturateFactor: Xw,
    SrcColorFactor: zw,
    StaticCopyUsage: W8,
    StaticDrawUsage: cu,
    StaticReadUsage: V8,
    StereoCamera: RU,
    StreamCopyUsage: X8,
    StreamDrawUsage: z8,
    StreamReadUsage: G8,
    StringKeyframeTrack: Zo,
    SubtractEquation: Ow,
    SubtractiveBlending: I1,
    TOUCH: m8,
    TangentSpaceNormalMap: $s,
    TetrahedronGeometry: xm,
    Texture: en,
    TextureLoader: SU,
    TextureUtils: hD,
    TorusGeometry: _m,
    TorusKnotGeometry: ym,
    Triangle: Ci,
    TriangleFanDrawMode: b8,
    TriangleStripDrawMode: w8,
    TrianglesDrawMode: M8,
    TubeGeometry: Sm,
    UVMapping: jp,
    Uint16BufferAttribute: px,
    Uint32BufferAttribute: mx,
    Uint8BufferAttribute: A7,
    Uint8ClampedBufferAttribute: R7,
    Uniform: Vx,
    UniformsGroup: qU,
    UniformsLib: De,
    UniformsUtils: gx,
    UnsignedByteType: fr,
    UnsignedInt248Type: zo,
    UnsignedInt5999Type: nx,
    UnsignedIntType: as,
    UnsignedShort4444Type: $p,
    UnsignedShort5551Type: qp,
    UnsignedShortType: dl,
    VSMShadowMap: sr,
    Vector2: he,
    Vector3: B,
    Vector4: Bt,
    VectorKeyframeTrack: vu,
    VideoTexture: ND,
    WebGL3DRenderTarget: g7,
    WebGLArrayRenderTarget: m7,
    WebGLCoordinateSystem: Tr,
    WebGLCubeRenderTarget: xx,
    WebGLMultipleRenderTargets: gF,
    WebGLRenderTarget: qi,
    WebGLRenderer: zb,
    WebGLUtils: kb,
    WebGPUCoordinateSystem: uu,
    WireframeGeometry: rE,
    WrapAroundEnding: su,
    ZeroCurvatureEnding: Ao,
    ZeroFactor: kw,
    ZeroSlopeEnding: Ro,
    ZeroStencilOp: E8,
    createCanvasElement: Ab
}, Symbol.toStringTag, {
    value: "Module"
}));
var UE = {
    exports: {}
}
  , Ko = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Ko.ConcurrentRoot = 1;
Ko.ContinuousEventPriority = 4;
Ko.DefaultEventPriority = 16;
Ko.DiscreteEventPriority = 1;
Ko.IdleEventPriority = 536870912;
Ko.LegacyRoot = 0;
UE.exports = Ko;
var Za = UE.exports;
function vF(n) {
    let e;
    const t = new Set
      , i = (f, d) => {
        const h = typeof f == "function" ? f(e) : f;
        if (h !== e) {
            const m = e;
            e = d ? h : Object.assign({}, e, h),
            t.forEach(g => g(e, m))
        }
    }
      , r = () => e
      , s = (f, d=r, h=Object.is) => {
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let m = d(e);
        function g() {
            const x = d(e);
            if (!h(m, x)) {
                const S = m;
                f(m = x, S)
            }
        }
        return t.add(g),
        () => t.delete(g)
    }
      , u = {
        setState: i,
        getState: r,
        subscribe: (f, d, h) => d || h ? s(f, d, h) : (t.add(f),
        () => t.delete(f)),
        destroy: () => t.clear()
    };
    return e = n(i, r, u),
    u
}
const xF = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , EM = xF ? N.useEffect : N.useLayoutEffect;
function _F(n) {
    const e = typeof n == "function" ? vF(n) : n
      , t = (i=e.getState, r=Object.is) => {
        const [,s] = N.useReducer(_ => _ + 1, 0)
          , o = e.getState()
          , l = N.useRef(o)
          , u = N.useRef(i)
          , f = N.useRef(r)
          , d = N.useRef(!1)
          , h = N.useRef();
        h.current === void 0 && (h.current = i(o));
        let m, g = !1;
        (l.current !== o || u.current !== i || f.current !== r || d.current) && (m = i(o),
        g = !r(h.current, m)),
        EM( () => {
            g && (h.current = m),
            l.current = o,
            u.current = i,
            f.current = r,
            d.current = !1
        }
        );
        const x = N.useRef(o);
        EM( () => {
            const _ = () => {
                try {
                    const M = e.getState()
                      , w = u.current(M);
                    f.current(h.current, w) || (l.current = M,
                    h.current = w,
                    s())
                } catch {
                    d.current = !0,
                    s()
                }
            }
              , v = e.subscribe(_);
            return e.getState() !== x.current && _(),
            v
        }
        , []);
        const S = g ? m : h.current;
        return N.useDebugValue(S),
        S
    }
    ;
    return Object.assign(t, e),
    t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const i = [t, e];
        return {
            next() {
                const r = i.length <= 0;
                return {
                    value: i.shift(),
                    done: r
                }
            }
        }
    }
    ,
    t
}
var FE = {
    exports: {}
}
  , kE = {
    exports: {}
}
  , BE = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(z, ee) {
        var Q = z.length;
        z.push(ee);
        e: for (; 0 < Q; ) {
            var ce = Q - 1 >>> 1
              , be = z[ce];
            if (0 < r(be, ee))
                z[ce] = ee,
                z[Q] = be,
                Q = ce;
            else
                break e
        }
    }
    function t(z) {
        return z.length === 0 ? null : z[0]
    }
    function i(z) {
        if (z.length === 0)
            return null;
        var ee = z[0]
          , Q = z.pop();
        if (Q !== ee) {
            z[0] = Q;
            e: for (var ce = 0, be = z.length, Ue = be >>> 1; ce < Ue; ) {
                var se = 2 * (ce + 1) - 1
                  , ue = z[se]
                  , Te = se + 1
                  , Me = z[Te];
                if (0 > r(ue, Q))
                    Te < be && 0 > r(Me, ue) ? (z[ce] = Me,
                    z[Te] = Q,
                    ce = Te) : (z[ce] = ue,
                    z[se] = Q,
                    ce = se);
                else if (Te < be && 0 > r(Me, Q))
                    z[ce] = Me,
                    z[Te] = Q,
                    ce = Te;
                else
                    break e
            }
        }
        return ee
    }
    function r(z, ee) {
        var Q = z.sortIndex - ee.sortIndex;
        return Q !== 0 ? Q : z.id - ee.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , l = o.now();
        n.unstable_now = function() {
            return o.now() - l
        }
    }
    var u = []
      , f = []
      , d = 1
      , h = null
      , m = 3
      , g = !1
      , x = !1
      , S = !1
      , _ = typeof setTimeout == "function" ? setTimeout : null
      , v = typeof clearTimeout == "function" ? clearTimeout : null
      , M = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(z) {
        for (var ee = t(f); ee !== null; ) {
            if (ee.callback === null)
                i(f);
            else if (ee.startTime <= z)
                i(f),
                ee.sortIndex = ee.expirationTime,
                e(u, ee);
            else
                break;
            ee = t(f)
        }
    }
    function E(z) {
        if (S = !1,
        w(z),
        !x)
            if (t(u) !== null)
                x = !0,
                K(O);
            else {
                var ee = t(f);
                ee !== null && oe(E, ee.startTime - z)
            }
    }
    function O(z, ee) {
        x = !1,
        S && (S = !1,
        v(F),
        F = -1),
        g = !0;
        var Q = m;
        try {
            for (w(ee),
            h = t(u); h !== null && (!(h.expirationTime > ee) || z && !D()); ) {
                var ce = h.callback;
                if (typeof ce == "function") {
                    h.callback = null,
                    m = h.priorityLevel;
                    var be = ce(h.expirationTime <= ee);
                    ee = n.unstable_now(),
                    typeof be == "function" ? h.callback = be : h === t(u) && i(u),
                    w(ee)
                } else
                    i(u);
                h = t(u)
            }
            if (h !== null)
                var Ue = !0;
            else {
                var se = t(f);
                se !== null && oe(E, se.startTime - ee),
                Ue = !1
            }
            return Ue
        } finally {
            h = null,
            m = Q,
            g = !1
        }
    }
    var R = !1
      , A = null
      , F = -1
      , I = 5
      , P = -1;
    function D() {
        return !(n.unstable_now() - P < I)
    }
    function W() {
        if (A !== null) {
            var z = n.unstable_now();
            P = z;
            var ee = !0;
            try {
                ee = A(!0, z)
            } finally {
                ee ? X() : (R = !1,
                A = null)
            }
        } else
            R = !1
    }
    var X;
    if (typeof M == "function")
        X = function() {
            M(W)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var G = new MessageChannel
          , q = G.port2;
        G.port1.onmessage = W,
        X = function() {
            q.postMessage(null)
        }
    } else
        X = function() {
            _(W, 0)
        }
        ;
    function K(z) {
        A = z,
        R || (R = !0,
        X())
    }
    function oe(z, ee) {
        F = _(function() {
            z(n.unstable_now())
        }, ee)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(z) {
        z.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        x || g || (x = !0,
        K(O))
    }
    ,
    n.unstable_forceFrameRate = function(z) {
        0 > z || 125 < z ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < z ? Math.floor(1e3 / z) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return m
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(u)
    }
    ,
    n.unstable_next = function(z) {
        switch (m) {
        case 1:
        case 2:
        case 3:
            var ee = 3;
            break;
        default:
            ee = m
        }
        var Q = m;
        m = ee;
        try {
            return z()
        } finally {
            m = Q
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(z, ee) {
        switch (z) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            z = 3
        }
        var Q = m;
        m = z;
        try {
            return ee()
        } finally {
            m = Q
        }
    }
    ,
    n.unstable_scheduleCallback = function(z, ee, Q) {
        var ce = n.unstable_now();
        switch (typeof Q == "object" && Q !== null ? (Q = Q.delay,
        Q = typeof Q == "number" && 0 < Q ? ce + Q : ce) : Q = ce,
        z) {
        case 1:
            var be = -1;
            break;
        case 2:
            be = 250;
            break;
        case 5:
            be = 1073741823;
            break;
        case 4:
            be = 1e4;
            break;
        default:
            be = 5e3
        }
        return be = Q + be,
        z = {
            id: d++,
            callback: ee,
            priorityLevel: z,
            startTime: Q,
            expirationTime: be,
            sortIndex: -1
        },
        Q > ce ? (z.sortIndex = Q,
        e(f, z),
        t(u) === null && z === t(f) && (S ? (v(F),
        F = -1) : S = !0,
        oe(E, Q - ce))) : (z.sortIndex = be,
        e(u, z),
        x || g || (x = !0,
        K(O))),
        z
    }
    ,
    n.unstable_shouldYield = D,
    n.unstable_wrapCallback = function(z) {
        var ee = m;
        return function() {
            var Q = m;
            m = ee;
            try {
                return z.apply(this, arguments)
            } finally {
                m = Q
            }
        }
    }
}
)(BE);
kE.exports = BE;
var j1 = kE.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yF = function(e) {
    var t = {}
      , i = N
      , r = j1
      , s = Object.assign;
    function o(a) {
        for (var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, p = 1; p < arguments.length; p++)
            c += "&args[]=" + encodeURIComponent(arguments[p]);
        return "Minified React error #" + a + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var l = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , u = Symbol.for("react.element")
      , f = Symbol.for("react.portal")
      , d = Symbol.for("react.fragment")
      , h = Symbol.for("react.strict_mode")
      , m = Symbol.for("react.profiler")
      , g = Symbol.for("react.provider")
      , x = Symbol.for("react.context")
      , S = Symbol.for("react.forward_ref")
      , _ = Symbol.for("react.suspense")
      , v = Symbol.for("react.suspense_list")
      , M = Symbol.for("react.memo")
      , w = Symbol.for("react.lazy")
      , E = Symbol.for("react.offscreen")
      , O = Symbol.iterator;
    function R(a) {
        return a === null || typeof a != "object" ? null : (a = O && a[O] || a["@@iterator"],
        typeof a == "function" ? a : null)
    }
    function A(a) {
        if (a == null)
            return null;
        if (typeof a == "function")
            return a.displayName || a.name || null;
        if (typeof a == "string")
            return a;
        switch (a) {
        case d:
            return "Fragment";
        case f:
            return "Portal";
        case m:
            return "Profiler";
        case h:
            return "StrictMode";
        case _:
            return "Suspense";
        case v:
            return "SuspenseList"
        }
        if (typeof a == "object")
            switch (a.$$typeof) {
            case x:
                return (a.displayName || "Context") + ".Consumer";
            case g:
                return (a._context.displayName || "Context") + ".Provider";
            case S:
                var c = a.render;
                return a = a.displayName,
                a || (a = c.displayName || c.name || "",
                a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"),
                a;
            case M:
                return c = a.displayName || null,
                c !== null ? c : A(a.type) || "Memo";
            case w:
                c = a._payload,
                a = a._init;
                try {
                    return A(a(c))
                } catch {}
            }
        return null
    }
    function F(a) {
        var c = a.type;
        switch (a.tag) {
        case 24:
            return "Cache";
        case 9:
            return (c.displayName || "Context") + ".Consumer";
        case 10:
            return (c._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return a = c.render,
            a = a.displayName || a.name || "",
            c.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return c;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return A(c);
        case 8:
            return c === h ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof c == "function")
                return c.displayName || c.name || null;
            if (typeof c == "string")
                return c
        }
        return null
    }
    function I(a) {
        var c = a
          , p = a;
        if (a.alternate)
            for (; c.return; )
                c = c.return;
        else {
            a = c;
            do
                c = a,
                c.flags & 4098 && (p = c.return),
                a = c.return;
            while (a)
        }
        return c.tag === 3 ? p : null
    }
    function P(a) {
        if (I(a) !== a)
            throw Error(o(188))
    }
    function D(a) {
        var c = a.alternate;
        if (!c) {
            if (c = I(a),
            c === null)
                throw Error(o(188));
            return c !== a ? null : a
        }
        for (var p = a, y = c; ; ) {
            var b = p.return;
            if (b === null)
                break;
            var C = b.alternate;
            if (C === null) {
                if (y = b.return,
                y !== null) {
                    p = y;
                    continue
                }
                break
            }
            if (b.child === C.child) {
                for (C = b.child; C; ) {
                    if (C === p)
                        return P(b),
                        a;
                    if (C === y)
                        return P(b),
                        c;
                    C = C.sibling
                }
                throw Error(o(188))
            }
            if (p.return !== y.return)
                p = b,
                y = C;
            else {
                for (var V = !1, j = b.child; j; ) {
                    if (j === p) {
                        V = !0,
                        p = b,
                        y = C;
                        break
                    }
                    if (j === y) {
                        V = !0,
                        y = b,
                        p = C;
                        break
                    }
                    j = j.sibling
                }
                if (!V) {
                    for (j = C.child; j; ) {
                        if (j === p) {
                            V = !0,
                            p = C,
                            y = b;
                            break
                        }
                        if (j === y) {
                            V = !0,
                            y = C,
                            p = b;
                            break
                        }
                        j = j.sibling
                    }
                    if (!V)
                        throw Error(o(189))
                }
            }
            if (p.alternate !== y)
                throw Error(o(190))
        }
        if (p.tag !== 3)
            throw Error(o(188));
        return p.stateNode.current === p ? a : c
    }
    function W(a) {
        return a = D(a),
        a !== null ? X(a) : null
    }
    function X(a) {
        if (a.tag === 5 || a.tag === 6)
            return a;
        for (a = a.child; a !== null; ) {
            var c = X(a);
            if (c !== null)
                return c;
            a = a.sibling
        }
        return null
    }
    function G(a) {
        if (a.tag === 5 || a.tag === 6)
            return a;
        for (a = a.child; a !== null; ) {
            if (a.tag !== 4) {
                var c = G(a);
                if (c !== null)
                    return c
            }
            a = a.sibling
        }
        return null
    }
    var q = Array.isArray, K = e.getPublicInstance, oe = e.getRootHostContext, z = e.getChildHostContext, ee = e.prepareForCommit, Q = e.resetAfterCommit, ce = e.createInstance, be = e.appendInitialChild, Ue = e.finalizeInitialChildren, se = e.prepareUpdate, ue = e.shouldSetTextContent, Te = e.createTextInstance, Me = e.scheduleTimeout, Ye = e.cancelTimeout, Qe = e.noTimeout, ze = e.isPrimaryRenderer, ke = e.supportsMutation, k = e.supportsPersistence, pe = e.supportsHydration, ye = e.getInstanceFromNode, Pe = e.preparePortalMount, fe = e.getCurrentEventPriority, $e = e.detachDeletedInstance, Le = e.supportsMicrotasks, Be = e.scheduleMicrotask, H = e.supportsTestSelectors, L = e.findFiberRoot, te = e.getBoundingRect, _e = e.getTextContent, ge = e.isHiddenSubtree, ve = e.matchAccessibilityRole, Ke = e.setFocusIfFocusable, we = e.setupIntersectionObserver, He = e.appendChild, ft = e.appendChildToContainer, Ee = e.commitTextUpdate, We = e.commitMount, Ct = e.commitUpdate, dt = e.insertBefore, je = e.insertInContainerBefore, pt = e.removeChild, Mt = e.removeChildFromContainer, Gt = e.resetTextContent, $ = e.hideInstance, Ae = e.hideTextInstance, me = e.unhideInstance, xe = e.unhideTextInstance, Ne = e.clearContainer, ut = e.cloneInstance, Tt = e.createContainerChildSet, Kt = e.appendChildToContainerChildSet, Mn = e.finalizeContainerChildren, Rt = e.replaceContainerChildren, Li = e.cloneHiddenInstance, xi = e.cloneHiddenTextInstance, Ku = e.canHydrateInstance, kr = e.canHydrateTextInstance, Rl = e.canHydrateSuspenseInstance, Pl = e.isSuspenseInstancePending, Jo = e.isSuspenseInstanceFallback, Qo = e.registerSuspenseInstanceRetry, ds = e.getNextHydratableSibling, ea = e.getFirstHydratableChild, Ju = e.getFirstHydratableChildWithinContainer, Qu = e.getFirstHydratableChildWithinSuspenseInstance, Am = e.hydrateInstance, Rm = e.hydrateTextInstance, Pm = e.hydrateSuspenseInstance, U = e.getNextHydratableInstanceAfterSuspenseInstance, Y = e.commitHydratedContainer, ie = e.commitHydratedSuspenseInstance, re = e.clearSuspenseBoundary, J = e.clearSuspenseBoundaryFromContainer, Re = e.shouldDeleteUnhydratedTailInstances, Ge = e.didNotMatchHydratedContainerTextInstance, Ze = e.didNotMatchHydratedTextInstance, qe;
    function st(a) {
        if (qe === void 0)
            try {
                throw Error()
            } catch (p) {
                var c = p.stack.trim().match(/\n( *(at )?)/);
                qe = c && c[1] || ""
            }
        return `
` + qe + a
    }
    var lt = !1;
    function it(a, c) {
        if (!a || lt)
            return "";
        lt = !0;
        var p = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (c)
                if (c = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(c.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(c, [])
                    } catch (Ce) {
                        var y = Ce
                    }
                    Reflect.construct(a, [], c)
                } else {
                    try {
                        c.call()
                    } catch (Ce) {
                        y = Ce
                    }
                    a.call(c.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (Ce) {
                    y = Ce
                }
                a()
            }
        } catch (Ce) {
            if (Ce && y && typeof Ce.stack == "string") {
                for (var b = Ce.stack.split(`
`), C = y.stack.split(`
`), V = b.length - 1, j = C.length - 1; 1 <= V && 0 <= j && b[V] !== C[j]; )
                    j--;
                for (; 1 <= V && 0 <= j; V--,
                j--)
                    if (b[V] !== C[j]) {
                        if (V !== 1 || j !== 1)
                            do
                                if (V--,
                                j--,
                                0 > j || b[V] !== C[j]) {
                                    var le = `
` + b[V].replace(" at new ", " at ");
                                    return a.displayName && le.includes("<anonymous>") && (le = le.replace("<anonymous>", a.displayName)),
                                    le
                                }
                            while (1 <= V && 0 <= j);
                        break
                    }
            }
        } finally {
            lt = !1,
            Error.prepareStackTrace = p
        }
        return (a = a ? a.displayName || a.name : "") ? st(a) : ""
    }
    var Lt = Object.prototype.hasOwnProperty
      , Wt = []
      , zt = -1;
    function tn(a) {
        return {
            current: a
        }
    }
    function nt(a) {
        0 > zt || (a.current = Wt[zt],
        Wt[zt] = null,
        zt--)
    }
    function Ie(a, c) {
        zt++,
        Wt[zt] = a.current,
        a.current = c
    }
    var jt = {}
      , ht = tn(jt)
      , Xt = tn(!1)
      , ai = jt;
    function pn(a, c) {
        var p = a.type.contextTypes;
        if (!p)
            return jt;
        var y = a.stateNode;
        if (y && y.__reactInternalMemoizedUnmaskedChildContext === c)
            return y.__reactInternalMemoizedMaskedChildContext;
        var b = {}, C;
        for (C in p)
            b[C] = c[C];
        return y && (a = a.stateNode,
        a.__reactInternalMemoizedUnmaskedChildContext = c,
        a.__reactInternalMemoizedMaskedChildContext = b),
        b
    }
    function Tn(a) {
        return a = a.childContextTypes,
        a != null
    }
    function qt() {
        nt(Xt),
        nt(ht)
    }
    function Qi(a, c, p) {
        if (ht.current !== jt)
            throw Error(o(168));
        Ie(ht, c),
        Ie(Xt, p)
    }
    function ta(a, c, p) {
        var y = a.stateNode;
        if (c = c.childContextTypes,
        typeof y.getChildContext != "function")
            return p;
        y = y.getChildContext();
        for (var b in y)
            if (!(b in c))
                throw Error(o(108, F(a) || "Unknown", b));
        return s({}, p, y)
    }
    function Nn(a) {
        return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || jt,
        ai = ht.current,
        Ie(ht, a),
        Ie(Xt, Xt.current),
        !0
    }
    function na(a, c, p) {
        var y = a.stateNode;
        if (!y)
            throw Error(o(169));
        p ? (a = ta(a, c, ai),
        y.__reactInternalMemoizedMergedChildContext = a,
        nt(Xt),
        nt(ht),
        Ie(ht, a)) : nt(Xt),
        Ie(Xt, p)
    }
    var _i = Math.clz32 ? Math.clz32 : RC
      , ef = Math.log
      , AC = Math.LN2;
    function RC(a) {
        return a >>>= 0,
        a === 0 ? 32 : 31 - (ef(a) / AC | 0) | 0
    }
    var tf = 64
      , nf = 4194304;
    function Il(a) {
        switch (a & -a) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return a & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return a
        }
    }
    function rf(a, c) {
        var p = a.pendingLanes;
        if (p === 0)
            return 0;
        var y = 0
          , b = a.suspendedLanes
          , C = a.pingedLanes
          , V = p & 268435455;
        if (V !== 0) {
            var j = V & ~b;
            j !== 0 ? y = Il(j) : (C &= V,
            C !== 0 && (y = Il(C)))
        } else
            V = p & ~b,
            V !== 0 ? y = Il(V) : C !== 0 && (y = Il(C));
        if (y === 0)
            return 0;
        if (c !== 0 && c !== y && !(c & b) && (b = y & -y,
        C = c & -c,
        b >= C || b === 16 && (C & 4194240) !== 0))
            return c;
        if (y & 4 && (y |= p & 16),
        c = a.entangledLanes,
        c !== 0)
            for (a = a.entanglements,
            c &= y; 0 < c; )
                p = 31 - _i(c),
                b = 1 << p,
                y |= a[p],
                c &= ~b;
        return y
    }
    function PC(a, c) {
        switch (a) {
        case 1:
        case 2:
        case 4:
            return c + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return c + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function IC(a, c) {
        for (var p = a.suspendedLanes, y = a.pingedLanes, b = a.expirationTimes, C = a.pendingLanes; 0 < C; ) {
            var V = 31 - _i(C)
              , j = 1 << V
              , le = b[V];
            le === -1 ? (!(j & p) || j & y) && (b[V] = PC(j, c)) : le <= c && (a.expiredLanes |= j),
            C &= ~j
        }
    }
    function Im(a) {
        return a = a.pendingLanes & -1073741825,
        a !== 0 ? a : a & 1073741824 ? 1073741824 : 0
    }
    function Lm(a) {
        for (var c = [], p = 0; 31 > p; p++)
            c.push(a);
        return c
    }
    function Ll(a, c, p) {
        a.pendingLanes |= c,
        c !== 536870912 && (a.suspendedLanes = 0,
        a.pingedLanes = 0),
        a = a.eventTimes,
        c = 31 - _i(c),
        a[c] = p
    }
    function LC(a, c) {
        var p = a.pendingLanes & ~c;
        a.pendingLanes = c,
        a.suspendedLanes = 0,
        a.pingedLanes = 0,
        a.expiredLanes &= c,
        a.mutableReadLanes &= c,
        a.entangledLanes &= c,
        c = a.entanglements;
        var y = a.eventTimes;
        for (a = a.expirationTimes; 0 < p; ) {
            var b = 31 - _i(p)
              , C = 1 << b;
            c[b] = 0,
            y[b] = -1,
            a[b] = -1,
            p &= ~C
        }
    }
    function Nm(a, c) {
        var p = a.entangledLanes |= c;
        for (a = a.entanglements; p; ) {
            var y = 31 - _i(p)
              , b = 1 << y;
            b & c | a[y] & c && (a[y] |= c),
            p &= ~b
        }
    }
    var Nt = 0;
    function s_(a) {
        return a &= -a,
        1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var Om = r.unstable_scheduleCallback
      , o_ = r.unstable_cancelCallback
      , NC = r.unstable_shouldYield
      , OC = r.unstable_requestPaint
      , An = r.unstable_now
      , Dm = r.unstable_ImmediatePriority
      , DC = r.unstable_UserBlockingPriority
      , Um = r.unstable_NormalPriority
      , UC = r.unstable_IdlePriority
      , sf = null
      , mr = null;
    function FC(a) {
        if (mr && typeof mr.onCommitFiberRoot == "function")
            try {
                mr.onCommitFiberRoot(sf, a, void 0, (a.current.flags & 128) === 128)
            } catch {}
    }
    function kC(a, c) {
        return a === c && (a !== 0 || 1 / a === 1 / c) || a !== a && c !== c
    }
    var gr = typeof Object.is == "function" ? Object.is : kC
      , Br = null
      , of = !1
      , Fm = !1;
    function a_(a) {
        Br === null ? Br = [a] : Br.push(a)
    }
    function BC(a) {
        of = !0,
        a_(a)
    }
    function vr() {
        if (!Fm && Br !== null) {
            Fm = !0;
            var a = 0
              , c = Nt;
            try {
                var p = Br;
                for (Nt = 1; a < p.length; a++) {
                    var y = p[a];
                    do
                        y = y(!0);
                    while (y !== null)
                }
                Br = null,
                of = !1
            } catch (b) {
                throw Br !== null && (Br = Br.slice(a + 1)),
                Om(Dm, vr),
                b
            } finally {
                Nt = c,
                Fm = !1
            }
        }
        return null
    }
    var zC = l.ReactCurrentBatchConfig;
    function af(a, c) {
        if (gr(a, c))
            return !0;
        if (typeof a != "object" || a === null || typeof c != "object" || c === null)
            return !1;
        var p = Object.keys(a)
          , y = Object.keys(c);
        if (p.length !== y.length)
            return !1;
        for (y = 0; y < p.length; y++) {
            var b = p[y];
            if (!Lt.call(c, b) || !gr(a[b], c[b]))
                return !1
        }
        return !0
    }
    function VC(a) {
        switch (a.tag) {
        case 5:
            return st(a.type);
        case 16:
            return st("Lazy");
        case 13:
            return st("Suspense");
        case 19:
            return st("SuspenseList");
        case 0:
        case 2:
        case 15:
            return a = it(a.type, !1),
            a;
        case 11:
            return a = it(a.type.render, !1),
            a;
        case 1:
            return a = it(a.type, !0),
            a;
        default:
            return ""
        }
    }
    function er(a, c) {
        if (a && a.defaultProps) {
            c = s({}, c),
            a = a.defaultProps;
            for (var p in a)
                c[p] === void 0 && (c[p] = a[p]);
            return c
        }
        return c
    }
    var lf = tn(null)
      , cf = null
      , ia = null
      , km = null;
    function Bm() {
        km = ia = cf = null
    }
    function l_(a, c, p) {
        ze ? (Ie(lf, c._currentValue),
        c._currentValue = p) : (Ie(lf, c._currentValue2),
        c._currentValue2 = p)
    }
    function zm(a) {
        var c = lf.current;
        nt(lf),
        ze ? a._currentValue = c : a._currentValue2 = c
    }
    function Vm(a, c, p) {
        for (; a !== null; ) {
            var y = a.alternate;
            if ((a.childLanes & c) !== c ? (a.childLanes |= c,
            y !== null && (y.childLanes |= c)) : y !== null && (y.childLanes & c) !== c && (y.childLanes |= c),
            a === p)
                break;
            a = a.return
        }
    }
    function ra(a, c) {
        cf = a,
        km = ia = null,
        a = a.dependencies,
        a !== null && a.firstContext !== null && (a.lanes & c && (Mi = !0),
        a.firstContext = null)
    }
    function Ni(a) {
        var c = ze ? a._currentValue : a._currentValue2;
        if (km !== a)
            if (a = {
                context: a,
                memoizedValue: c,
                next: null
            },
            ia === null) {
                if (cf === null)
                    throw Error(o(308));
                ia = a,
                cf.dependencies = {
                    lanes: 0,
                    firstContext: a
                }
            } else
                ia = ia.next = a;
        return c
    }
    var xr = null
      , hs = !1;
    function Hm(a) {
        a.updateQueue = {
            baseState: a.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function c_(a, c) {
        a = a.updateQueue,
        c.updateQueue === a && (c.updateQueue = {
            baseState: a.baseState,
            firstBaseUpdate: a.firstBaseUpdate,
            lastBaseUpdate: a.lastBaseUpdate,
            shared: a.shared,
            effects: a.effects
        })
    }
    function zr(a, c) {
        return {
            eventTime: a,
            lane: c,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function ps(a, c) {
        var p = a.updateQueue;
        p !== null && (p = p.shared,
        mn !== null && a.mode & 1 && !(bt & 2) ? (a = p.interleaved,
        a === null ? (c.next = c,
        xr === null ? xr = [p] : xr.push(p)) : (c.next = a.next,
        a.next = c),
        p.interleaved = c) : (a = p.pending,
        a === null ? c.next = c : (c.next = a.next,
        a.next = c),
        p.pending = c))
    }
    function uf(a, c, p) {
        if (c = c.updateQueue,
        c !== null && (c = c.shared,
        (p & 4194240) !== 0)) {
            var y = c.lanes;
            y &= a.pendingLanes,
            p |= y,
            c.lanes = p,
            Nm(a, p)
        }
    }
    function u_(a, c) {
        var p = a.updateQueue
          , y = a.alternate;
        if (y !== null && (y = y.updateQueue,
        p === y)) {
            var b = null
              , C = null;
            if (p = p.firstBaseUpdate,
            p !== null) {
                do {
                    var V = {
                        eventTime: p.eventTime,
                        lane: p.lane,
                        tag: p.tag,
                        payload: p.payload,
                        callback: p.callback,
                        next: null
                    };
                    C === null ? b = C = V : C = C.next = V,
                    p = p.next
                } while (p !== null);
                C === null ? b = C = c : C = C.next = c
            } else
                b = C = c;
            p = {
                baseState: y.baseState,
                firstBaseUpdate: b,
                lastBaseUpdate: C,
                shared: y.shared,
                effects: y.effects
            },
            a.updateQueue = p;
            return
        }
        a = p.lastBaseUpdate,
        a === null ? p.firstBaseUpdate = c : a.next = c,
        p.lastBaseUpdate = c
    }
    function ff(a, c, p, y) {
        var b = a.updateQueue;
        hs = !1;
        var C = b.firstBaseUpdate
          , V = b.lastBaseUpdate
          , j = b.shared.pending;
        if (j !== null) {
            b.shared.pending = null;
            var le = j
              , Ce = le.next;
            le.next = null,
            V === null ? C = Ce : V.next = Ce,
            V = le;
            var Xe = a.alternate;
            Xe !== null && (Xe = Xe.updateQueue,
            j = Xe.lastBaseUpdate,
            j !== V && (j === null ? Xe.firstBaseUpdate = Ce : j.next = Ce,
            Xe.lastBaseUpdate = le))
        }
        if (C !== null) {
            var gt = b.baseState;
            V = 0,
            Xe = Ce = le = null,
            j = C;
            do {
                var at = j.lane
                  , Ht = j.eventTime;
                if ((y & at) === at) {
                    Xe !== null && (Xe = Xe.next = {
                        eventTime: Ht,
                        lane: 0,
                        tag: j.tag,
                        payload: j.payload,
                        callback: j.callback,
                        next: null
                    });
                    e: {
                        var tt = a
                          , Vn = j;
                        switch (at = c,
                        Ht = p,
                        Vn.tag) {
                        case 1:
                            if (tt = Vn.payload,
                            typeof tt == "function") {
                                gt = tt.call(Ht, gt, at);
                                break e
                            }
                            gt = tt;
                            break e;
                        case 3:
                            tt.flags = tt.flags & -65537 | 128;
                        case 0:
                            if (tt = Vn.payload,
                            at = typeof tt == "function" ? tt.call(Ht, gt, at) : tt,
                            at == null)
                                break e;
                            gt = s({}, gt, at);
                            break e;
                        case 2:
                            hs = !0
                        }
                    }
                    j.callback !== null && j.lane !== 0 && (a.flags |= 64,
                    at = b.effects,
                    at === null ? b.effects = [j] : at.push(j))
                } else
                    Ht = {
                        eventTime: Ht,
                        lane: at,
                        tag: j.tag,
                        payload: j.payload,
                        callback: j.callback,
                        next: null
                    },
                    Xe === null ? (Ce = Xe = Ht,
                    le = gt) : Xe = Xe.next = Ht,
                    V |= at;
                if (j = j.next,
                j === null) {
                    if (j = b.shared.pending,
                    j === null)
                        break;
                    at = j,
                    j = at.next,
                    at.next = null,
                    b.lastBaseUpdate = at,
                    b.shared.pending = null
                }
            } while (!0);
            if (Xe === null && (le = gt),
            b.baseState = le,
            b.firstBaseUpdate = Ce,
            b.lastBaseUpdate = Xe,
            c = b.shared.interleaved,
            c !== null) {
                b = c;
                do
                    V |= b.lane,
                    b = b.next;
                while (b !== c)
            } else
                C === null && (b.shared.lanes = 0);
            ha |= V,
            a.lanes = V,
            a.memoizedState = gt
        }
    }
    function f_(a, c, p) {
        if (a = c.effects,
        c.effects = null,
        a !== null)
            for (c = 0; c < a.length; c++) {
                var y = a[c]
                  , b = y.callback;
                if (b !== null) {
                    if (y.callback = null,
                    y = p,
                    typeof b != "function")
                        throw Error(o(191, b));
                    b.call(y)
                }
            }
    }
    var d_ = new i.Component().refs;
    function Gm(a, c, p, y) {
        c = a.memoizedState,
        p = p(y, c),
        p = p == null ? c : s({}, c, p),
        a.memoizedState = p,
        a.lanes === 0 && (a.updateQueue.baseState = p)
    }
    var df = {
        isMounted: function(a) {
            return (a = a._reactInternals) ? I(a) === a : !1
        },
        enqueueSetState: function(a, c, p) {
            a = a._reactInternals;
            var y = Kn()
              , b = vs(a)
              , C = zr(y, b);
            C.payload = c,
            p != null && (C.callback = p),
            ps(a, C),
            c = ki(a, b, y),
            c !== null && uf(c, a, b)
        },
        enqueueReplaceState: function(a, c, p) {
            a = a._reactInternals;
            var y = Kn()
              , b = vs(a)
              , C = zr(y, b);
            C.tag = 1,
            C.payload = c,
            p != null && (C.callback = p),
            ps(a, C),
            c = ki(a, b, y),
            c !== null && uf(c, a, b)
        },
        enqueueForceUpdate: function(a, c) {
            a = a._reactInternals;
            var p = Kn()
              , y = vs(a)
              , b = zr(p, y);
            b.tag = 2,
            c != null && (b.callback = c),
            ps(a, b),
            c = ki(a, y, p),
            c !== null && uf(c, a, y)
        }
    };
    function h_(a, c, p, y, b, C, V) {
        return a = a.stateNode,
        typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(y, C, V) : c.prototype && c.prototype.isPureReactComponent ? !af(p, y) || !af(b, C) : !0
    }
    function p_(a, c, p) {
        var y = !1
          , b = jt
          , C = c.contextType;
        return typeof C == "object" && C !== null ? C = Ni(C) : (b = Tn(c) ? ai : ht.current,
        y = c.contextTypes,
        C = (y = y != null) ? pn(a, b) : jt),
        c = new c(p,C),
        a.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null,
        c.updater = df,
        a.stateNode = c,
        c._reactInternals = a,
        y && (a = a.stateNode,
        a.__reactInternalMemoizedUnmaskedChildContext = b,
        a.__reactInternalMemoizedMaskedChildContext = C),
        c
    }
    function m_(a, c, p, y) {
        a = c.state,
        typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(p, y),
        typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(p, y),
        c.state !== a && df.enqueueReplaceState(c, c.state, null)
    }
    function Wm(a, c, p, y) {
        var b = a.stateNode;
        b.props = p,
        b.state = a.memoizedState,
        b.refs = d_,
        Hm(a);
        var C = c.contextType;
        typeof C == "object" && C !== null ? b.context = Ni(C) : (C = Tn(c) ? ai : ht.current,
        b.context = pn(a, C)),
        b.state = a.memoizedState,
        C = c.getDerivedStateFromProps,
        typeof C == "function" && (Gm(a, c, C, p),
        b.state = a.memoizedState),
        typeof c.getDerivedStateFromProps == "function" || typeof b.getSnapshotBeforeUpdate == "function" || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (c = b.state,
        typeof b.componentWillMount == "function" && b.componentWillMount(),
        typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(),
        c !== b.state && df.enqueueReplaceState(b, b.state, null),
        ff(a, p, b, y),
        b.state = a.memoizedState),
        typeof b.componentDidMount == "function" && (a.flags |= 4194308)
    }
    var sa = []
      , oa = 0
      , hf = null
      , pf = 0
      , Oi = []
      , Di = 0
      , Ks = null
      , Vr = 1
      , Hr = "";
    function Js(a, c) {
        sa[oa++] = pf,
        sa[oa++] = hf,
        hf = a,
        pf = c
    }
    function g_(a, c, p) {
        Oi[Di++] = Vr,
        Oi[Di++] = Hr,
        Oi[Di++] = Ks,
        Ks = a;
        var y = Vr;
        a = Hr;
        var b = 32 - _i(y) - 1;
        y &= ~(1 << b),
        p += 1;
        var C = 32 - _i(c) + b;
        if (30 < C) {
            var V = b - b % 5;
            C = (y & (1 << V) - 1).toString(32),
            y >>= V,
            b -= V,
            Vr = 1 << 32 - _i(c) + b | p << b | y,
            Hr = C + a
        } else
            Vr = 1 << C | p << b | y,
            Hr = a
    }
    function jm(a) {
        a.return !== null && (Js(a, 1),
        g_(a, 1, 0))
    }
    function Xm(a) {
        for (; a === hf; )
            hf = sa[--oa],
            sa[oa] = null,
            pf = sa[--oa],
            sa[oa] = null;
        for (; a === Ks; )
            Ks = Oi[--Di],
            Oi[Di] = null,
            Hr = Oi[--Di],
            Oi[Di] = null,
            Vr = Oi[--Di],
            Oi[Di] = null
    }
    var yi = null
      , Si = null
      , Zt = !1
      , Nl = !1
      , tr = null;
    function v_(a, c) {
        var p = Bi(5, null, null, 0);
        p.elementType = "DELETED",
        p.stateNode = c,
        p.return = a,
        c = a.deletions,
        c === null ? (a.deletions = [p],
        a.flags |= 16) : c.push(p)
    }
    function x_(a, c) {
        switch (a.tag) {
        case 5:
            return c = Ku(c, a.type, a.pendingProps),
            c !== null ? (a.stateNode = c,
            yi = a,
            Si = ea(c),
            !0) : !1;
        case 6:
            return c = kr(c, a.pendingProps),
            c !== null ? (a.stateNode = c,
            yi = a,
            Si = null,
            !0) : !1;
        case 13:
            if (c = Rl(c),
            c !== null) {
                var p = Ks !== null ? {
                    id: Vr,
                    overflow: Hr
                } : null;
                return a.memoizedState = {
                    dehydrated: c,
                    treeContext: p,
                    retryLane: 1073741824
                },
                p = Bi(18, null, null, 0),
                p.stateNode = c,
                p.return = a,
                a.child = p,
                yi = a,
                Si = null,
                !0
            }
            return !1;
        default:
            return !1
        }
    }
    function $m(a) {
        return (a.mode & 1) !== 0 && (a.flags & 128) === 0
    }
    function qm(a) {
        if (Zt) {
            var c = Si;
            if (c) {
                var p = c;
                if (!x_(a, c)) {
                    if ($m(a))
                        throw Error(o(418));
                    c = ds(p);
                    var y = yi;
                    c && x_(a, c) ? v_(y, p) : (a.flags = a.flags & -4097 | 2,
                    Zt = !1,
                    yi = a)
                }
            } else {
                if ($m(a))
                    throw Error(o(418));
                a.flags = a.flags & -4097 | 2,
                Zt = !1,
                yi = a
            }
        }
    }
    function __(a) {
        for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
            a = a.return;
        yi = a
    }
    function Ol(a) {
        if (!pe || a !== yi)
            return !1;
        if (!Zt)
            return __(a),
            Zt = !0,
            !1;
        if (a.tag !== 3 && (a.tag !== 5 || Re(a.type) && !ue(a.type, a.memoizedProps))) {
            var c = Si;
            if (c) {
                if ($m(a)) {
                    for (a = Si; a; )
                        a = ds(a);
                    throw Error(o(418))
                }
                for (; c; )
                    v_(a, c),
                    c = ds(c)
            }
        }
        if (__(a),
        a.tag === 13) {
            if (!pe)
                throw Error(o(316));
            if (a = a.memoizedState,
            a = a !== null ? a.dehydrated : null,
            !a)
                throw Error(o(317));
            Si = U(a)
        } else
            Si = yi ? ds(a.stateNode) : null;
        return !0
    }
    function aa() {
        pe && (Si = yi = null,
        Nl = Zt = !1)
    }
    function Ym(a) {
        tr === null ? tr = [a] : tr.push(a)
    }
    function Dl(a, c, p) {
        if (a = p.ref,
        a !== null && typeof a != "function" && typeof a != "object") {
            if (p._owner) {
                if (p = p._owner,
                p) {
                    if (p.tag !== 1)
                        throw Error(o(309));
                    var y = p.stateNode
                }
                if (!y)
                    throw Error(o(147, a));
                var b = y
                  , C = "" + a;
                return c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === C ? c.ref : (c = function(V) {
                    var j = b.refs;
                    j === d_ && (j = b.refs = {}),
                    V === null ? delete j[C] : j[C] = V
                }
                ,
                c._stringRef = C,
                c)
            }
            if (typeof a != "string")
                throw Error(o(284));
            if (!p._owner)
                throw Error(o(290, a))
        }
        return a
    }
    function mf(a, c) {
        throw a = Object.prototype.toString.call(c),
        Error(o(31, a === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : a))
    }
    function y_(a) {
        var c = a._init;
        return c(a._payload)
    }
    function S_(a) {
        function c(ne, Z) {
            if (a) {
                var ae = ne.deletions;
                ae === null ? (ne.deletions = [Z],
                ne.flags |= 16) : ae.push(Z)
            }
        }
        function p(ne, Z) {
            if (!a)
                return null;
            for (; Z !== null; )
                c(ne, Z),
                Z = Z.sibling;
            return null
        }
        function y(ne, Z) {
            for (ne = new Map; Z !== null; )
                Z.key !== null ? ne.set(Z.key, Z) : ne.set(Z.index, Z),
                Z = Z.sibling;
            return ne
        }
        function b(ne, Z) {
            return ne = _s(ne, Z),
            ne.index = 0,
            ne.sibling = null,
            ne
        }
        function C(ne, Z, ae) {
            return ne.index = ae,
            a ? (ae = ne.alternate,
            ae !== null ? (ae = ae.index,
            ae < Z ? (ne.flags |= 2,
            Z) : ae) : (ne.flags |= 2,
            Z)) : (ne.flags |= 1048576,
            Z)
        }
        function V(ne) {
            return a && ne.alternate === null && (ne.flags |= 2),
            ne
        }
        function j(ne, Z, ae, Ve) {
            return Z === null || Z.tag !== 6 ? (Z = L0(ae, ne.mode, Ve),
            Z.return = ne,
            Z) : (Z = b(Z, ae),
            Z.return = ne,
            Z)
        }
        function le(ne, Z, ae, Ve) {
            var et = ae.type;
            return et === d ? Xe(ne, Z, ae.props.children, Ve, ae.key) : Z !== null && (Z.elementType === et || typeof et == "object" && et !== null && et.$$typeof === w && y_(et) === Z.type) ? (Ve = b(Z, ae.props),
            Ve.ref = Dl(ne, Z, ae),
            Ve.return = ne,
            Ve) : (Ve = Xf(ae.type, ae.key, ae.props, null, ne.mode, Ve),
            Ve.ref = Dl(ne, Z, ae),
            Ve.return = ne,
            Ve)
        }
        function Ce(ne, Z, ae, Ve) {
            return Z === null || Z.tag !== 4 || Z.stateNode.containerInfo !== ae.containerInfo || Z.stateNode.implementation !== ae.implementation ? (Z = N0(ae, ne.mode, Ve),
            Z.return = ne,
            Z) : (Z = b(Z, ae.children || []),
            Z.return = ne,
            Z)
        }
        function Xe(ne, Z, ae, Ve, et) {
            return Z === null || Z.tag !== 7 ? (Z = so(ae, ne.mode, Ve, et),
            Z.return = ne,
            Z) : (Z = b(Z, ae),
            Z.return = ne,
            Z)
        }
        function gt(ne, Z, ae) {
            if (typeof Z == "string" && Z !== "" || typeof Z == "number")
                return Z = L0("" + Z, ne.mode, ae),
                Z.return = ne,
                Z;
            if (typeof Z == "object" && Z !== null) {
                switch (Z.$$typeof) {
                case u:
                    return ae = Xf(Z.type, Z.key, Z.props, null, ne.mode, ae),
                    ae.ref = Dl(ne, null, Z),
                    ae.return = ne,
                    ae;
                case f:
                    return Z = N0(Z, ne.mode, ae),
                    Z.return = ne,
                    Z;
                case w:
                    var Ve = Z._init;
                    return gt(ne, Ve(Z._payload), ae)
                }
                if (q(Z) || R(Z))
                    return Z = so(Z, ne.mode, ae, null),
                    Z.return = ne,
                    Z;
                mf(ne, Z)
            }
            return null
        }
        function at(ne, Z, ae, Ve) {
            var et = Z !== null ? Z.key : null;
            if (typeof ae == "string" && ae !== "" || typeof ae == "number")
                return et !== null ? null : j(ne, Z, "" + ae, Ve);
            if (typeof ae == "object" && ae !== null) {
                switch (ae.$$typeof) {
                case u:
                    return ae.key === et ? le(ne, Z, ae, Ve) : null;
                case f:
                    return ae.key === et ? Ce(ne, Z, ae, Ve) : null;
                case w:
                    return et = ae._init,
                    at(ne, Z, et(ae._payload), Ve)
                }
                if (q(ae) || R(ae))
                    return et !== null ? null : Xe(ne, Z, ae, Ve, null);
                mf(ne, ae)
            }
            return null
        }
        function Ht(ne, Z, ae, Ve, et) {
            if (typeof Ve == "string" && Ve !== "" || typeof Ve == "number")
                return ne = ne.get(ae) || null,
                j(Z, ne, "" + Ve, et);
            if (typeof Ve == "object" && Ve !== null) {
                switch (Ve.$$typeof) {
                case u:
                    return ne = ne.get(Ve.key === null ? ae : Ve.key) || null,
                    le(Z, ne, Ve, et);
                case f:
                    return ne = ne.get(Ve.key === null ? ae : Ve.key) || null,
                    Ce(Z, ne, Ve, et);
                case w:
                    var wt = Ve._init;
                    return Ht(ne, Z, ae, wt(Ve._payload), et)
                }
                if (q(Ve) || R(Ve))
                    return ne = ne.get(ae) || null,
                    Xe(Z, ne, Ve, et, null);
                mf(Z, Ve)
            }
            return null
        }
        function tt(ne, Z, ae, Ve) {
            for (var et = null, wt = null, vt = Z, Ot = Z = 0, Pn = null; vt !== null && Ot < ae.length; Ot++) {
                vt.index > Ot ? (Pn = vt,
                vt = null) : Pn = vt.sibling;
                var Dt = at(ne, vt, ae[Ot], Ve);
                if (Dt === null) {
                    vt === null && (vt = Pn);
                    break
                }
                a && vt && Dt.alternate === null && c(ne, vt),
                Z = C(Dt, Z, Ot),
                wt === null ? et = Dt : wt.sibling = Dt,
                wt = Dt,
                vt = Pn
            }
            if (Ot === ae.length)
                return p(ne, vt),
                Zt && Js(ne, Ot),
                et;
            if (vt === null) {
                for (; Ot < ae.length; Ot++)
                    vt = gt(ne, ae[Ot], Ve),
                    vt !== null && (Z = C(vt, Z, Ot),
                    wt === null ? et = vt : wt.sibling = vt,
                    wt = vt);
                return Zt && Js(ne, Ot),
                et
            }
            for (vt = y(ne, vt); Ot < ae.length; Ot++)
                Pn = Ht(vt, ne, Ot, ae[Ot], Ve),
                Pn !== null && (a && Pn.alternate !== null && vt.delete(Pn.key === null ? Ot : Pn.key),
                Z = C(Pn, Z, Ot),
                wt === null ? et = Pn : wt.sibling = Pn,
                wt = Pn);
            return a && vt.forEach(function(ys) {
                return c(ne, ys)
            }),
            Zt && Js(ne, Ot),
            et
        }
        function Vn(ne, Z, ae, Ve) {
            var et = R(ae);
            if (typeof et != "function")
                throw Error(o(150));
            if (ae = et.call(ae),
            ae == null)
                throw Error(o(151));
            for (var wt = et = null, vt = Z, Ot = Z = 0, Pn = null, Dt = ae.next(); vt !== null && !Dt.done; Ot++,
            Dt = ae.next()) {
                vt.index > Ot ? (Pn = vt,
                vt = null) : Pn = vt.sibling;
                var ys = at(ne, vt, Dt.value, Ve);
                if (ys === null) {
                    vt === null && (vt = Pn);
                    break
                }
                a && vt && ys.alternate === null && c(ne, vt),
                Z = C(ys, Z, Ot),
                wt === null ? et = ys : wt.sibling = ys,
                wt = ys,
                vt = Pn
            }
            if (Dt.done)
                return p(ne, vt),
                Zt && Js(ne, Ot),
                et;
            if (vt === null) {
                for (; !Dt.done; Ot++,
                Dt = ae.next())
                    Dt = gt(ne, Dt.value, Ve),
                    Dt !== null && (Z = C(Dt, Z, Ot),
                    wt === null ? et = Dt : wt.sibling = Dt,
                    wt = Dt);
                return Zt && Js(ne, Ot),
                et
            }
            for (vt = y(ne, vt); !Dt.done; Ot++,
            Dt = ae.next())
                Dt = Ht(vt, ne, Ot, Dt.value, Ve),
                Dt !== null && (a && Dt.alternate !== null && vt.delete(Dt.key === null ? Ot : Dt.key),
                Z = C(Dt, Z, Ot),
                wt === null ? et = Dt : wt.sibling = Dt,
                wt = Dt);
            return a && vt.forEach(function(v5) {
                return c(ne, v5)
            }),
            Zt && Js(ne, Ot),
            et
        }
        function zi(ne, Z, ae, Ve) {
            if (typeof ae == "object" && ae !== null && ae.type === d && ae.key === null && (ae = ae.props.children),
            typeof ae == "object" && ae !== null) {
                switch (ae.$$typeof) {
                case u:
                    e: {
                        for (var et = ae.key, wt = Z; wt !== null; ) {
                            if (wt.key === et) {
                                if (et = ae.type,
                                et === d) {
                                    if (wt.tag === 7) {
                                        p(ne, wt.sibling),
                                        Z = b(wt, ae.props.children),
                                        Z.return = ne,
                                        ne = Z;
                                        break e
                                    }
                                } else if (wt.elementType === et || typeof et == "object" && et !== null && et.$$typeof === w && y_(et) === wt.type) {
                                    p(ne, wt.sibling),
                                    Z = b(wt, ae.props),
                                    Z.ref = Dl(ne, wt, ae),
                                    Z.return = ne,
                                    ne = Z;
                                    break e
                                }
                                p(ne, wt);
                                break
                            } else
                                c(ne, wt);
                            wt = wt.sibling
                        }
                        ae.type === d ? (Z = so(ae.props.children, ne.mode, Ve, ae.key),
                        Z.return = ne,
                        ne = Z) : (Ve = Xf(ae.type, ae.key, ae.props, null, ne.mode, Ve),
                        Ve.ref = Dl(ne, Z, ae),
                        Ve.return = ne,
                        ne = Ve)
                    }
                    return V(ne);
                case f:
                    e: {
                        for (wt = ae.key; Z !== null; ) {
                            if (Z.key === wt)
                                if (Z.tag === 4 && Z.stateNode.containerInfo === ae.containerInfo && Z.stateNode.implementation === ae.implementation) {
                                    p(ne, Z.sibling),
                                    Z = b(Z, ae.children || []),
                                    Z.return = ne,
                                    ne = Z;
                                    break e
                                } else {
                                    p(ne, Z);
                                    break
                                }
                            else
                                c(ne, Z);
                            Z = Z.sibling
                        }
                        Z = N0(ae, ne.mode, Ve),
                        Z.return = ne,
                        ne = Z
                    }
                    return V(ne);
                case w:
                    return wt = ae._init,
                    zi(ne, Z, wt(ae._payload), Ve)
                }
                if (q(ae))
                    return tt(ne, Z, ae, Ve);
                if (R(ae))
                    return Vn(ne, Z, ae, Ve);
                mf(ne, ae)
            }
            return typeof ae == "string" && ae !== "" || typeof ae == "number" ? (ae = "" + ae,
            Z !== null && Z.tag === 6 ? (p(ne, Z.sibling),
            Z = b(Z, ae),
            Z.return = ne,
            ne = Z) : (p(ne, Z),
            Z = L0(ae, ne.mode, Ve),
            Z.return = ne,
            ne = Z),
            V(ne)) : p(ne, Z)
        }
        return zi
    }
    var la = S_(!0)
      , M_ = S_(!1)
      , Ul = {}
      , Ui = tn(Ul)
      , Fl = tn(Ul)
      , ca = tn(Ul);
    function _r(a) {
        if (a === Ul)
            throw Error(o(174));
        return a
    }
    function Zm(a, c) {
        Ie(ca, c),
        Ie(Fl, a),
        Ie(Ui, Ul),
        a = oe(c),
        nt(Ui),
        Ie(Ui, a)
    }
    function ua() {
        nt(Ui),
        nt(Fl),
        nt(ca)
    }
    function w_(a) {
        var c = _r(ca.current)
          , p = _r(Ui.current);
        c = z(p, a.type, c),
        p !== c && (Ie(Fl, a),
        Ie(Ui, c))
    }
    function Km(a) {
        Fl.current === a && (nt(Ui),
        nt(Fl))
    }
    var Jt = tn(0);
    function gf(a) {
        for (var c = a; c !== null; ) {
            if (c.tag === 13) {
                var p = c.memoizedState;
                if (p !== null && (p = p.dehydrated,
                p === null || Pl(p) || Jo(p)))
                    return c
            } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
                if (c.flags & 128)
                    return c
            } else if (c.child !== null) {
                c.child.return = c,
                c = c.child;
                continue
            }
            if (c === a)
                break;
            for (; c.sibling === null; ) {
                if (c.return === null || c.return === a)
                    return null;
                c = c.return
            }
            c.sibling.return = c.return,
            c = c.sibling
        }
        return null
    }
    var Jm = [];
    function Qm() {
        for (var a = 0; a < Jm.length; a++) {
            var c = Jm[a];
            ze ? c._workInProgressVersionPrimary = null : c._workInProgressVersionSecondary = null
        }
        Jm.length = 0
    }
    var vf = l.ReactCurrentDispatcher
      , Fi = l.ReactCurrentBatchConfig
      , fa = 0
      , nn = null
      , kn = null
      , Rn = null
      , xf = !1
      , kl = !1
      , Bl = 0
      , HC = 0;
    function Bn() {
        throw Error(o(321))
    }
    function e0(a, c) {
        if (c === null)
            return !1;
        for (var p = 0; p < c.length && p < a.length; p++)
            if (!gr(a[p], c[p]))
                return !1;
        return !0
    }
    function t0(a, c, p, y, b, C) {
        if (fa = C,
        nn = c,
        c.memoizedState = null,
        c.updateQueue = null,
        c.lanes = 0,
        vf.current = a === null || a.memoizedState === null ? XC : $C,
        a = p(y, b),
        kl) {
            C = 0;
            do {
                if (kl = !1,
                Bl = 0,
                25 <= C)
                    throw Error(o(301));
                C += 1,
                Rn = kn = null,
                c.updateQueue = null,
                vf.current = qC,
                a = p(y, b)
            } while (kl)
        }
        if (vf.current = wf,
        c = kn !== null && kn.next !== null,
        fa = 0,
        Rn = kn = nn = null,
        xf = !1,
        c)
            throw Error(o(300));
        return a
    }
    function n0() {
        var a = Bl !== 0;
        return Bl = 0,
        a
    }
    function Gr() {
        var a = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Rn === null ? nn.memoizedState = Rn = a : Rn = Rn.next = a,
        Rn
    }
    function yr() {
        if (kn === null) {
            var a = nn.alternate;
            a = a !== null ? a.memoizedState : null
        } else
            a = kn.next;
        var c = Rn === null ? nn.memoizedState : Rn.next;
        if (c !== null)
            Rn = c,
            kn = a;
        else {
            if (a === null)
                throw Error(o(310));
            kn = a,
            a = {
                memoizedState: kn.memoizedState,
                baseState: kn.baseState,
                baseQueue: kn.baseQueue,
                queue: kn.queue,
                next: null
            },
            Rn === null ? nn.memoizedState = Rn = a : Rn = Rn.next = a
        }
        return Rn
    }
    function Qs(a, c) {
        return typeof c == "function" ? c(a) : c
    }
    function _f(a) {
        var c = yr()
          , p = c.queue;
        if (p === null)
            throw Error(o(311));
        p.lastRenderedReducer = a;
        var y = kn
          , b = y.baseQueue
          , C = p.pending;
        if (C !== null) {
            if (b !== null) {
                var V = b.next;
                b.next = C.next,
                C.next = V
            }
            y.baseQueue = b = C,
            p.pending = null
        }
        if (b !== null) {
            C = b.next,
            y = y.baseState;
            var j = V = null
              , le = null
              , Ce = C;
            do {
                var Xe = Ce.lane;
                if ((fa & Xe) === Xe)
                    le !== null && (le = le.next = {
                        lane: 0,
                        action: Ce.action,
                        hasEagerState: Ce.hasEagerState,
                        eagerState: Ce.eagerState,
                        next: null
                    }),
                    y = Ce.hasEagerState ? Ce.eagerState : a(y, Ce.action);
                else {
                    var gt = {
                        lane: Xe,
                        action: Ce.action,
                        hasEagerState: Ce.hasEagerState,
                        eagerState: Ce.eagerState,
                        next: null
                    };
                    le === null ? (j = le = gt,
                    V = y) : le = le.next = gt,
                    nn.lanes |= Xe,
                    ha |= Xe
                }
                Ce = Ce.next
            } while (Ce !== null && Ce !== C);
            le === null ? V = y : le.next = j,
            gr(y, c.memoizedState) || (Mi = !0),
            c.memoizedState = y,
            c.baseState = V,
            c.baseQueue = le,
            p.lastRenderedState = y
        }
        if (a = p.interleaved,
        a !== null) {
            b = a;
            do
                C = b.lane,
                nn.lanes |= C,
                ha |= C,
                b = b.next;
            while (b !== a)
        } else
            b === null && (p.lanes = 0);
        return [c.memoizedState, p.dispatch]
    }
    function yf(a) {
        var c = yr()
          , p = c.queue;
        if (p === null)
            throw Error(o(311));
        p.lastRenderedReducer = a;
        var y = p.dispatch
          , b = p.pending
          , C = c.memoizedState;
        if (b !== null) {
            p.pending = null;
            var V = b = b.next;
            do
                C = a(C, V.action),
                V = V.next;
            while (V !== b);
            gr(C, c.memoizedState) || (Mi = !0),
            c.memoizedState = C,
            c.baseQueue === null && (c.baseState = C),
            p.lastRenderedState = C
        }
        return [C, y]
    }
    function b_() {}
    function E_(a, c) {
        var p = nn
          , y = yr()
          , b = c()
          , C = !gr(y.memoizedState, b);
        if (C && (y.memoizedState = b,
        Mi = !0),
        y = y.queue,
        Vl(A_.bind(null, p, y, a), [a]),
        y.getSnapshot !== c || C || Rn !== null && Rn.memoizedState.tag & 1) {
            if (p.flags |= 2048,
            zl(9, T_.bind(null, p, y, b, c), void 0, null),
            mn === null)
                throw Error(o(349));
            fa & 30 || C_(p, c, b)
        }
        return b
    }
    function C_(a, c, p) {
        a.flags |= 16384,
        a = {
            getSnapshot: c,
            value: p
        },
        c = nn.updateQueue,
        c === null ? (c = {
            lastEffect: null,
            stores: null
        },
        nn.updateQueue = c,
        c.stores = [a]) : (p = c.stores,
        p === null ? c.stores = [a] : p.push(a))
    }
    function T_(a, c, p, y) {
        c.value = p,
        c.getSnapshot = y,
        R_(c) && ki(a, 1, -1)
    }
    function A_(a, c, p) {
        return p(function() {
            R_(c) && ki(a, 1, -1)
        })
    }
    function R_(a) {
        var c = a.getSnapshot;
        a = a.value;
        try {
            var p = c();
            return !gr(a, p)
        } catch {
            return !0
        }
    }
    function i0(a) {
        var c = Gr();
        return typeof a == "function" && (a = a()),
        c.memoizedState = c.baseState = a,
        a = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Qs,
            lastRenderedState: a
        },
        c.queue = a,
        a = a.dispatch = jC.bind(null, nn, a),
        [c.memoizedState, a]
    }
    function zl(a, c, p, y) {
        return a = {
            tag: a,
            create: c,
            destroy: p,
            deps: y,
            next: null
        },
        c = nn.updateQueue,
        c === null ? (c = {
            lastEffect: null,
            stores: null
        },
        nn.updateQueue = c,
        c.lastEffect = a.next = a) : (p = c.lastEffect,
        p === null ? c.lastEffect = a.next = a : (y = p.next,
        p.next = a,
        a.next = y,
        c.lastEffect = a)),
        a
    }
    function P_() {
        return yr().memoizedState
    }
    function Sf(a, c, p, y) {
        var b = Gr();
        nn.flags |= a,
        b.memoizedState = zl(1 | c, p, void 0, y === void 0 ? null : y)
    }
    function Mf(a, c, p, y) {
        var b = yr();
        y = y === void 0 ? null : y;
        var C = void 0;
        if (kn !== null) {
            var V = kn.memoizedState;
            if (C = V.destroy,
            y !== null && e0(y, V.deps)) {
                b.memoizedState = zl(c, p, C, y);
                return
            }
        }
        nn.flags |= a,
        b.memoizedState = zl(1 | c, p, C, y)
    }
    function r0(a, c) {
        return Sf(8390656, 8, a, c)
    }
    function Vl(a, c) {
        return Mf(2048, 8, a, c)
    }
    function I_(a, c) {
        return Mf(4, 2, a, c)
    }
    function L_(a, c) {
        return Mf(4, 4, a, c)
    }
    function N_(a, c) {
        if (typeof c == "function")
            return a = a(),
            c(a),
            function() {
                c(null)
            }
            ;
        if (c != null)
            return a = a(),
            c.current = a,
            function() {
                c.current = null
            }
    }
    function O_(a, c, p) {
        return p = p != null ? p.concat([a]) : null,
        Mf(4, 4, N_.bind(null, c, a), p)
    }
    function s0() {}
    function D_(a, c) {
        var p = yr();
        c = c === void 0 ? null : c;
        var y = p.memoizedState;
        return y !== null && c !== null && e0(c, y[1]) ? y[0] : (p.memoizedState = [a, c],
        a)
    }
    function U_(a, c) {
        var p = yr();
        c = c === void 0 ? null : c;
        var y = p.memoizedState;
        return y !== null && c !== null && e0(c, y[1]) ? y[0] : (a = a(),
        p.memoizedState = [a, c],
        a)
    }
    function GC(a, c) {
        var p = Nt;
        Nt = p !== 0 && 4 > p ? p : 4,
        a(!0);
        var y = Fi.transition;
        Fi.transition = {};
        try {
            a(!1),
            c()
        } finally {
            Nt = p,
            Fi.transition = y
        }
    }
    function F_() {
        return yr().memoizedState
    }
    function WC(a, c, p) {
        var y = vs(a);
        p = {
            lane: y,
            action: p,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        k_(a) ? B_(c, p) : (z_(a, c, p),
        p = Kn(),
        a = ki(a, y, p),
        a !== null && V_(a, c, y))
    }
    function jC(a, c, p) {
        var y = vs(a)
          , b = {
            lane: y,
            action: p,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (k_(a))
            B_(c, b);
        else {
            z_(a, c, b);
            var C = a.alternate;
            if (a.lanes === 0 && (C === null || C.lanes === 0) && (C = c.lastRenderedReducer,
            C !== null))
                try {
                    var V = c.lastRenderedState
                      , j = C(V, p);
                    if (b.hasEagerState = !0,
                    b.eagerState = j,
                    gr(j, V))
                        return
                } catch {} finally {}
            p = Kn(),
            a = ki(a, y, p),
            a !== null && V_(a, c, y)
        }
    }
    function k_(a) {
        var c = a.alternate;
        return a === nn || c !== null && c === nn
    }
    function B_(a, c) {
        kl = xf = !0;
        var p = a.pending;
        p === null ? c.next = c : (c.next = p.next,
        p.next = c),
        a.pending = c
    }
    function z_(a, c, p) {
        mn !== null && a.mode & 1 && !(bt & 2) ? (a = c.interleaved,
        a === null ? (p.next = p,
        xr === null ? xr = [c] : xr.push(c)) : (p.next = a.next,
        a.next = p),
        c.interleaved = p) : (a = c.pending,
        a === null ? p.next = p : (p.next = a.next,
        a.next = p),
        c.pending = p)
    }
    function V_(a, c, p) {
        if (p & 4194240) {
            var y = c.lanes;
            y &= a.pendingLanes,
            p |= y,
            c.lanes = p,
            Nm(a, p)
        }
    }
    var wf = {
        readContext: Ni,
        useCallback: Bn,
        useContext: Bn,
        useEffect: Bn,
        useImperativeHandle: Bn,
        useInsertionEffect: Bn,
        useLayoutEffect: Bn,
        useMemo: Bn,
        useReducer: Bn,
        useRef: Bn,
        useState: Bn,
        useDebugValue: Bn,
        useDeferredValue: Bn,
        useTransition: Bn,
        useMutableSource: Bn,
        useSyncExternalStore: Bn,
        useId: Bn,
        unstable_isNewReconciler: !1
    }
      , XC = {
        readContext: Ni,
        useCallback: function(a, c) {
            return Gr().memoizedState = [a, c === void 0 ? null : c],
            a
        },
        useContext: Ni,
        useEffect: r0,
        useImperativeHandle: function(a, c, p) {
            return p = p != null ? p.concat([a]) : null,
            Sf(4194308, 4, N_.bind(null, c, a), p)
        },
        useLayoutEffect: function(a, c) {
            return Sf(4194308, 4, a, c)
        },
        useInsertionEffect: function(a, c) {
            return Sf(4, 2, a, c)
        },
        useMemo: function(a, c) {
            var p = Gr();
            return c = c === void 0 ? null : c,
            a = a(),
            p.memoizedState = [a, c],
            a
        },
        useReducer: function(a, c, p) {
            var y = Gr();
            return c = p !== void 0 ? p(c) : c,
            y.memoizedState = y.baseState = c,
            a = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: a,
                lastRenderedState: c
            },
            y.queue = a,
            a = a.dispatch = WC.bind(null, nn, a),
            [y.memoizedState, a]
        },
        useRef: function(a) {
            var c = Gr();
            return a = {
                current: a
            },
            c.memoizedState = a
        },
        useState: i0,
        useDebugValue: s0,
        useDeferredValue: function(a) {
            var c = i0(a)
              , p = c[0]
              , y = c[1];
            return r0(function() {
                var b = Fi.transition;
                Fi.transition = {};
                try {
                    y(a)
                } finally {
                    Fi.transition = b
                }
            }, [a]),
            p
        },
        useTransition: function() {
            var a = i0(!1)
              , c = a[0];
            return a = GC.bind(null, a[1]),
            Gr().memoizedState = a,
            [c, a]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(a, c, p) {
            var y = nn
              , b = Gr();
            if (Zt) {
                if (p === void 0)
                    throw Error(o(407));
                p = p()
            } else {
                if (p = c(),
                mn === null)
                    throw Error(o(349));
                fa & 30 || C_(y, c, p)
            }
            b.memoizedState = p;
            var C = {
                value: p,
                getSnapshot: c
            };
            return b.queue = C,
            r0(A_.bind(null, y, C, a), [a]),
            y.flags |= 2048,
            zl(9, T_.bind(null, y, C, p, c), void 0, null),
            p
        },
        useId: function() {
            var a = Gr()
              , c = mn.identifierPrefix;
            if (Zt) {
                var p = Hr
                  , y = Vr;
                p = (y & ~(1 << 32 - _i(y) - 1)).toString(32) + p,
                c = ":" + c + "R" + p,
                p = Bl++,
                0 < p && (c += "H" + p.toString(32)),
                c += ":"
            } else
                p = HC++,
                c = ":" + c + "r" + p.toString(32) + ":";
            return a.memoizedState = c
        },
        unstable_isNewReconciler: !1
    }
      , $C = {
        readContext: Ni,
        useCallback: D_,
        useContext: Ni,
        useEffect: Vl,
        useImperativeHandle: O_,
        useInsertionEffect: I_,
        useLayoutEffect: L_,
        useMemo: U_,
        useReducer: _f,
        useRef: P_,
        useState: function() {
            return _f(Qs)
        },
        useDebugValue: s0,
        useDeferredValue: function(a) {
            var c = _f(Qs)
              , p = c[0]
              , y = c[1];
            return Vl(function() {
                var b = Fi.transition;
                Fi.transition = {};
                try {
                    y(a)
                } finally {
                    Fi.transition = b
                }
            }, [a]),
            p
        },
        useTransition: function() {
            var a = _f(Qs)[0]
              , c = yr().memoizedState;
            return [a, c]
        },
        useMutableSource: b_,
        useSyncExternalStore: E_,
        useId: F_,
        unstable_isNewReconciler: !1
    }
      , qC = {
        readContext: Ni,
        useCallback: D_,
        useContext: Ni,
        useEffect: Vl,
        useImperativeHandle: O_,
        useInsertionEffect: I_,
        useLayoutEffect: L_,
        useMemo: U_,
        useReducer: yf,
        useRef: P_,
        useState: function() {
            return yf(Qs)
        },
        useDebugValue: s0,
        useDeferredValue: function(a) {
            var c = yf(Qs)
              , p = c[0]
              , y = c[1];
            return Vl(function() {
                var b = Fi.transition;
                Fi.transition = {};
                try {
                    y(a)
                } finally {
                    Fi.transition = b
                }
            }, [a]),
            p
        },
        useTransition: function() {
            var a = yf(Qs)[0]
              , c = yr().memoizedState;
            return [a, c]
        },
        useMutableSource: b_,
        useSyncExternalStore: E_,
        useId: F_,
        unstable_isNewReconciler: !1
    };
    function o0(a, c) {
        try {
            var p = ""
              , y = c;
            do
                p += VC(y),
                y = y.return;
            while (y);
            var b = p
        } catch (C) {
            b = `
Error generating stack: ` + C.message + `
` + C.stack
        }
        return {
            value: a,
            source: c,
            stack: b
        }
    }
    function a0(a, c) {
        try {
            console.error(c.value)
        } catch (p) {
            setTimeout(function() {
                throw p
            })
        }
    }
    var YC = typeof WeakMap == "function" ? WeakMap : Map;
    function H_(a, c, p) {
        p = zr(-1, p),
        p.tag = 3,
        p.payload = {
            element: null
        };
        var y = c.value;
        return p.callback = function() {
            Bf || (Bf = !0,
            E0 = y),
            a0(a, c)
        }
        ,
        p
    }
    function G_(a, c, p) {
        p = zr(-1, p),
        p.tag = 3;
        var y = a.type.getDerivedStateFromError;
        if (typeof y == "function") {
            var b = c.value;
            p.payload = function() {
                return y(b)
            }
            ,
            p.callback = function() {
                a0(a, c)
            }
        }
        var C = a.stateNode;
        return C !== null && typeof C.componentDidCatch == "function" && (p.callback = function() {
            a0(a, c),
            typeof y != "function" && (ms === null ? ms = new Set([this]) : ms.add(this));
            var V = c.stack;
            this.componentDidCatch(c.value, {
                componentStack: V !== null ? V : ""
            })
        }
        ),
        p
    }
    function W_(a, c, p) {
        var y = a.pingCache;
        if (y === null) {
            y = a.pingCache = new YC;
            var b = new Set;
            y.set(c, b)
        } else
            b = y.get(c),
            b === void 0 && (b = new Set,
            y.set(c, b));
        b.has(p) || (b.add(p),
        a = c5.bind(null, a, c, p),
        c.then(a, a))
    }
    function j_(a) {
        do {
            var c;
            if ((c = a.tag === 13) && (c = a.memoizedState,
            c = c !== null ? c.dehydrated !== null : !0),
            c)
                return a;
            a = a.return
        } while (a !== null);
        return null
    }
    function X_(a, c, p, y, b) {
        return a.mode & 1 ? (a.flags |= 65536,
        a.lanes = b,
        a) : (a === c ? a.flags |= 65536 : (a.flags |= 128,
        p.flags |= 131072,
        p.flags &= -52805,
        p.tag === 1 && (p.alternate === null ? p.tag = 17 : (c = zr(-1, 1),
        c.tag = 2,
        ps(p, c))),
        p.lanes |= 1),
        a)
    }
    function Sr(a) {
        a.flags |= 4
    }
    function $_(a, c) {
        if (a !== null && a.child === c.child)
            return !0;
        if (c.flags & 16)
            return !1;
        for (a = c.child; a !== null; ) {
            if (a.flags & 12854 || a.subtreeFlags & 12854)
                return !1;
            a = a.sibling
        }
        return !0
    }
    var Hl, Gl, bf, Ef;
    if (ke)
        Hl = function(a, c) {
            for (var p = c.child; p !== null; ) {
                if (p.tag === 5 || p.tag === 6)
                    be(a, p.stateNode);
                else if (p.tag !== 4 && p.child !== null) {
                    p.child.return = p,
                    p = p.child;
                    continue
                }
                if (p === c)
                    break;
                for (; p.sibling === null; ) {
                    if (p.return === null || p.return === c)
                        return;
                    p = p.return
                }
                p.sibling.return = p.return,
                p = p.sibling
            }
        }
        ,
        Gl = function() {}
        ,
        bf = function(a, c, p, y, b) {
            if (a = a.memoizedProps,
            a !== y) {
                var C = c.stateNode
                  , V = _r(Ui.current);
                p = se(C, p, a, y, b, V),
                (c.updateQueue = p) && Sr(c)
            }
        }
        ,
        Ef = function(a, c, p, y) {
            p !== y && Sr(c)
        }
        ;
    else if (k) {
        Hl = function(a, c, p, y) {
            for (var b = c.child; b !== null; ) {
                if (b.tag === 5) {
                    var C = b.stateNode;
                    p && y && (C = Li(C, b.type, b.memoizedProps, b)),
                    be(a, C)
                } else if (b.tag === 6)
                    C = b.stateNode,
                    p && y && (C = xi(C, b.memoizedProps, b)),
                    be(a, C);
                else if (b.tag !== 4) {
                    if (b.tag === 22 && b.memoizedState !== null)
                        C = b.child,
                        C !== null && (C.return = b),
                        Hl(a, b, !0, !0);
                    else if (b.child !== null) {
                        b.child.return = b,
                        b = b.child;
                        continue
                    }
                }
                if (b === c)
                    break;
                for (; b.sibling === null; ) {
                    if (b.return === null || b.return === c)
                        return;
                    b = b.return
                }
                b.sibling.return = b.return,
                b = b.sibling
            }
        }
        ;
        var q_ = function(a, c, p, y) {
            for (var b = c.child; b !== null; ) {
                if (b.tag === 5) {
                    var C = b.stateNode;
                    p && y && (C = Li(C, b.type, b.memoizedProps, b)),
                    Kt(a, C)
                } else if (b.tag === 6)
                    C = b.stateNode,
                    p && y && (C = xi(C, b.memoizedProps, b)),
                    Kt(a, C);
                else if (b.tag !== 4) {
                    if (b.tag === 22 && b.memoizedState !== null)
                        C = b.child,
                        C !== null && (C.return = b),
                        q_(a, b, !0, !0);
                    else if (b.child !== null) {
                        b.child.return = b,
                        b = b.child;
                        continue
                    }
                }
                if (b === c)
                    break;
                for (; b.sibling === null; ) {
                    if (b.return === null || b.return === c)
                        return;
                    b = b.return
                }
                b.sibling.return = b.return,
                b = b.sibling
            }
        };
        Gl = function(a, c) {
            var p = c.stateNode;
            if (!$_(a, c)) {
                a = p.containerInfo;
                var y = Tt(a);
                q_(y, c, !1, !1),
                p.pendingChildren = y,
                Sr(c),
                Mn(a, y)
            }
        }
        ,
        bf = function(a, c, p, y, b) {
            var C = a.stateNode
              , V = a.memoizedProps;
            if ((a = $_(a, c)) && V === y)
                c.stateNode = C;
            else {
                var j = c.stateNode
                  , le = _r(Ui.current)
                  , Ce = null;
                V !== y && (Ce = se(j, p, V, y, b, le)),
                a && Ce === null ? c.stateNode = C : (C = ut(C, Ce, p, V, y, c, a, j),
                Ue(C, p, y, b, le) && Sr(c),
                c.stateNode = C,
                a ? Sr(c) : Hl(C, c, !1, !1))
            }
        }
        ,
        Ef = function(a, c, p, y) {
            p !== y ? (a = _r(ca.current),
            p = _r(Ui.current),
            c.stateNode = Te(y, a, p, c),
            Sr(c)) : c.stateNode = a.stateNode
        }
    } else
        Gl = function() {}
        ,
        bf = function() {}
        ,
        Ef = function() {}
        ;
    function Wl(a, c) {
        if (!Zt)
            switch (a.tailMode) {
            case "hidden":
                c = a.tail;
                for (var p = null; c !== null; )
                    c.alternate !== null && (p = c),
                    c = c.sibling;
                p === null ? a.tail = null : p.sibling = null;
                break;
            case "collapsed":
                p = a.tail;
                for (var y = null; p !== null; )
                    p.alternate !== null && (y = p),
                    p = p.sibling;
                y === null ? c || a.tail === null ? a.tail = null : a.tail.sibling = null : y.sibling = null
            }
    }
    function zn(a) {
        var c = a.alternate !== null && a.alternate.child === a.child
          , p = 0
          , y = 0;
        if (c)
            for (var b = a.child; b !== null; )
                p |= b.lanes | b.childLanes,
                y |= b.subtreeFlags & 14680064,
                y |= b.flags & 14680064,
                b.return = a,
                b = b.sibling;
        else
            for (b = a.child; b !== null; )
                p |= b.lanes | b.childLanes,
                y |= b.subtreeFlags,
                y |= b.flags,
                b.return = a,
                b = b.sibling;
        return a.subtreeFlags |= y,
        a.childLanes = p,
        c
    }
    function ZC(a, c, p) {
        var y = c.pendingProps;
        switch (Xm(c),
        c.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return zn(c),
            null;
        case 1:
            return Tn(c.type) && qt(),
            zn(c),
            null;
        case 3:
            return y = c.stateNode,
            ua(),
            nt(Xt),
            nt(ht),
            Qm(),
            y.pendingContext && (y.context = y.pendingContext,
            y.pendingContext = null),
            (a === null || a.child === null) && (Ol(c) ? Sr(c) : a === null || a.memoizedState.isDehydrated && !(c.flags & 256) || (c.flags |= 1024,
            tr !== null && (A0(tr),
            tr = null))),
            Gl(a, c),
            zn(c),
            null;
        case 5:
            Km(c),
            p = _r(ca.current);
            var b = c.type;
            if (a !== null && c.stateNode != null)
                bf(a, c, b, y, p),
                a.ref !== c.ref && (c.flags |= 512,
                c.flags |= 2097152);
            else {
                if (!y) {
                    if (c.stateNode === null)
                        throw Error(o(166));
                    return zn(c),
                    null
                }
                if (a = _r(Ui.current),
                Ol(c)) {
                    if (!pe)
                        throw Error(o(175));
                    a = Am(c.stateNode, c.type, c.memoizedProps, p, a, c, !Nl),
                    c.updateQueue = a,
                    a !== null && Sr(c)
                } else {
                    var C = ce(b, y, p, a, c);
                    Hl(C, c, !1, !1),
                    c.stateNode = C,
                    Ue(C, b, y, p, a) && Sr(c)
                }
                c.ref !== null && (c.flags |= 512,
                c.flags |= 2097152)
            }
            return zn(c),
            null;
        case 6:
            if (a && c.stateNode != null)
                Ef(a, c, a.memoizedProps, y);
            else {
                if (typeof y != "string" && c.stateNode === null)
                    throw Error(o(166));
                if (a = _r(ca.current),
                p = _r(Ui.current),
                Ol(c)) {
                    if (!pe)
                        throw Error(o(176));
                    if (a = c.stateNode,
                    y = c.memoizedProps,
                    (p = Rm(a, y, c, !Nl)) && (b = yi,
                    b !== null))
                        switch (C = (b.mode & 1) !== 0,
                        b.tag) {
                        case 3:
                            Ge(b.stateNode.containerInfo, a, y, C);
                            break;
                        case 5:
                            Ze(b.type, b.memoizedProps, b.stateNode, a, y, C)
                        }
                    p && Sr(c)
                } else
                    c.stateNode = Te(y, a, p, c)
            }
            return zn(c),
            null;
        case 13:
            if (nt(Jt),
            y = c.memoizedState,
            Zt && Si !== null && c.mode & 1 && !(c.flags & 128)) {
                for (a = Si; a; )
                    a = ds(a);
                return aa(),
                c.flags |= 98560,
                c
            }
            if (y !== null && y.dehydrated !== null) {
                if (y = Ol(c),
                a === null) {
                    if (!y)
                        throw Error(o(318));
                    if (!pe)
                        throw Error(o(344));
                    if (a = c.memoizedState,
                    a = a !== null ? a.dehydrated : null,
                    !a)
                        throw Error(o(317));
                    Pm(a, c)
                } else
                    aa(),
                    !(c.flags & 128) && (c.memoizedState = null),
                    c.flags |= 4;
                return zn(c),
                null
            }
            return tr !== null && (A0(tr),
            tr = null),
            c.flags & 128 ? (c.lanes = p,
            c) : (y = y !== null,
            p = !1,
            a === null ? Ol(c) : p = a.memoizedState !== null,
            y && !p && (c.child.flags |= 8192,
            c.mode & 1 && (a === null || Jt.current & 1 ? wn === 0 && (wn = 3) : P0())),
            c.updateQueue !== null && (c.flags |= 4),
            zn(c),
            null);
        case 4:
            return ua(),
            Gl(a, c),
            a === null && Pe(c.stateNode.containerInfo),
            zn(c),
            null;
        case 10:
            return zm(c.type._context),
            zn(c),
            null;
        case 17:
            return Tn(c.type) && qt(),
            zn(c),
            null;
        case 19:
            if (nt(Jt),
            b = c.memoizedState,
            b === null)
                return zn(c),
                null;
            if (y = (c.flags & 128) !== 0,
            C = b.rendering,
            C === null)
                if (y)
                    Wl(b, !1);
                else {
                    if (wn !== 0 || a !== null && a.flags & 128)
                        for (a = c.child; a !== null; ) {
                            if (C = gf(a),
                            C !== null) {
                                for (c.flags |= 128,
                                Wl(b, !1),
                                a = C.updateQueue,
                                a !== null && (c.updateQueue = a,
                                c.flags |= 4),
                                c.subtreeFlags = 0,
                                a = p,
                                y = c.child; y !== null; )
                                    p = y,
                                    b = a,
                                    p.flags &= 14680066,
                                    C = p.alternate,
                                    C === null ? (p.childLanes = 0,
                                    p.lanes = b,
                                    p.child = null,
                                    p.subtreeFlags = 0,
                                    p.memoizedProps = null,
                                    p.memoizedState = null,
                                    p.updateQueue = null,
                                    p.dependencies = null,
                                    p.stateNode = null) : (p.childLanes = C.childLanes,
                                    p.lanes = C.lanes,
                                    p.child = C.child,
                                    p.subtreeFlags = 0,
                                    p.deletions = null,
                                    p.memoizedProps = C.memoizedProps,
                                    p.memoizedState = C.memoizedState,
                                    p.updateQueue = C.updateQueue,
                                    p.type = C.type,
                                    b = C.dependencies,
                                    p.dependencies = b === null ? null : {
                                        lanes: b.lanes,
                                        firstContext: b.firstContext
                                    }),
                                    y = y.sibling;
                                return Ie(Jt, Jt.current & 1 | 2),
                                c.child
                            }
                            a = a.sibling
                        }
                    b.tail !== null && An() > b0 && (c.flags |= 128,
                    y = !0,
                    Wl(b, !1),
                    c.lanes = 4194304)
                }
            else {
                if (!y)
                    if (a = gf(C),
                    a !== null) {
                        if (c.flags |= 128,
                        y = !0,
                        a = a.updateQueue,
                        a !== null && (c.updateQueue = a,
                        c.flags |= 4),
                        Wl(b, !0),
                        b.tail === null && b.tailMode === "hidden" && !C.alternate && !Zt)
                            return zn(c),
                            null
                    } else
                        2 * An() - b.renderingStartTime > b0 && p !== 1073741824 && (c.flags |= 128,
                        y = !0,
                        Wl(b, !1),
                        c.lanes = 4194304);
                b.isBackwards ? (C.sibling = c.child,
                c.child = C) : (a = b.last,
                a !== null ? a.sibling = C : c.child = C,
                b.last = C)
            }
            return b.tail !== null ? (c = b.tail,
            b.rendering = c,
            b.tail = c.sibling,
            b.renderingStartTime = An(),
            c.sibling = null,
            a = Jt.current,
            Ie(Jt, y ? a & 1 | 2 : a & 1),
            c) : (zn(c),
            null);
        case 22:
        case 23:
            return R0(),
            y = c.memoizedState !== null,
            a !== null && a.memoizedState !== null !== y && (c.flags |= 8192),
            y && c.mode & 1 ? wi & 1073741824 && (zn(c),
            ke && c.subtreeFlags & 6 && (c.flags |= 8192)) : zn(c),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(o(156, c.tag))
    }
    var KC = l.ReactCurrentOwner
      , Mi = !1;
    function Zn(a, c, p, y) {
        c.child = a === null ? M_(c, null, p, y) : la(c, a.child, p, y)
    }
    function Y_(a, c, p, y, b) {
        p = p.render;
        var C = c.ref;
        return ra(c, b),
        y = t0(a, c, p, y, C, b),
        p = n0(),
        a !== null && !Mi ? (c.updateQueue = a.updateQueue,
        c.flags &= -2053,
        a.lanes &= ~b,
        Wr(a, c, b)) : (Zt && p && jm(c),
        c.flags |= 1,
        Zn(a, c, y, b),
        c.child)
    }
    function Z_(a, c, p, y, b) {
        if (a === null) {
            var C = p.type;
            return typeof C == "function" && !I0(C) && C.defaultProps === void 0 && p.compare === null && p.defaultProps === void 0 ? (c.tag = 15,
            c.type = C,
            K_(a, c, C, y, b)) : (a = Xf(p.type, null, y, c, c.mode, b),
            a.ref = c.ref,
            a.return = c,
            c.child = a)
        }
        if (C = a.child,
        !(a.lanes & b)) {
            var V = C.memoizedProps;
            if (p = p.compare,
            p = p !== null ? p : af,
            p(V, y) && a.ref === c.ref)
                return Wr(a, c, b)
        }
        return c.flags |= 1,
        a = _s(C, y),
        a.ref = c.ref,
        a.return = c,
        c.child = a
    }
    function K_(a, c, p, y, b) {
        if (a !== null && af(a.memoizedProps, y) && a.ref === c.ref)
            if (Mi = !1,
            (a.lanes & b) !== 0)
                a.flags & 131072 && (Mi = !0);
            else
                return c.lanes = a.lanes,
                Wr(a, c, b);
        return l0(a, c, p, y, b)
    }
    function J_(a, c, p) {
        var y = c.pendingProps
          , b = y.children
          , C = a !== null ? a.memoizedState : null;
        if (y.mode === "hidden")
            if (!(c.mode & 1))
                c.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                Ie(da, wi),
                wi |= p;
            else if (p & 1073741824)
                c.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                y = C !== null ? C.baseLanes : p,
                Ie(da, wi),
                wi |= y;
            else
                return a = C !== null ? C.baseLanes | p : p,
                c.lanes = c.childLanes = 1073741824,
                c.memoizedState = {
                    baseLanes: a,
                    cachePool: null
                },
                c.updateQueue = null,
                Ie(da, wi),
                wi |= a,
                null;
        else
            C !== null ? (y = C.baseLanes | p,
            c.memoizedState = null) : y = p,
            Ie(da, wi),
            wi |= y;
        return Zn(a, c, b, p),
        c.child
    }
    function Q_(a, c) {
        var p = c.ref;
        (a === null && p !== null || a !== null && a.ref !== p) && (c.flags |= 512,
        c.flags |= 2097152)
    }
    function l0(a, c, p, y, b) {
        var C = Tn(p) ? ai : ht.current;
        return C = pn(c, C),
        ra(c, b),
        p = t0(a, c, p, y, C, b),
        y = n0(),
        a !== null && !Mi ? (c.updateQueue = a.updateQueue,
        c.flags &= -2053,
        a.lanes &= ~b,
        Wr(a, c, b)) : (Zt && y && jm(c),
        c.flags |= 1,
        Zn(a, c, p, b),
        c.child)
    }
    function ey(a, c, p, y, b) {
        if (Tn(p)) {
            var C = !0;
            Nn(c)
        } else
            C = !1;
        if (ra(c, b),
        c.stateNode === null)
            a !== null && (a.alternate = null,
            c.alternate = null,
            c.flags |= 2),
            p_(c, p, y),
            Wm(c, p, y, b),
            y = !0;
        else if (a === null) {
            var V = c.stateNode
              , j = c.memoizedProps;
            V.props = j;
            var le = V.context
              , Ce = p.contextType;
            typeof Ce == "object" && Ce !== null ? Ce = Ni(Ce) : (Ce = Tn(p) ? ai : ht.current,
            Ce = pn(c, Ce));
            var Xe = p.getDerivedStateFromProps
              , gt = typeof Xe == "function" || typeof V.getSnapshotBeforeUpdate == "function";
            gt || typeof V.UNSAFE_componentWillReceiveProps != "function" && typeof V.componentWillReceiveProps != "function" || (j !== y || le !== Ce) && m_(c, V, y, Ce),
            hs = !1;
            var at = c.memoizedState;
            V.state = at,
            ff(c, y, V, b),
            le = c.memoizedState,
            j !== y || at !== le || Xt.current || hs ? (typeof Xe == "function" && (Gm(c, p, Xe, y),
            le = c.memoizedState),
            (j = hs || h_(c, p, j, y, at, le, Ce)) ? (gt || typeof V.UNSAFE_componentWillMount != "function" && typeof V.componentWillMount != "function" || (typeof V.componentWillMount == "function" && V.componentWillMount(),
            typeof V.UNSAFE_componentWillMount == "function" && V.UNSAFE_componentWillMount()),
            typeof V.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof V.componentDidMount == "function" && (c.flags |= 4194308),
            c.memoizedProps = y,
            c.memoizedState = le),
            V.props = y,
            V.state = le,
            V.context = Ce,
            y = j) : (typeof V.componentDidMount == "function" && (c.flags |= 4194308),
            y = !1)
        } else {
            V = c.stateNode,
            c_(a, c),
            j = c.memoizedProps,
            Ce = c.type === c.elementType ? j : er(c.type, j),
            V.props = Ce,
            gt = c.pendingProps,
            at = V.context,
            le = p.contextType,
            typeof le == "object" && le !== null ? le = Ni(le) : (le = Tn(p) ? ai : ht.current,
            le = pn(c, le));
            var Ht = p.getDerivedStateFromProps;
            (Xe = typeof Ht == "function" || typeof V.getSnapshotBeforeUpdate == "function") || typeof V.UNSAFE_componentWillReceiveProps != "function" && typeof V.componentWillReceiveProps != "function" || (j !== gt || at !== le) && m_(c, V, y, le),
            hs = !1,
            at = c.memoizedState,
            V.state = at,
            ff(c, y, V, b);
            var tt = c.memoizedState;
            j !== gt || at !== tt || Xt.current || hs ? (typeof Ht == "function" && (Gm(c, p, Ht, y),
            tt = c.memoizedState),
            (Ce = hs || h_(c, p, Ce, y, at, tt, le) || !1) ? (Xe || typeof V.UNSAFE_componentWillUpdate != "function" && typeof V.componentWillUpdate != "function" || (typeof V.componentWillUpdate == "function" && V.componentWillUpdate(y, tt, le),
            typeof V.UNSAFE_componentWillUpdate == "function" && V.UNSAFE_componentWillUpdate(y, tt, le)),
            typeof V.componentDidUpdate == "function" && (c.flags |= 4),
            typeof V.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof V.componentDidUpdate != "function" || j === a.memoizedProps && at === a.memoizedState || (c.flags |= 4),
            typeof V.getSnapshotBeforeUpdate != "function" || j === a.memoizedProps && at === a.memoizedState || (c.flags |= 1024),
            c.memoizedProps = y,
            c.memoizedState = tt),
            V.props = y,
            V.state = tt,
            V.context = le,
            y = Ce) : (typeof V.componentDidUpdate != "function" || j === a.memoizedProps && at === a.memoizedState || (c.flags |= 4),
            typeof V.getSnapshotBeforeUpdate != "function" || j === a.memoizedProps && at === a.memoizedState || (c.flags |= 1024),
            y = !1)
        }
        return c0(a, c, p, y, C, b)
    }
    function c0(a, c, p, y, b, C) {
        Q_(a, c);
        var V = (c.flags & 128) !== 0;
        if (!y && !V)
            return b && na(c, p, !1),
            Wr(a, c, C);
        y = c.stateNode,
        KC.current = c;
        var j = V && typeof p.getDerivedStateFromError != "function" ? null : y.render();
        return c.flags |= 1,
        a !== null && V ? (c.child = la(c, a.child, null, C),
        c.child = la(c, null, j, C)) : Zn(a, c, j, C),
        c.memoizedState = y.state,
        b && na(c, p, !0),
        c.child
    }
    function ty(a) {
        var c = a.stateNode;
        c.pendingContext ? Qi(a, c.pendingContext, c.pendingContext !== c.context) : c.context && Qi(a, c.context, !1),
        Zm(a, c.containerInfo)
    }
    function ny(a, c, p, y, b) {
        return aa(),
        Ym(b),
        c.flags |= 256,
        Zn(a, c, p, y),
        c.child
    }
    var Cf = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function Tf(a) {
        return {
            baseLanes: a,
            cachePool: null
        }
    }
    function iy(a, c, p) {
        var y = c.pendingProps, b = Jt.current, C = !1, V = (c.flags & 128) !== 0, j;
        if ((j = V) || (j = a !== null && a.memoizedState === null ? !1 : (b & 2) !== 0),
        j ? (C = !0,
        c.flags &= -129) : (a === null || a.memoizedState !== null) && (b |= 1),
        Ie(Jt, b & 1),
        a === null)
            return qm(c),
            a = c.memoizedState,
            a !== null && (a = a.dehydrated,
            a !== null) ? (c.mode & 1 ? Jo(a) ? c.lanes = 8 : c.lanes = 1073741824 : c.lanes = 1,
            null) : (b = y.children,
            a = y.fallback,
            C ? (y = c.mode,
            C = c.child,
            b = {
                mode: "hidden",
                children: b
            },
            !(y & 1) && C !== null ? (C.childLanes = 0,
            C.pendingProps = b) : C = $f(b, y, 0, null),
            a = so(a, y, p, null),
            C.return = c,
            a.return = c,
            C.sibling = a,
            c.child = C,
            c.child.memoizedState = Tf(p),
            c.memoizedState = Cf,
            a) : u0(c, b));
        if (b = a.memoizedState,
        b !== null) {
            if (j = b.dehydrated,
            j !== null) {
                if (V)
                    return c.flags & 256 ? (c.flags &= -257,
                    Af(a, c, p, Error(o(422)))) : c.memoizedState !== null ? (c.child = a.child,
                    c.flags |= 128,
                    null) : (C = y.fallback,
                    b = c.mode,
                    y = $f({
                        mode: "visible",
                        children: y.children
                    }, b, 0, null),
                    C = so(C, b, p, null),
                    C.flags |= 2,
                    y.return = c,
                    C.return = c,
                    y.sibling = C,
                    c.child = y,
                    c.mode & 1 && la(c, a.child, null, p),
                    c.child.memoizedState = Tf(p),
                    c.memoizedState = Cf,
                    C);
                if (!(c.mode & 1))
                    c = Af(a, c, p, null);
                else if (Jo(j))
                    c = Af(a, c, p, Error(o(419)));
                else if (y = (p & a.childLanes) !== 0,
                Mi || y) {
                    if (y = mn,
                    y !== null) {
                        switch (p & -p) {
                        case 4:
                            C = 2;
                            break;
                        case 16:
                            C = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            C = 32;
                            break;
                        case 536870912:
                            C = 268435456;
                            break;
                        default:
                            C = 0
                        }
                        y = C & (y.suspendedLanes | p) ? 0 : C,
                        y !== 0 && y !== b.retryLane && (b.retryLane = y,
                        ki(a, y, -1))
                    }
                    P0(),
                    c = Af(a, c, p, Error(o(421)))
                } else
                    Pl(j) ? (c.flags |= 128,
                    c.child = a.child,
                    c = u5.bind(null, a),
                    Qo(j, c),
                    c = null) : (p = b.treeContext,
                    pe && (Si = Qu(j),
                    yi = c,
                    Zt = !0,
                    tr = null,
                    Nl = !1,
                    p !== null && (Oi[Di++] = Vr,
                    Oi[Di++] = Hr,
                    Oi[Di++] = Ks,
                    Vr = p.id,
                    Hr = p.overflow,
                    Ks = c)),
                    c = u0(c, c.pendingProps.children),
                    c.flags |= 4096);
                return c
            }
            return C ? (y = sy(a, c, y.children, y.fallback, p),
            C = c.child,
            b = a.child.memoizedState,
            C.memoizedState = b === null ? Tf(p) : {
                baseLanes: b.baseLanes | p,
                cachePool: null
            },
            C.childLanes = a.childLanes & ~p,
            c.memoizedState = Cf,
            y) : (p = ry(a, c, y.children, p),
            c.memoizedState = null,
            p)
        }
        return C ? (y = sy(a, c, y.children, y.fallback, p),
        C = c.child,
        b = a.child.memoizedState,
        C.memoizedState = b === null ? Tf(p) : {
            baseLanes: b.baseLanes | p,
            cachePool: null
        },
        C.childLanes = a.childLanes & ~p,
        c.memoizedState = Cf,
        y) : (p = ry(a, c, y.children, p),
        c.memoizedState = null,
        p)
    }
    function u0(a, c) {
        return c = $f({
            mode: "visible",
            children: c
        }, a.mode, 0, null),
        c.return = a,
        a.child = c
    }
    function ry(a, c, p, y) {
        var b = a.child;
        return a = b.sibling,
        p = _s(b, {
            mode: "visible",
            children: p
        }),
        !(c.mode & 1) && (p.lanes = y),
        p.return = c,
        p.sibling = null,
        a !== null && (y = c.deletions,
        y === null ? (c.deletions = [a],
        c.flags |= 16) : y.push(a)),
        c.child = p
    }
    function sy(a, c, p, y, b) {
        var C = c.mode;
        a = a.child;
        var V = a.sibling
          , j = {
            mode: "hidden",
            children: p
        };
        return !(C & 1) && c.child !== a ? (p = c.child,
        p.childLanes = 0,
        p.pendingProps = j,
        c.deletions = null) : (p = _s(a, j),
        p.subtreeFlags = a.subtreeFlags & 14680064),
        V !== null ? y = _s(V, y) : (y = so(y, C, b, null),
        y.flags |= 2),
        y.return = c,
        p.return = c,
        p.sibling = y,
        c.child = p,
        y
    }
    function Af(a, c, p, y) {
        return y !== null && Ym(y),
        la(c, a.child, null, p),
        a = u0(c, c.pendingProps.children),
        a.flags |= 2,
        c.memoizedState = null,
        a
    }
    function oy(a, c, p) {
        a.lanes |= c;
        var y = a.alternate;
        y !== null && (y.lanes |= c),
        Vm(a.return, c, p)
    }
    function f0(a, c, p, y, b) {
        var C = a.memoizedState;
        C === null ? a.memoizedState = {
            isBackwards: c,
            rendering: null,
            renderingStartTime: 0,
            last: y,
            tail: p,
            tailMode: b
        } : (C.isBackwards = c,
        C.rendering = null,
        C.renderingStartTime = 0,
        C.last = y,
        C.tail = p,
        C.tailMode = b)
    }
    function ay(a, c, p) {
        var y = c.pendingProps
          , b = y.revealOrder
          , C = y.tail;
        if (Zn(a, c, y.children, p),
        y = Jt.current,
        y & 2)
            y = y & 1 | 2,
            c.flags |= 128;
        else {
            if (a !== null && a.flags & 128)
                e: for (a = c.child; a !== null; ) {
                    if (a.tag === 13)
                        a.memoizedState !== null && oy(a, p, c);
                    else if (a.tag === 19)
                        oy(a, p, c);
                    else if (a.child !== null) {
                        a.child.return = a,
                        a = a.child;
                        continue
                    }
                    if (a === c)
                        break e;
                    for (; a.sibling === null; ) {
                        if (a.return === null || a.return === c)
                            break e;
                        a = a.return
                    }
                    a.sibling.return = a.return,
                    a = a.sibling
                }
            y &= 1
        }
        if (Ie(Jt, y),
        !(c.mode & 1))
            c.memoizedState = null;
        else
            switch (b) {
            case "forwards":
                for (p = c.child,
                b = null; p !== null; )
                    a = p.alternate,
                    a !== null && gf(a) === null && (b = p),
                    p = p.sibling;
                p = b,
                p === null ? (b = c.child,
                c.child = null) : (b = p.sibling,
                p.sibling = null),
                f0(c, !1, b, p, C);
                break;
            case "backwards":
                for (p = null,
                b = c.child,
                c.child = null; b !== null; ) {
                    if (a = b.alternate,
                    a !== null && gf(a) === null) {
                        c.child = b;
                        break
                    }
                    a = b.sibling,
                    b.sibling = p,
                    p = b,
                    b = a
                }
                f0(c, !0, p, null, C);
                break;
            case "together":
                f0(c, !1, null, null, void 0);
                break;
            default:
                c.memoizedState = null
            }
        return c.child
    }
    function Wr(a, c, p) {
        if (a !== null && (c.dependencies = a.dependencies),
        ha |= c.lanes,
        !(p & c.childLanes))
            return null;
        if (a !== null && c.child !== a.child)
            throw Error(o(153));
        if (c.child !== null) {
            for (a = c.child,
            p = _s(a, a.pendingProps),
            c.child = p,
            p.return = c; a.sibling !== null; )
                a = a.sibling,
                p = p.sibling = _s(a, a.pendingProps),
                p.return = c;
            p.sibling = null
        }
        return c.child
    }
    function JC(a, c, p) {
        switch (c.tag) {
        case 3:
            ty(c),
            aa();
            break;
        case 5:
            w_(c);
            break;
        case 1:
            Tn(c.type) && Nn(c);
            break;
        case 4:
            Zm(c, c.stateNode.containerInfo);
            break;
        case 10:
            l_(c, c.type._context, c.memoizedProps.value);
            break;
        case 13:
            var y = c.memoizedState;
            if (y !== null)
                return y.dehydrated !== null ? (Ie(Jt, Jt.current & 1),
                c.flags |= 128,
                null) : p & c.child.childLanes ? iy(a, c, p) : (Ie(Jt, Jt.current & 1),
                a = Wr(a, c, p),
                a !== null ? a.sibling : null);
            Ie(Jt, Jt.current & 1);
            break;
        case 19:
            if (y = (p & c.childLanes) !== 0,
            a.flags & 128) {
                if (y)
                    return ay(a, c, p);
                c.flags |= 128
            }
            var b = c.memoizedState;
            if (b !== null && (b.rendering = null,
            b.tail = null,
            b.lastEffect = null),
            Ie(Jt, Jt.current),
            y)
                break;
            return null;
        case 22:
        case 23:
            return c.lanes = 0,
            J_(a, c, p)
        }
        return Wr(a, c, p)
    }
    function QC(a, c) {
        switch (Xm(c),
        c.tag) {
        case 1:
            return Tn(c.type) && qt(),
            a = c.flags,
            a & 65536 ? (c.flags = a & -65537 | 128,
            c) : null;
        case 3:
            return ua(),
            nt(Xt),
            nt(ht),
            Qm(),
            a = c.flags,
            a & 65536 && !(a & 128) ? (c.flags = a & -65537 | 128,
            c) : null;
        case 5:
            return Km(c),
            null;
        case 13:
            if (nt(Jt),
            a = c.memoizedState,
            a !== null && a.dehydrated !== null) {
                if (c.alternate === null)
                    throw Error(o(340));
                aa()
            }
            return a = c.flags,
            a & 65536 ? (c.flags = a & -65537 | 128,
            c) : null;
        case 19:
            return nt(Jt),
            null;
        case 4:
            return ua(),
            null;
        case 10:
            return zm(c.type._context),
            null;
        case 22:
        case 23:
            return R0(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Rf = !1
      , eo = !1
      , e5 = typeof WeakSet == "function" ? WeakSet : Set
      , Fe = null;
    function Pf(a, c) {
        var p = a.ref;
        if (p !== null)
            if (typeof p == "function")
                try {
                    p(null)
                } catch (y) {
                    ui(a, c, y)
                }
            else
                p.current = null
    }
    function d0(a, c, p) {
        try {
            p()
        } catch (y) {
            ui(a, c, y)
        }
    }
    var ly = !1;
    function t5(a, c) {
        for (ee(a.containerInfo),
        Fe = c; Fe !== null; )
            if (a = Fe,
            c = a.child,
            (a.subtreeFlags & 1028) !== 0 && c !== null)
                c.return = a,
                Fe = c;
            else
                for (; Fe !== null; ) {
                    a = Fe;
                    try {
                        var p = a.alternate;
                        if (a.flags & 1024)
                            switch (a.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (p !== null) {
                                    var y = p.memoizedProps
                                      , b = p.memoizedState
                                      , C = a.stateNode
                                      , V = C.getSnapshotBeforeUpdate(a.elementType === a.type ? y : er(a.type, y), b);
                                    C.__reactInternalSnapshotBeforeUpdate = V
                                }
                                break;
                            case 3:
                                ke && Ne(a.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                            }
                    } catch (j) {
                        ui(a, a.return, j)
                    }
                    if (c = a.sibling,
                    c !== null) {
                        c.return = a.return,
                        Fe = c;
                        break
                    }
                    Fe = a.return
                }
        return p = ly,
        ly = !1,
        p
    }
    function to(a, c, p) {
        var y = c.updateQueue;
        if (y = y !== null ? y.lastEffect : null,
        y !== null) {
            var b = y = y.next;
            do {
                if ((b.tag & a) === a) {
                    var C = b.destroy;
                    b.destroy = void 0,
                    C !== void 0 && d0(c, p, C)
                }
                b = b.next
            } while (b !== y)
        }
    }
    function jl(a, c) {
        if (c = c.updateQueue,
        c = c !== null ? c.lastEffect : null,
        c !== null) {
            var p = c = c.next;
            do {
                if ((p.tag & a) === a) {
                    var y = p.create;
                    p.destroy = y()
                }
                p = p.next
            } while (p !== c)
        }
    }
    function h0(a) {
        var c = a.ref;
        if (c !== null) {
            var p = a.stateNode;
            switch (a.tag) {
            case 5:
                a = K(p);
                break;
            default:
                a = p
            }
            typeof c == "function" ? c(a) : c.current = a
        }
    }
    function cy(a, c, p) {
        if (mr && typeof mr.onCommitFiberUnmount == "function")
            try {
                mr.onCommitFiberUnmount(sf, c)
            } catch {}
        switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (a = c.updateQueue,
            a !== null && (a = a.lastEffect,
            a !== null)) {
                var y = a = a.next;
                do {
                    var b = y
                      , C = b.destroy;
                    b = b.tag,
                    C !== void 0 && (b & 2 || b & 4) && d0(c, p, C),
                    y = y.next
                } while (y !== a)
            }
            break;
        case 1:
            if (Pf(c, p),
            a = c.stateNode,
            typeof a.componentWillUnmount == "function")
                try {
                    a.props = c.memoizedProps,
                    a.state = c.memoizedState,
                    a.componentWillUnmount()
                } catch (V) {
                    ui(c, p, V)
                }
            break;
        case 5:
            Pf(c, p);
            break;
        case 4:
            ke ? my(a, c, p) : k && k && (c = c.stateNode.containerInfo,
            p = Tt(c),
            Rt(c, p))
        }
    }
    function uy(a, c, p) {
        for (var y = c; ; )
            if (cy(a, y, p),
            y.child === null || ke && y.tag === 4) {
                if (y === c)
                    break;
                for (; y.sibling === null; ) {
                    if (y.return === null || y.return === c)
                        return;
                    y = y.return
                }
                y.sibling.return = y.return,
                y = y.sibling
            } else
                y.child.return = y,
                y = y.child
    }
    function fy(a) {
        var c = a.alternate;
        c !== null && (a.alternate = null,
        fy(c)),
        a.child = null,
        a.deletions = null,
        a.sibling = null,
        a.tag === 5 && (c = a.stateNode,
        c !== null && $e(c)),
        a.stateNode = null,
        a.return = null,
        a.dependencies = null,
        a.memoizedProps = null,
        a.memoizedState = null,
        a.pendingProps = null,
        a.stateNode = null,
        a.updateQueue = null
    }
    function dy(a) {
        return a.tag === 5 || a.tag === 3 || a.tag === 4
    }
    function hy(a) {
        e: for (; ; ) {
            for (; a.sibling === null; ) {
                if (a.return === null || dy(a.return))
                    return null;
                a = a.return
            }
            for (a.sibling.return = a.return,
            a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
                if (a.flags & 2 || a.child === null || a.tag === 4)
                    continue e;
                a.child.return = a,
                a = a.child
            }
            if (!(a.flags & 2))
                return a.stateNode
        }
    }
    function py(a) {
        if (ke) {
            e: {
                for (var c = a.return; c !== null; ) {
                    if (dy(c))
                        break e;
                    c = c.return
                }
                throw Error(o(160))
            }
            var p = c;
            switch (p.tag) {
            case 5:
                c = p.stateNode,
                p.flags & 32 && (Gt(c),
                p.flags &= -33),
                p = hy(a),
                m0(a, p, c);
                break;
            case 3:
            case 4:
                c = p.stateNode.containerInfo,
                p = hy(a),
                p0(a, p, c);
                break;
            default:
                throw Error(o(161))
            }
        }
    }
    function p0(a, c, p) {
        var y = a.tag;
        if (y === 5 || y === 6)
            a = a.stateNode,
            c ? je(p, a, c) : ft(p, a);
        else if (y !== 4 && (a = a.child,
        a !== null))
            for (p0(a, c, p),
            a = a.sibling; a !== null; )
                p0(a, c, p),
                a = a.sibling
    }
    function m0(a, c, p) {
        var y = a.tag;
        if (y === 5 || y === 6)
            a = a.stateNode,
            c ? dt(p, a, c) : He(p, a);
        else if (y !== 4 && (a = a.child,
        a !== null))
            for (m0(a, c, p),
            a = a.sibling; a !== null; )
                m0(a, c, p),
                a = a.sibling
    }
    function my(a, c, p) {
        for (var y = c, b = !1, C, V; ; ) {
            if (!b) {
                b = y.return;
                e: for (; ; ) {
                    if (b === null)
                        throw Error(o(160));
                    switch (C = b.stateNode,
                    b.tag) {
                    case 5:
                        V = !1;
                        break e;
                    case 3:
                        C = C.containerInfo,
                        V = !0;
                        break e;
                    case 4:
                        C = C.containerInfo,
                        V = !0;
                        break e
                    }
                    b = b.return
                }
                b = !0
            }
            if (y.tag === 5 || y.tag === 6)
                uy(a, y, p),
                V ? Mt(C, y.stateNode) : pt(C, y.stateNode);
            else if (y.tag === 18)
                V ? J(C, y.stateNode) : re(C, y.stateNode);
            else if (y.tag === 4) {
                if (y.child !== null) {
                    C = y.stateNode.containerInfo,
                    V = !0,
                    y.child.return = y,
                    y = y.child;
                    continue
                }
            } else if (cy(a, y, p),
            y.child !== null) {
                y.child.return = y,
                y = y.child;
                continue
            }
            if (y === c)
                break;
            for (; y.sibling === null; ) {
                if (y.return === null || y.return === c)
                    return;
                y = y.return,
                y.tag === 4 && (b = !1)
            }
            y.sibling.return = y.return,
            y = y.sibling
        }
    }
    function g0(a, c) {
        if (ke) {
            switch (c.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                to(3, c, c.return),
                jl(3, c),
                to(5, c, c.return);
                return;
            case 1:
                return;
            case 5:
                var p = c.stateNode;
                if (p != null) {
                    var y = c.memoizedProps;
                    a = a !== null ? a.memoizedProps : y;
                    var b = c.type
                      , C = c.updateQueue;
                    c.updateQueue = null,
                    C !== null && Ct(p, C, b, a, y, c)
                }
                return;
            case 6:
                if (c.stateNode === null)
                    throw Error(o(162));
                p = c.memoizedProps,
                Ee(c.stateNode, a !== null ? a.memoizedProps : p, p);
                return;
            case 3:
                pe && a !== null && a.memoizedState.isDehydrated && Y(c.stateNode.containerInfo);
                return;
            case 12:
                return;
            case 13:
                If(c);
                return;
            case 19:
                If(c);
                return;
            case 17:
                return
            }
            throw Error(o(163))
        }
        switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            to(3, c, c.return),
            jl(3, c),
            to(5, c, c.return);
            return;
        case 12:
            return;
        case 13:
            If(c);
            return;
        case 19:
            If(c);
            return;
        case 3:
            pe && a !== null && a.memoizedState.isDehydrated && Y(c.stateNode.containerInfo);
            break;
        case 22:
        case 23:
            return
        }
        e: if (k) {
            switch (c.tag) {
            case 1:
            case 5:
            case 6:
                break e;
            case 3:
            case 4:
                c = c.stateNode,
                Rt(c.containerInfo, c.pendingChildren);
                break e
            }
            throw Error(o(163))
        }
    }
    function If(a) {
        var c = a.updateQueue;
        if (c !== null) {
            a.updateQueue = null;
            var p = a.stateNode;
            p === null && (p = a.stateNode = new e5),
            c.forEach(function(y) {
                var b = f5.bind(null, a, y);
                p.has(y) || (p.add(y),
                y.then(b, b))
            })
        }
    }
    function n5(a, c) {
        for (Fe = c; Fe !== null; ) {
            c = Fe;
            var p = c.deletions;
            if (p !== null)
                for (var y = 0; y < p.length; y++) {
                    var b = p[y];
                    try {
                        var C = a;
                        ke ? my(C, b, c) : uy(C, b, c);
                        var V = b.alternate;
                        V !== null && (V.return = null),
                        b.return = null
                    } catch (et) {
                        ui(b, c, et)
                    }
                }
            if (p = c.child,
            c.subtreeFlags & 12854 && p !== null)
                p.return = c,
                Fe = p;
            else
                for (; Fe !== null; ) {
                    c = Fe;
                    try {
                        var j = c.flags;
                        if (j & 32 && ke && Gt(c.stateNode),
                        j & 512) {
                            var le = c.alternate;
                            if (le !== null) {
                                var Ce = le.ref;
                                Ce !== null && (typeof Ce == "function" ? Ce(null) : Ce.current = null)
                            }
                        }
                        if (j & 8192)
                            switch (c.tag) {
                            case 13:
                                if (c.memoizedState !== null) {
                                    var Xe = c.alternate;
                                    (Xe === null || Xe.memoizedState === null) && (w0 = An())
                                }
                                break;
                            case 22:
                                var gt = c.memoizedState !== null
                                  , at = c.alternate
                                  , Ht = at !== null && at.memoizedState !== null;
                                if (p = c,
                                ke) {
                                    e: if (y = p,
                                    b = gt,
                                    C = null,
                                    ke)
                                        for (var tt = y; ; ) {
                                            if (tt.tag === 5) {
                                                if (C === null) {
                                                    C = tt;
                                                    var Vn = tt.stateNode;
                                                    b ? $(Vn) : me(tt.stateNode, tt.memoizedProps)
                                                }
                                            } else if (tt.tag === 6) {
                                                if (C === null) {
                                                    var zi = tt.stateNode;
                                                    b ? Ae(zi) : xe(zi, tt.memoizedProps)
                                                }
                                            } else if ((tt.tag !== 22 && tt.tag !== 23 || tt.memoizedState === null || tt === y) && tt.child !== null) {
                                                tt.child.return = tt,
                                                tt = tt.child;
                                                continue
                                            }
                                            if (tt === y)
                                                break;
                                            for (; tt.sibling === null; ) {
                                                if (tt.return === null || tt.return === y)
                                                    break e;
                                                C === tt && (C = null),
                                                tt = tt.return
                                            }
                                            C === tt && (C = null),
                                            tt.sibling.return = tt.return,
                                            tt = tt.sibling
                                        }
                                }
                                if (gt && !Ht && p.mode & 1) {
                                    Fe = p;
                                    for (var ne = p.child; ne !== null; ) {
                                        for (p = Fe = ne; Fe !== null; ) {
                                            y = Fe;
                                            var Z = y.child;
                                            switch (y.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                to(4, y, y.return);
                                                break;
                                            case 1:
                                                Pf(y, y.return);
                                                var ae = y.stateNode;
                                                if (typeof ae.componentWillUnmount == "function") {
                                                    var Ve = y.return;
                                                    try {
                                                        ae.props = y.memoizedProps,
                                                        ae.state = y.memoizedState,
                                                        ae.componentWillUnmount()
                                                    } catch (et) {
                                                        ui(y, Ve, et)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                Pf(y, y.return);
                                                break;
                                            case 22:
                                                if (y.memoizedState !== null) {
                                                    xy(p);
                                                    continue
                                                }
                                            }
                                            Z !== null ? (Z.return = y,
                                            Fe = Z) : xy(p)
                                        }
                                        ne = ne.sibling
                                    }
                                }
                            }
                        switch (j & 4102) {
                        case 2:
                            py(c),
                            c.flags &= -3;
                            break;
                        case 6:
                            py(c),
                            c.flags &= -3,
                            g0(c.alternate, c);
                            break;
                        case 4096:
                            c.flags &= -4097;
                            break;
                        case 4100:
                            c.flags &= -4097,
                            g0(c.alternate, c);
                            break;
                        case 4:
                            g0(c.alternate, c)
                        }
                    } catch (et) {
                        ui(c, c.return, et)
                    }
                    if (p = c.sibling,
                    p !== null) {
                        p.return = c.return,
                        Fe = p;
                        break
                    }
                    Fe = c.return
                }
        }
    }
    function i5(a, c, p) {
        Fe = a,
        gy(a)
    }
    function gy(a, c, p) {
        for (var y = (a.mode & 1) !== 0; Fe !== null; ) {
            var b = Fe
              , C = b.child;
            if (b.tag === 22 && y) {
                var V = b.memoizedState !== null || Rf;
                if (!V) {
                    var j = b.alternate
                      , le = j !== null && j.memoizedState !== null || eo;
                    j = Rf;
                    var Ce = eo;
                    if (Rf = V,
                    (eo = le) && !Ce)
                        for (Fe = b; Fe !== null; )
                            V = Fe,
                            le = V.child,
                            V.tag === 22 && V.memoizedState !== null ? _y(b) : le !== null ? (le.return = V,
                            Fe = le) : _y(b);
                    for (; C !== null; )
                        Fe = C,
                        gy(C),
                        C = C.sibling;
                    Fe = b,
                    Rf = j,
                    eo = Ce
                }
                vy(a)
            } else
                b.subtreeFlags & 8772 && C !== null ? (C.return = b,
                Fe = C) : vy(a)
        }
    }
    function vy(a) {
        for (; Fe !== null; ) {
            var c = Fe;
            if (c.flags & 8772) {
                var p = c.alternate;
                try {
                    if (c.flags & 8772)
                        switch (c.tag) {
                        case 0:
                        case 11:
                        case 15:
                            eo || jl(5, c);
                            break;
                        case 1:
                            var y = c.stateNode;
                            if (c.flags & 4 && !eo)
                                if (p === null)
                                    y.componentDidMount();
                                else {
                                    var b = c.elementType === c.type ? p.memoizedProps : er(c.type, p.memoizedProps);
                                    y.componentDidUpdate(b, p.memoizedState, y.__reactInternalSnapshotBeforeUpdate)
                                }
                            var C = c.updateQueue;
                            C !== null && f_(c, C, y);
                            break;
                        case 3:
                            var V = c.updateQueue;
                            if (V !== null) {
                                if (p = null,
                                c.child !== null)
                                    switch (c.child.tag) {
                                    case 5:
                                        p = K(c.child.stateNode);
                                        break;
                                    case 1:
                                        p = c.child.stateNode
                                    }
                                f_(c, V, p)
                            }
                            break;
                        case 5:
                            var j = c.stateNode;
                            p === null && c.flags & 4 && We(j, c.type, c.memoizedProps, c);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (pe && c.memoizedState === null) {
                                var le = c.alternate;
                                if (le !== null) {
                                    var Ce = le.memoizedState;
                                    if (Ce !== null) {
                                        var Xe = Ce.dehydrated;
                                        Xe !== null && ie(Xe)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                        }
                    eo || c.flags & 512 && h0(c)
                } catch (gt) {
                    ui(c, c.return, gt)
                }
            }
            if (c === a) {
                Fe = null;
                break
            }
            if (p = c.sibling,
            p !== null) {
                p.return = c.return,
                Fe = p;
                break
            }
            Fe = c.return
        }
    }
    function xy(a) {
        for (; Fe !== null; ) {
            var c = Fe;
            if (c === a) {
                Fe = null;
                break
            }
            var p = c.sibling;
            if (p !== null) {
                p.return = c.return,
                Fe = p;
                break
            }
            Fe = c.return
        }
    }
    function _y(a) {
        for (; Fe !== null; ) {
            var c = Fe;
            try {
                switch (c.tag) {
                case 0:
                case 11:
                case 15:
                    var p = c.return;
                    try {
                        jl(4, c)
                    } catch (le) {
                        ui(c, p, le)
                    }
                    break;
                case 1:
                    var y = c.stateNode;
                    if (typeof y.componentDidMount == "function") {
                        var b = c.return;
                        try {
                            y.componentDidMount()
                        } catch (le) {
                            ui(c, b, le)
                        }
                    }
                    var C = c.return;
                    try {
                        h0(c)
                    } catch (le) {
                        ui(c, C, le)
                    }
                    break;
                case 5:
                    var V = c.return;
                    try {
                        h0(c)
                    } catch (le) {
                        ui(c, V, le)
                    }
                }
            } catch (le) {
                ui(c, c.return, le)
            }
            if (c === a) {
                Fe = null;
                break
            }
            var j = c.sibling;
            if (j !== null) {
                j.return = c.return,
                Fe = j;
                break
            }
            Fe = c.return
        }
    }
    var Lf = 0
      , Nf = 1
      , Of = 2
      , Df = 3
      , Uf = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var Xl = Symbol.for;
        Lf = Xl("selector.component"),
        Nf = Xl("selector.has_pseudo_class"),
        Of = Xl("selector.role"),
        Df = Xl("selector.test_id"),
        Uf = Xl("selector.text")
    }
    function v0(a) {
        var c = ye(a);
        if (c != null) {
            if (typeof c.memoizedProps["data-testname"] != "string")
                throw Error(o(364));
            return c
        }
        if (a = L(a),
        a === null)
            throw Error(o(362));
        return a.stateNode.current
    }
    function x0(a, c) {
        switch (c.$$typeof) {
        case Lf:
            if (a.type === c.value)
                return !0;
            break;
        case Nf:
            e: {
                c = c.value,
                a = [a, 0];
                for (var p = 0; p < a.length; ) {
                    var y = a[p++]
                      , b = a[p++]
                      , C = c[b];
                    if (y.tag !== 5 || !ge(y)) {
                        for (; C != null && x0(y, C); )
                            b++,
                            C = c[b];
                        if (b === c.length) {
                            c = !0;
                            break e
                        } else
                            for (y = y.child; y !== null; )
                                a.push(y, b),
                                y = y.sibling
                    }
                }
                c = !1
            }
            return c;
        case Of:
            if (a.tag === 5 && ve(a.stateNode, c.value))
                return !0;
            break;
        case Uf:
            if ((a.tag === 5 || a.tag === 6) && (a = _e(a),
            a !== null && 0 <= a.indexOf(c.value)))
                return !0;
            break;
        case Df:
            if (a.tag === 5 && (a = a.memoizedProps["data-testname"],
            typeof a == "string" && a.toLowerCase() === c.value.toLowerCase()))
                return !0;
            break;
        default:
            throw Error(o(365))
        }
        return !1
    }
    function _0(a) {
        switch (a.$$typeof) {
        case Lf:
            return "<" + (A(a.value) || "Unknown") + ">";
        case Nf:
            return ":has(" + (_0(a) || "") + ")";
        case Of:
            return '[role="' + a.value + '"]';
        case Uf:
            return '"' + a.value + '"';
        case Df:
            return '[data-testname="' + a.value + '"]';
        default:
            throw Error(o(365))
        }
    }
    function yy(a, c) {
        var p = [];
        a = [a, 0];
        for (var y = 0; y < a.length; ) {
            var b = a[y++]
              , C = a[y++]
              , V = c[C];
            if (b.tag !== 5 || !ge(b)) {
                for (; V != null && x0(b, V); )
                    C++,
                    V = c[C];
                if (C === c.length)
                    p.push(b);
                else
                    for (b = b.child; b !== null; )
                        a.push(b, C),
                        b = b.sibling
            }
        }
        return p
    }
    function y0(a, c) {
        if (!H)
            throw Error(o(363));
        a = v0(a),
        a = yy(a, c),
        c = [],
        a = Array.from(a);
        for (var p = 0; p < a.length; ) {
            var y = a[p++];
            if (y.tag === 5)
                ge(y) || c.push(y.stateNode);
            else
                for (y = y.child; y !== null; )
                    a.push(y),
                    y = y.sibling
        }
        return c
    }
    var r5 = Math.ceil
      , Ff = l.ReactCurrentDispatcher
      , S0 = l.ReactCurrentOwner
      , un = l.ReactCurrentBatchConfig
      , bt = 0
      , mn = null
      , gn = null
      , On = 0
      , wi = 0
      , da = tn(0)
      , wn = 0
      , $l = null
      , ha = 0
      , kf = 0
      , M0 = 0
      , ql = null
      , li = null
      , w0 = 0
      , b0 = 1 / 0;
    function pa() {
        b0 = An() + 500
    }
    var Bf = !1
      , E0 = null
      , ms = null
      , zf = !1
      , gs = null
      , Vf = 0
      , Yl = 0
      , C0 = null
      , Hf = -1
      , Gf = 0;
    function Kn() {
        return bt & 6 ? An() : Hf !== -1 ? Hf : Hf = An()
    }
    function vs(a) {
        return a.mode & 1 ? bt & 2 && On !== 0 ? On & -On : zC.transition !== null ? (Gf === 0 && (a = tf,
        tf <<= 1,
        !(tf & 4194240) && (tf = 64),
        Gf = a),
        Gf) : (a = Nt,
        a !== 0 ? a : fe()) : 1
    }
    function ki(a, c, p) {
        if (50 < Yl)
            throw Yl = 0,
            C0 = null,
            Error(o(185));
        var y = Wf(a, c);
        return y === null ? null : (Ll(y, c, p),
        (!(bt & 2) || y !== mn) && (y === mn && (!(bt & 2) && (kf |= c),
        wn === 4 && xs(y, On)),
        ci(y, p),
        c === 1 && bt === 0 && !(a.mode & 1) && (pa(),
        of && vr())),
        y)
    }
    function Wf(a, c) {
        a.lanes |= c;
        var p = a.alternate;
        for (p !== null && (p.lanes |= c),
        p = a,
        a = a.return; a !== null; )
            a.childLanes |= c,
            p = a.alternate,
            p !== null && (p.childLanes |= c),
            p = a,
            a = a.return;
        return p.tag === 3 ? p.stateNode : null
    }
    function ci(a, c) {
        var p = a.callbackNode;
        IC(a, c);
        var y = rf(a, a === mn ? On : 0);
        if (y === 0)
            p !== null && o_(p),
            a.callbackNode = null,
            a.callbackPriority = 0;
        else if (c = y & -y,
        a.callbackPriority !== c) {
            if (p != null && o_(p),
            c === 1)
                a.tag === 0 ? BC(My.bind(null, a)) : a_(My.bind(null, a)),
                Le ? Be(function() {
                    bt === 0 && vr()
                }) : Om(Dm, vr),
                p = null;
            else {
                switch (s_(y)) {
                case 1:
                    p = Dm;
                    break;
                case 4:
                    p = DC;
                    break;
                case 16:
                    p = Um;
                    break;
                case 536870912:
                    p = UC;
                    break;
                default:
                    p = Um
                }
                p = Iy(p, Sy.bind(null, a))
            }
            a.callbackPriority = c,
            a.callbackNode = p
        }
    }
    function Sy(a, c) {
        if (Hf = -1,
        Gf = 0,
        bt & 6)
            throw Error(o(327));
        var p = a.callbackNode;
        if (ro() && a.callbackNode !== p)
            return null;
        var y = rf(a, a === mn ? On : 0);
        if (y === 0)
            return null;
        if (y & 30 || y & a.expiredLanes || c)
            c = jf(a, y);
        else {
            c = y;
            var b = bt;
            bt |= 2;
            var C = Ey();
            (mn !== a || On !== c) && (pa(),
            no(a, c));
            do
                try {
                    a5();
                    break
                } catch (j) {
                    by(a, j)
                }
            while (!0);
            Bm(),
            Ff.current = C,
            bt = b,
            gn !== null ? c = 0 : (mn = null,
            On = 0,
            c = wn)
        }
        if (c !== 0) {
            if (c === 2 && (b = Im(a),
            b !== 0 && (y = b,
            c = T0(a, b))),
            c === 1)
                throw p = $l,
                no(a, 0),
                xs(a, y),
                ci(a, An()),
                p;
            if (c === 6)
                xs(a, y);
            else {
                if (b = a.current.alternate,
                !(y & 30) && !s5(b) && (c = jf(a, y),
                c === 2 && (C = Im(a),
                C !== 0 && (y = C,
                c = T0(a, C))),
                c === 1))
                    throw p = $l,
                    no(a, 0),
                    xs(a, y),
                    ci(a, An()),
                    p;
                switch (a.finishedWork = b,
                a.finishedLanes = y,
                c) {
                case 0:
                case 1:
                    throw Error(o(345));
                case 2:
                    io(a, li);
                    break;
                case 3:
                    if (xs(a, y),
                    (y & 130023424) === y && (c = w0 + 500 - An(),
                    10 < c)) {
                        if (rf(a, 0) !== 0)
                            break;
                        if (b = a.suspendedLanes,
                        (b & y) !== y) {
                            Kn(),
                            a.pingedLanes |= a.suspendedLanes & b;
                            break
                        }
                        a.timeoutHandle = Me(io.bind(null, a, li), c);
                        break
                    }
                    io(a, li);
                    break;
                case 4:
                    if (xs(a, y),
                    (y & 4194240) === y)
                        break;
                    for (c = a.eventTimes,
                    b = -1; 0 < y; ) {
                        var V = 31 - _i(y);
                        C = 1 << V,
                        V = c[V],
                        V > b && (b = V),
                        y &= ~C
                    }
                    if (y = b,
                    y = An() - y,
                    y = (120 > y ? 120 : 480 > y ? 480 : 1080 > y ? 1080 : 1920 > y ? 1920 : 3e3 > y ? 3e3 : 4320 > y ? 4320 : 1960 * r5(y / 1960)) - y,
                    10 < y) {
                        a.timeoutHandle = Me(io.bind(null, a, li), y);
                        break
                    }
                    io(a, li);
                    break;
                case 5:
                    io(a, li);
                    break;
                default:
                    throw Error(o(329))
                }
            }
        }
        return ci(a, An()),
        a.callbackNode === p ? Sy.bind(null, a) : null
    }
    function T0(a, c) {
        var p = ql;
        return a.current.memoizedState.isDehydrated && (no(a, c).flags |= 256),
        a = jf(a, c),
        a !== 2 && (c = li,
        li = p,
        c !== null && A0(c)),
        a
    }
    function A0(a) {
        li === null ? li = a : li.push.apply(li, a)
    }
    function s5(a) {
        for (var c = a; ; ) {
            if (c.flags & 16384) {
                var p = c.updateQueue;
                if (p !== null && (p = p.stores,
                p !== null))
                    for (var y = 0; y < p.length; y++) {
                        var b = p[y]
                          , C = b.getSnapshot;
                        b = b.value;
                        try {
                            if (!gr(C(), b))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (p = c.child,
            c.subtreeFlags & 16384 && p !== null)
                p.return = c,
                c = p;
            else {
                if (c === a)
                    break;
                for (; c.sibling === null; ) {
                    if (c.return === null || c.return === a)
                        return !0;
                    c = c.return
                }
                c.sibling.return = c.return,
                c = c.sibling
            }
        }
        return !0
    }
    function xs(a, c) {
        for (c &= ~M0,
        c &= ~kf,
        a.suspendedLanes |= c,
        a.pingedLanes &= ~c,
        a = a.expirationTimes; 0 < c; ) {
            var p = 31 - _i(c)
              , y = 1 << p;
            a[p] = -1,
            c &= ~y
        }
    }
    function My(a) {
        if (bt & 6)
            throw Error(o(327));
        ro();
        var c = rf(a, 0);
        if (!(c & 1))
            return ci(a, An()),
            null;
        var p = jf(a, c);
        if (a.tag !== 0 && p === 2) {
            var y = Im(a);
            y !== 0 && (c = y,
            p = T0(a, y))
        }
        if (p === 1)
            throw p = $l,
            no(a, 0),
            xs(a, c),
            ci(a, An()),
            p;
        if (p === 6)
            throw Error(o(345));
        return a.finishedWork = a.current.alternate,
        a.finishedLanes = c,
        io(a, li),
        ci(a, An()),
        null
    }
    function wy(a) {
        gs !== null && gs.tag === 0 && !(bt & 6) && ro();
        var c = bt;
        bt |= 1;
        var p = un.transition
          , y = Nt;
        try {
            if (un.transition = null,
            Nt = 1,
            a)
                return a()
        } finally {
            Nt = y,
            un.transition = p,
            bt = c,
            !(bt & 6) && vr()
        }
    }
    function R0() {
        wi = da.current,
        nt(da)
    }
    function no(a, c) {
        a.finishedWork = null,
        a.finishedLanes = 0;
        var p = a.timeoutHandle;
        if (p !== Qe && (a.timeoutHandle = Qe,
        Ye(p)),
        gn !== null)
            for (p = gn.return; p !== null; ) {
                var y = p;
                switch (Xm(y),
                y.tag) {
                case 1:
                    y = y.type.childContextTypes,
                    y != null && qt();
                    break;
                case 3:
                    ua(),
                    nt(Xt),
                    nt(ht),
                    Qm();
                    break;
                case 5:
                    Km(y);
                    break;
                case 4:
                    ua();
                    break;
                case 13:
                    nt(Jt);
                    break;
                case 19:
                    nt(Jt);
                    break;
                case 10:
                    zm(y.type._context);
                    break;
                case 22:
                case 23:
                    R0()
                }
                p = p.return
            }
        if (mn = a,
        gn = a = _s(a.current, null),
        On = wi = c,
        wn = 0,
        $l = null,
        M0 = kf = ha = 0,
        li = ql = null,
        xr !== null) {
            for (c = 0; c < xr.length; c++)
                if (p = xr[c],
                y = p.interleaved,
                y !== null) {
                    p.interleaved = null;
                    var b = y.next
                      , C = p.pending;
                    if (C !== null) {
                        var V = C.next;
                        C.next = b,
                        y.next = V
                    }
                    p.pending = y
                }
            xr = null
        }
        return a
    }
    function by(a, c) {
        do {
            var p = gn;
            try {
                if (Bm(),
                vf.current = wf,
                xf) {
                    for (var y = nn.memoizedState; y !== null; ) {
                        var b = y.queue;
                        b !== null && (b.pending = null),
                        y = y.next
                    }
                    xf = !1
                }
                if (fa = 0,
                Rn = kn = nn = null,
                kl = !1,
                Bl = 0,
                S0.current = null,
                p === null || p.return === null) {
                    wn = 1,
                    $l = c,
                    gn = null;
                    break
                }
                e: {
                    var C = a
                      , V = p.return
                      , j = p
                      , le = c;
                    if (c = On,
                    j.flags |= 32768,
                    le !== null && typeof le == "object" && typeof le.then == "function") {
                        var Ce = le
                          , Xe = j
                          , gt = Xe.tag;
                        if (!(Xe.mode & 1) && (gt === 0 || gt === 11 || gt === 15)) {
                            var at = Xe.alternate;
                            at ? (Xe.updateQueue = at.updateQueue,
                            Xe.memoizedState = at.memoizedState,
                            Xe.lanes = at.lanes) : (Xe.updateQueue = null,
                            Xe.memoizedState = null)
                        }
                        var Ht = j_(V);
                        if (Ht !== null) {
                            Ht.flags &= -257,
                            X_(Ht, V, j, C, c),
                            Ht.mode & 1 && W_(C, Ce, c),
                            c = Ht,
                            le = Ce;
                            var tt = c.updateQueue;
                            if (tt === null) {
                                var Vn = new Set;
                                Vn.add(le),
                                c.updateQueue = Vn
                            } else
                                tt.add(le);
                            break e
                        } else {
                            if (!(c & 1)) {
                                W_(C, Ce, c),
                                P0();
                                break e
                            }
                            le = Error(o(426))
                        }
                    } else if (Zt && j.mode & 1) {
                        var zi = j_(V);
                        if (zi !== null) {
                            !(zi.flags & 65536) && (zi.flags |= 256),
                            X_(zi, V, j, C, c),
                            Ym(le);
                            break e
                        }
                    }
                    C = le,
                    wn !== 4 && (wn = 2),
                    ql === null ? ql = [C] : ql.push(C),
                    le = o0(le, j),
                    j = V;
                    do {
                        switch (j.tag) {
                        case 3:
                            j.flags |= 65536,
                            c &= -c,
                            j.lanes |= c;
                            var ne = H_(j, le, c);
                            u_(j, ne);
                            break e;
                        case 1:
                            C = le;
                            var Z = j.type
                              , ae = j.stateNode;
                            if (!(j.flags & 128) && (typeof Z.getDerivedStateFromError == "function" || ae !== null && typeof ae.componentDidCatch == "function" && (ms === null || !ms.has(ae)))) {
                                j.flags |= 65536,
                                c &= -c,
                                j.lanes |= c;
                                var Ve = G_(j, C, c);
                                u_(j, Ve);
                                break e
                            }
                        }
                        j = j.return
                    } while (j !== null)
                }
                Ty(p)
            } catch (et) {
                c = et,
                gn === p && p !== null && (gn = p = p.return);
                continue
            }
            break
        } while (!0)
    }
    function Ey() {
        var a = Ff.current;
        return Ff.current = wf,
        a === null ? wf : a
    }
    function P0() {
        (wn === 0 || wn === 3 || wn === 2) && (wn = 4),
        mn === null || !(ha & 268435455) && !(kf & 268435455) || xs(mn, On)
    }
    function jf(a, c) {
        var p = bt;
        bt |= 2;
        var y = Ey();
        mn === a && On === c || no(a, c);
        do
            try {
                o5();
                break
            } catch (b) {
                by(a, b)
            }
        while (!0);
        if (Bm(),
        bt = p,
        Ff.current = y,
        gn !== null)
            throw Error(o(261));
        return mn = null,
        On = 0,
        wn
    }
    function o5() {
        for (; gn !== null; )
            Cy(gn)
    }
    function a5() {
        for (; gn !== null && !NC(); )
            Cy(gn)
    }
    function Cy(a) {
        var c = Py(a.alternate, a, wi);
        a.memoizedProps = a.pendingProps,
        c === null ? Ty(a) : gn = c,
        S0.current = null
    }
    function Ty(a) {
        var c = a;
        do {
            var p = c.alternate;
            if (a = c.return,
            c.flags & 32768) {
                if (p = QC(p, c),
                p !== null) {
                    p.flags &= 32767,
                    gn = p;
                    return
                }
                if (a !== null)
                    a.flags |= 32768,
                    a.subtreeFlags = 0,
                    a.deletions = null;
                else {
                    wn = 6,
                    gn = null;
                    return
                }
            } else if (p = ZC(p, c, wi),
            p !== null) {
                gn = p;
                return
            }
            if (c = c.sibling,
            c !== null) {
                gn = c;
                return
            }
            gn = c = a
        } while (c !== null);
        wn === 0 && (wn = 5)
    }
    function io(a, c) {
        var p = Nt
          , y = un.transition;
        try {
            un.transition = null,
            Nt = 1,
            l5(a, c, p)
        } finally {
            un.transition = y,
            Nt = p
        }
        return null
    }
    function l5(a, c, p) {
        do
            ro();
        while (gs !== null);
        if (bt & 6)
            throw Error(o(327));
        var y = a.finishedWork
          , b = a.finishedLanes;
        if (y === null)
            return null;
        if (a.finishedWork = null,
        a.finishedLanes = 0,
        y === a.current)
            throw Error(o(177));
        a.callbackNode = null,
        a.callbackPriority = 0;
        var C = y.lanes | y.childLanes;
        if (LC(a, C),
        a === mn && (gn = mn = null,
        On = 0),
        !(y.subtreeFlags & 2064) && !(y.flags & 2064) || zf || (zf = !0,
        Iy(Um, function() {
            return ro(),
            null
        })),
        C = (y.flags & 15990) !== 0,
        y.subtreeFlags & 15990 || C) {
            C = un.transition,
            un.transition = null;
            var V = Nt;
            Nt = 1;
            var j = bt;
            bt |= 4,
            S0.current = null,
            t5(a, y),
            n5(a, y),
            Q(a.containerInfo),
            a.current = y,
            i5(y),
            OC(),
            bt = j,
            Nt = V,
            un.transition = C
        } else
            a.current = y;
        if (zf && (zf = !1,
        gs = a,
        Vf = b),
        C = a.pendingLanes,
        C === 0 && (ms = null),
        FC(y.stateNode),
        ci(a, An()),
        c !== null)
            for (p = a.onRecoverableError,
            y = 0; y < c.length; y++)
                p(c[y]);
        if (Bf)
            throw Bf = !1,
            a = E0,
            E0 = null,
            a;
        return Vf & 1 && a.tag !== 0 && ro(),
        C = a.pendingLanes,
        C & 1 ? a === C0 ? Yl++ : (Yl = 0,
        C0 = a) : Yl = 0,
        vr(),
        null
    }
    function ro() {
        if (gs !== null) {
            var a = s_(Vf)
              , c = un.transition
              , p = Nt;
            try {
                if (un.transition = null,
                Nt = 16 > a ? 16 : a,
                gs === null)
                    var y = !1;
                else {
                    if (a = gs,
                    gs = null,
                    Vf = 0,
                    bt & 6)
                        throw Error(o(331));
                    var b = bt;
                    for (bt |= 4,
                    Fe = a.current; Fe !== null; ) {
                        var C = Fe
                          , V = C.child;
                        if (Fe.flags & 16) {
                            var j = C.deletions;
                            if (j !== null) {
                                for (var le = 0; le < j.length; le++) {
                                    var Ce = j[le];
                                    for (Fe = Ce; Fe !== null; ) {
                                        var Xe = Fe;
                                        switch (Xe.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            to(8, Xe, C)
                                        }
                                        var gt = Xe.child;
                                        if (gt !== null)
                                            gt.return = Xe,
                                            Fe = gt;
                                        else
                                            for (; Fe !== null; ) {
                                                Xe = Fe;
                                                var at = Xe.sibling
                                                  , Ht = Xe.return;
                                                if (fy(Xe),
                                                Xe === Ce) {
                                                    Fe = null;
                                                    break
                                                }
                                                if (at !== null) {
                                                    at.return = Ht,
                                                    Fe = at;
                                                    break
                                                }
                                                Fe = Ht
                                            }
                                    }
                                }
                                var tt = C.alternate;
                                if (tt !== null) {
                                    var Vn = tt.child;
                                    if (Vn !== null) {
                                        tt.child = null;
                                        do {
                                            var zi = Vn.sibling;
                                            Vn.sibling = null,
                                            Vn = zi
                                        } while (Vn !== null)
                                    }
                                }
                                Fe = C
                            }
                        }
                        if (C.subtreeFlags & 2064 && V !== null)
                            V.return = C,
                            Fe = V;
                        else
                            e: for (; Fe !== null; ) {
                                if (C = Fe,
                                C.flags & 2048)
                                    switch (C.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        to(9, C, C.return)
                                    }
                                var ne = C.sibling;
                                if (ne !== null) {
                                    ne.return = C.return,
                                    Fe = ne;
                                    break e
                                }
                                Fe = C.return
                            }
                    }
                    var Z = a.current;
                    for (Fe = Z; Fe !== null; ) {
                        V = Fe;
                        var ae = V.child;
                        if (V.subtreeFlags & 2064 && ae !== null)
                            ae.return = V,
                            Fe = ae;
                        else
                            e: for (V = Z; Fe !== null; ) {
                                if (j = Fe,
                                j.flags & 2048)
                                    try {
                                        switch (j.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            jl(9, j)
                                        }
                                    } catch (et) {
                                        ui(j, j.return, et)
                                    }
                                if (j === V) {
                                    Fe = null;
                                    break e
                                }
                                var Ve = j.sibling;
                                if (Ve !== null) {
                                    Ve.return = j.return,
                                    Fe = Ve;
                                    break e
                                }
                                Fe = j.return
                            }
                    }
                    if (bt = b,
                    vr(),
                    mr && typeof mr.onPostCommitFiberRoot == "function")
                        try {
                            mr.onPostCommitFiberRoot(sf, a)
                        } catch {}
                    y = !0
                }
                return y
            } finally {
                Nt = p,
                un.transition = c
            }
        }
        return !1
    }
    function Ay(a, c, p) {
        c = o0(p, c),
        c = H_(a, c, 1),
        ps(a, c),
        c = Kn(),
        a = Wf(a, 1),
        a !== null && (Ll(a, 1, c),
        ci(a, c))
    }
    function ui(a, c, p) {
        if (a.tag === 3)
            Ay(a, a, p);
        else
            for (; c !== null; ) {
                if (c.tag === 3) {
                    Ay(c, a, p);
                    break
                } else if (c.tag === 1) {
                    var y = c.stateNode;
                    if (typeof c.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (ms === null || !ms.has(y))) {
                        a = o0(p, a),
                        a = G_(c, a, 1),
                        ps(c, a),
                        a = Kn(),
                        c = Wf(c, 1),
                        c !== null && (Ll(c, 1, a),
                        ci(c, a));
                        break
                    }
                }
                c = c.return
            }
    }
    function c5(a, c, p) {
        var y = a.pingCache;
        y !== null && y.delete(c),
        c = Kn(),
        a.pingedLanes |= a.suspendedLanes & p,
        mn === a && (On & p) === p && (wn === 4 || wn === 3 && (On & 130023424) === On && 500 > An() - w0 ? no(a, 0) : M0 |= p),
        ci(a, c)
    }
    function Ry(a, c) {
        c === 0 && (a.mode & 1 ? (c = nf,
        nf <<= 1,
        !(nf & 130023424) && (nf = 4194304)) : c = 1);
        var p = Kn();
        a = Wf(a, c),
        a !== null && (Ll(a, c, p),
        ci(a, p))
    }
    function u5(a) {
        var c = a.memoizedState
          , p = 0;
        c !== null && (p = c.retryLane),
        Ry(a, p)
    }
    function f5(a, c) {
        var p = 0;
        switch (a.tag) {
        case 13:
            var y = a.stateNode
              , b = a.memoizedState;
            b !== null && (p = b.retryLane);
            break;
        case 19:
            y = a.stateNode;
            break;
        default:
            throw Error(o(314))
        }
        y !== null && y.delete(c),
        Ry(a, p)
    }
    var Py;
    Py = function(a, c, p) {
        if (a !== null)
            if (a.memoizedProps !== c.pendingProps || Xt.current)
                Mi = !0;
            else {
                if (!(a.lanes & p) && !(c.flags & 128))
                    return Mi = !1,
                    JC(a, c, p);
                Mi = !!(a.flags & 131072)
            }
        else
            Mi = !1,
            Zt && c.flags & 1048576 && g_(c, pf, c.index);
        switch (c.lanes = 0,
        c.tag) {
        case 2:
            var y = c.type;
            a !== null && (a.alternate = null,
            c.alternate = null,
            c.flags |= 2),
            a = c.pendingProps;
            var b = pn(c, ht.current);
            ra(c, p),
            b = t0(null, c, y, a, b, p);
            var C = n0();
            return c.flags |= 1,
            typeof b == "object" && b !== null && typeof b.render == "function" && b.$$typeof === void 0 ? (c.tag = 1,
            c.memoizedState = null,
            c.updateQueue = null,
            Tn(y) ? (C = !0,
            Nn(c)) : C = !1,
            c.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null,
            Hm(c),
            b.updater = df,
            c.stateNode = b,
            b._reactInternals = c,
            Wm(c, y, a, p),
            c = c0(null, c, y, !0, C, p)) : (c.tag = 0,
            Zt && C && jm(c),
            Zn(null, c, b, p),
            c = c.child),
            c;
        case 16:
            y = c.elementType;
            e: {
                switch (a !== null && (a.alternate = null,
                c.alternate = null,
                c.flags |= 2),
                a = c.pendingProps,
                b = y._init,
                y = b(y._payload),
                c.type = y,
                b = c.tag = h5(y),
                a = er(y, a),
                b) {
                case 0:
                    c = l0(null, c, y, a, p);
                    break e;
                case 1:
                    c = ey(null, c, y, a, p);
                    break e;
                case 11:
                    c = Y_(null, c, y, a, p);
                    break e;
                case 14:
                    c = Z_(null, c, y, er(y.type, a), p);
                    break e
                }
                throw Error(o(306, y, ""))
            }
            return c;
        case 0:
            return y = c.type,
            b = c.pendingProps,
            b = c.elementType === y ? b : er(y, b),
            l0(a, c, y, b, p);
        case 1:
            return y = c.type,
            b = c.pendingProps,
            b = c.elementType === y ? b : er(y, b),
            ey(a, c, y, b, p);
        case 3:
            e: {
                if (ty(c),
                a === null)
                    throw Error(o(387));
                y = c.pendingProps,
                C = c.memoizedState,
                b = C.element,
                c_(a, c),
                ff(c, y, null, p);
                var V = c.memoizedState;
                if (y = V.element,
                pe && C.isDehydrated)
                    if (C = {
                        element: y,
                        isDehydrated: !1,
                        cache: V.cache,
                        transitions: V.transitions
                    },
                    c.updateQueue.baseState = C,
                    c.memoizedState = C,
                    c.flags & 256) {
                        b = Error(o(423)),
                        c = ny(a, c, y, p, b);
                        break e
                    } else if (y !== b) {
                        b = Error(o(424)),
                        c = ny(a, c, y, p, b);
                        break e
                    } else
                        for (pe && (Si = Ju(c.stateNode.containerInfo),
                        yi = c,
                        Zt = !0,
                        tr = null,
                        Nl = !1),
                        p = M_(c, null, y, p),
                        c.child = p; p; )
                            p.flags = p.flags & -3 | 4096,
                            p = p.sibling;
                else {
                    if (aa(),
                    y === b) {
                        c = Wr(a, c, p);
                        break e
                    }
                    Zn(a, c, y, p)
                }
                c = c.child
            }
            return c;
        case 5:
            return w_(c),
            a === null && qm(c),
            y = c.type,
            b = c.pendingProps,
            C = a !== null ? a.memoizedProps : null,
            V = b.children,
            ue(y, b) ? V = null : C !== null && ue(y, C) && (c.flags |= 32),
            Q_(a, c),
            Zn(a, c, V, p),
            c.child;
        case 6:
            return a === null && qm(c),
            null;
        case 13:
            return iy(a, c, p);
        case 4:
            return Zm(c, c.stateNode.containerInfo),
            y = c.pendingProps,
            a === null ? c.child = la(c, null, y, p) : Zn(a, c, y, p),
            c.child;
        case 11:
            return y = c.type,
            b = c.pendingProps,
            b = c.elementType === y ? b : er(y, b),
            Y_(a, c, y, b, p);
        case 7:
            return Zn(a, c, c.pendingProps, p),
            c.child;
        case 8:
            return Zn(a, c, c.pendingProps.children, p),
            c.child;
        case 12:
            return Zn(a, c, c.pendingProps.children, p),
            c.child;
        case 10:
            e: {
                if (y = c.type._context,
                b = c.pendingProps,
                C = c.memoizedProps,
                V = b.value,
                l_(c, y, V),
                C !== null)
                    if (gr(C.value, V)) {
                        if (C.children === b.children && !Xt.current) {
                            c = Wr(a, c, p);
                            break e
                        }
                    } else
                        for (C = c.child,
                        C !== null && (C.return = c); C !== null; ) {
                            var j = C.dependencies;
                            if (j !== null) {
                                V = C.child;
                                for (var le = j.firstContext; le !== null; ) {
                                    if (le.context === y) {
                                        if (C.tag === 1) {
                                            le = zr(-1, p & -p),
                                            le.tag = 2;
                                            var Ce = C.updateQueue;
                                            if (Ce !== null) {
                                                Ce = Ce.shared;
                                                var Xe = Ce.pending;
                                                Xe === null ? le.next = le : (le.next = Xe.next,
                                                Xe.next = le),
                                                Ce.pending = le
                                            }
                                        }
                                        C.lanes |= p,
                                        le = C.alternate,
                                        le !== null && (le.lanes |= p),
                                        Vm(C.return, p, c),
                                        j.lanes |= p;
                                        break
                                    }
                                    le = le.next
                                }
                            } else if (C.tag === 10)
                                V = C.type === c.type ? null : C.child;
                            else if (C.tag === 18) {
                                if (V = C.return,
                                V === null)
                                    throw Error(o(341));
                                V.lanes |= p,
                                j = V.alternate,
                                j !== null && (j.lanes |= p),
                                Vm(V, p, c),
                                V = C.sibling
                            } else
                                V = C.child;
                            if (V !== null)
                                V.return = C;
                            else
                                for (V = C; V !== null; ) {
                                    if (V === c) {
                                        V = null;
                                        break
                                    }
                                    if (C = V.sibling,
                                    C !== null) {
                                        C.return = V.return,
                                        V = C;
                                        break
                                    }
                                    V = V.return
                                }
                            C = V
                        }
                Zn(a, c, b.children, p),
                c = c.child
            }
            return c;
        case 9:
            return b = c.type,
            y = c.pendingProps.children,
            ra(c, p),
            b = Ni(b),
            y = y(b),
            c.flags |= 1,
            Zn(a, c, y, p),
            c.child;
        case 14:
            return y = c.type,
            b = er(y, c.pendingProps),
            b = er(y.type, b),
            Z_(a, c, y, b, p);
        case 15:
            return K_(a, c, c.type, c.pendingProps, p);
        case 17:
            return y = c.type,
            b = c.pendingProps,
            b = c.elementType === y ? b : er(y, b),
            a !== null && (a.alternate = null,
            c.alternate = null,
            c.flags |= 2),
            c.tag = 1,
            Tn(y) ? (a = !0,
            Nn(c)) : a = !1,
            ra(c, p),
            p_(c, y, b),
            Wm(c, y, b, p),
            c0(null, c, y, !0, a, p);
        case 19:
            return ay(a, c, p);
        case 22:
            return J_(a, c, p)
        }
        throw Error(o(156, c.tag))
    }
    ;
    function Iy(a, c) {
        return Om(a, c)
    }
    function d5(a, c, p, y) {
        this.tag = a,
        this.key = p,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = c,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = y,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Bi(a, c, p, y) {
        return new d5(a,c,p,y)
    }
    function I0(a) {
        return a = a.prototype,
        !(!a || !a.isReactComponent)
    }
    function h5(a) {
        if (typeof a == "function")
            return I0(a) ? 1 : 0;
        if (a != null) {
            if (a = a.$$typeof,
            a === S)
                return 11;
            if (a === M)
                return 14
        }
        return 2
    }
    function _s(a, c) {
        var p = a.alternate;
        return p === null ? (p = Bi(a.tag, c, a.key, a.mode),
        p.elementType = a.elementType,
        p.type = a.type,
        p.stateNode = a.stateNode,
        p.alternate = a,
        a.alternate = p) : (p.pendingProps = c,
        p.type = a.type,
        p.flags = 0,
        p.subtreeFlags = 0,
        p.deletions = null),
        p.flags = a.flags & 14680064,
        p.childLanes = a.childLanes,
        p.lanes = a.lanes,
        p.child = a.child,
        p.memoizedProps = a.memoizedProps,
        p.memoizedState = a.memoizedState,
        p.updateQueue = a.updateQueue,
        c = a.dependencies,
        p.dependencies = c === null ? null : {
            lanes: c.lanes,
            firstContext: c.firstContext
        },
        p.sibling = a.sibling,
        p.index = a.index,
        p.ref = a.ref,
        p
    }
    function Xf(a, c, p, y, b, C) {
        var V = 2;
        if (y = a,
        typeof a == "function")
            I0(a) && (V = 1);
        else if (typeof a == "string")
            V = 5;
        else
            e: switch (a) {
            case d:
                return so(p.children, b, C, c);
            case h:
                V = 8,
                b |= 8;
                break;
            case m:
                return a = Bi(12, p, c, b | 2),
                a.elementType = m,
                a.lanes = C,
                a;
            case _:
                return a = Bi(13, p, c, b),
                a.elementType = _,
                a.lanes = C,
                a;
            case v:
                return a = Bi(19, p, c, b),
                a.elementType = v,
                a.lanes = C,
                a;
            case E:
                return $f(p, b, C, c);
            default:
                if (typeof a == "object" && a !== null)
                    switch (a.$$typeof) {
                    case g:
                        V = 10;
                        break e;
                    case x:
                        V = 9;
                        break e;
                    case S:
                        V = 11;
                        break e;
                    case M:
                        V = 14;
                        break e;
                    case w:
                        V = 16,
                        y = null;
                        break e
                    }
                throw Error(o(130, a == null ? a : typeof a, ""))
            }
        return c = Bi(V, p, c, b),
        c.elementType = a,
        c.type = y,
        c.lanes = C,
        c
    }
    function so(a, c, p, y) {
        return a = Bi(7, a, y, c),
        a.lanes = p,
        a
    }
    function $f(a, c, p, y) {
        return a = Bi(22, a, y, c),
        a.elementType = E,
        a.lanes = p,
        a.stateNode = {},
        a
    }
    function L0(a, c, p) {
        return a = Bi(6, a, null, c),
        a.lanes = p,
        a
    }
    function N0(a, c, p) {
        return c = Bi(4, a.children !== null ? a.children : [], a.key, c),
        c.lanes = p,
        c.stateNode = {
            containerInfo: a.containerInfo,
            pendingChildren: null,
            implementation: a.implementation
        },
        c
    }
    function p5(a, c, p, y, b) {
        this.tag = c,
        this.containerInfo = a,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = Qe,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = Lm(0),
        this.expirationTimes = Lm(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Lm(0),
        this.identifierPrefix = y,
        this.onRecoverableError = b,
        pe && (this.mutableSourceEagerHydrationData = null)
    }
    function Ly(a, c, p, y, b, C, V, j, le) {
        return a = new p5(a,c,p,j,le),
        c === 1 ? (c = 1,
        C === !0 && (c |= 8)) : c = 0,
        C = Bi(3, null, null, c),
        a.current = C,
        C.stateNode = a,
        C.memoizedState = {
            element: y,
            isDehydrated: p,
            cache: null,
            transitions: null
        },
        Hm(C),
        a
    }
    function Ny(a) {
        if (!a)
            return jt;
        a = a._reactInternals;
        e: {
            if (I(a) !== a || a.tag !== 1)
                throw Error(o(170));
            var c = a;
            do {
                switch (c.tag) {
                case 3:
                    c = c.stateNode.context;
                    break e;
                case 1:
                    if (Tn(c.type)) {
                        c = c.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                c = c.return
            } while (c !== null);
            throw Error(o(171))
        }
        if (a.tag === 1) {
            var p = a.type;
            if (Tn(p))
                return ta(a, p, c)
        }
        return c
    }
    function Oy(a) {
        var c = a._reactInternals;
        if (c === void 0)
            throw typeof a.render == "function" ? Error(o(188)) : (a = Object.keys(a).join(","),
            Error(o(268, a)));
        return a = W(c),
        a === null ? null : a.stateNode
    }
    function Dy(a, c) {
        if (a = a.memoizedState,
        a !== null && a.dehydrated !== null) {
            var p = a.retryLane;
            a.retryLane = p !== 0 && p < c ? p : c
        }
    }
    function O0(a, c) {
        Dy(a, c),
        (a = a.alternate) && Dy(a, c)
    }
    function m5(a) {
        return a = W(a),
        a === null ? null : a.stateNode
    }
    function g5() {
        return null
    }
    return t.attemptContinuousHydration = function(a) {
        if (a.tag === 13) {
            var c = Kn();
            ki(a, 134217728, c),
            O0(a, 134217728)
        }
    }
    ,
    t.attemptHydrationAtCurrentPriority = function(a) {
        if (a.tag === 13) {
            var c = Kn()
              , p = vs(a);
            ki(a, p, c),
            O0(a, p)
        }
    }
    ,
    t.attemptSynchronousHydration = function(a) {
        switch (a.tag) {
        case 3:
            var c = a.stateNode;
            if (c.current.memoizedState.isDehydrated) {
                var p = Il(c.pendingLanes);
                p !== 0 && (Nm(c, p | 1),
                ci(c, An()),
                !(bt & 6) && (pa(),
                vr()))
            }
            break;
        case 13:
            var y = Kn();
            wy(function() {
                return ki(a, 1, y)
            }),
            O0(a, 1)
        }
    }
    ,
    t.batchedUpdates = function(a, c) {
        var p = bt;
        bt |= 1;
        try {
            return a(c)
        } finally {
            bt = p,
            bt === 0 && (pa(),
            of && vr())
        }
    }
    ,
    t.createComponentSelector = function(a) {
        return {
            $$typeof: Lf,
            value: a
        }
    }
    ,
    t.createContainer = function(a, c, p, y, b, C, V) {
        return Ly(a, c, !1, null, p, y, b, C, V)
    }
    ,
    t.createHasPseudoClassSelector = function(a) {
        return {
            $$typeof: Nf,
            value: a
        }
    }
    ,
    t.createHydrationContainer = function(a, c, p, y, b, C, V, j, le) {
        return a = Ly(p, y, !0, a, b, C, V, j, le),
        a.context = Ny(null),
        p = a.current,
        y = Kn(),
        b = vs(p),
        C = zr(y, b),
        C.callback = c ?? null,
        ps(p, C),
        a.current.lanes = b,
        Ll(a, b, y),
        ci(a, y),
        a
    }
    ,
    t.createPortal = function(a, c, p) {
        var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: f,
            key: y == null ? null : "" + y,
            children: a,
            containerInfo: c,
            implementation: p
        }
    }
    ,
    t.createRoleSelector = function(a) {
        return {
            $$typeof: Of,
            value: a
        }
    }
    ,
    t.createTestNameSelector = function(a) {
        return {
            $$typeof: Df,
            value: a
        }
    }
    ,
    t.createTextSelector = function(a) {
        return {
            $$typeof: Uf,
            value: a
        }
    }
    ,
    t.deferredUpdates = function(a) {
        var c = Nt
          , p = un.transition;
        try {
            return un.transition = null,
            Nt = 16,
            a()
        } finally {
            Nt = c,
            un.transition = p
        }
    }
    ,
    t.discreteUpdates = function(a, c, p, y, b) {
        var C = Nt
          , V = un.transition;
        try {
            return un.transition = null,
            Nt = 1,
            a(c, p, y, b)
        } finally {
            Nt = C,
            un.transition = V,
            bt === 0 && pa()
        }
    }
    ,
    t.findAllNodes = y0,
    t.findBoundingRects = function(a, c) {
        if (!H)
            throw Error(o(363));
        c = y0(a, c),
        a = [];
        for (var p = 0; p < c.length; p++)
            a.push(te(c[p]));
        for (c = a.length - 1; 0 < c; c--) {
            p = a[c];
            for (var y = p.x, b = y + p.width, C = p.y, V = C + p.height, j = c - 1; 0 <= j; j--)
                if (c !== j) {
                    var le = a[j]
                      , Ce = le.x
                      , Xe = Ce + le.width
                      , gt = le.y
                      , at = gt + le.height;
                    if (y >= Ce && C >= gt && b <= Xe && V <= at) {
                        a.splice(c, 1);
                        break
                    } else if (y !== Ce || p.width !== le.width || at < C || gt > V) {
                        if (!(C !== gt || p.height !== le.height || Xe < y || Ce > b)) {
                            Ce > y && (le.width += Ce - y,
                            le.x = y),
                            Xe < b && (le.width = b - Ce),
                            a.splice(c, 1);
                            break
                        }
                    } else {
                        gt > C && (le.height += gt - C,
                        le.y = C),
                        at < V && (le.height = V - gt),
                        a.splice(c, 1);
                        break
                    }
                }
        }
        return a
    }
    ,
    t.findHostInstance = Oy,
    t.findHostInstanceWithNoPortals = function(a) {
        return a = D(a),
        a = a !== null ? G(a) : null,
        a === null ? null : a.stateNode
    }
    ,
    t.findHostInstanceWithWarning = function(a) {
        return Oy(a)
    }
    ,
    t.flushControlled = function(a) {
        var c = bt;
        bt |= 1;
        var p = un.transition
          , y = Nt;
        try {
            un.transition = null,
            Nt = 1,
            a()
        } finally {
            Nt = y,
            un.transition = p,
            bt = c,
            bt === 0 && (pa(),
            vr())
        }
    }
    ,
    t.flushPassiveEffects = ro,
    t.flushSync = wy,
    t.focusWithin = function(a, c) {
        if (!H)
            throw Error(o(363));
        for (a = v0(a),
        c = yy(a, c),
        c = Array.from(c),
        a = 0; a < c.length; ) {
            var p = c[a++];
            if (!ge(p)) {
                if (p.tag === 5 && Ke(p.stateNode))
                    return !0;
                for (p = p.child; p !== null; )
                    c.push(p),
                    p = p.sibling
            }
        }
        return !1
    }
    ,
    t.getCurrentUpdatePriority = function() {
        return Nt
    }
    ,
    t.getFindAllNodesFailureDescription = function(a, c) {
        if (!H)
            throw Error(o(363));
        var p = 0
          , y = [];
        a = [v0(a), 0];
        for (var b = 0; b < a.length; ) {
            var C = a[b++]
              , V = a[b++]
              , j = c[V];
            if ((C.tag !== 5 || !ge(C)) && (x0(C, j) && (y.push(_0(j)),
            V++,
            V > p && (p = V)),
            V < c.length))
                for (C = C.child; C !== null; )
                    a.push(C, V),
                    C = C.sibling
        }
        if (p < c.length) {
            for (a = []; p < c.length; p++)
                a.push(_0(c[p]));
            return `findAllNodes was able to match part of the selector:
  ` + (y.join(" > ") + `

No matching component was found for:
  `) + a.join(" > ")
        }
        return null
    }
    ,
    t.getPublicRootInstance = function(a) {
        if (a = a.current,
        !a.child)
            return null;
        switch (a.child.tag) {
        case 5:
            return K(a.child.stateNode);
        default:
            return a.child.stateNode
        }
    }
    ,
    t.injectIntoDevTools = function(a) {
        if (a = {
            bundleType: a.bundleType,
            version: a.version,
            rendererPackageName: a.rendererPackageName,
            rendererConfig: a.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: l.ReactCurrentDispatcher,
            findHostInstanceByFiber: m5,
            findFiberByHostInstance: a.findFiberByHostInstance || g5,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329"
        },
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            a = !1;
        else {
            var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (c.isDisabled || !c.supportsFiber)
                a = !0;
            else {
                try {
                    sf = c.inject(a),
                    mr = c
                } catch {}
                a = !!c.checkDCE
            }
        }
        return a
    }
    ,
    t.isAlreadyRendering = function() {
        return !1
    }
    ,
    t.observeVisibleRects = function(a, c, p, y) {
        if (!H)
            throw Error(o(363));
        a = y0(a, c);
        var b = we(a, p, y).disconnect;
        return {
            disconnect: function() {
                b()
            }
        }
    }
    ,
    t.registerMutableSourceForHydration = function(a, c) {
        var p = c._getVersion;
        p = p(c._source),
        a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [c, p] : a.mutableSourceEagerHydrationData.push(c, p)
    }
    ,
    t.runWithPriority = function(a, c) {
        var p = Nt;
        try {
            return Nt = a,
            c()
        } finally {
            Nt = p
        }
    }
    ,
    t.shouldError = function() {
        return null
    }
    ,
    t.shouldSuspend = function() {
        return !1
    }
    ,
    t.updateContainer = function(a, c, p, y) {
        var b = c.current
          , C = Kn()
          , V = vs(b);
        return p = Ny(p),
        c.context === null ? c.context = p : c.pendingContext = p,
        c = zr(C, V),
        c.payload = {
            element: a
        },
        y = y === void 0 ? null : y,
        y !== null && (c.callback = y),
        ps(b, c),
        a = ki(b, V, C),
        a !== null && uf(a, b, V),
        V
    }
    ,
    t
};
FE.exports = yF;
var SF = FE.exports;
const MF = s3(SF)
  , Hx = {}
  , Wu = n => void Object.assign(Hx, n);
function wF(n, e) {
    function t(d, {args: h=[], attach: m, ...g}, x) {
        let S = `${d[0].toUpperCase()}${d.slice(1)}`, _;
        if (d === "primitive") {
            if (g.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const v = g.object;
            _ = Ga(v, {
                type: d,
                root: x,
                attach: m,
                primitive: !0
            })
        } else {
            const v = Hx[S];
            if (!v)
                throw new Error(`R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(h))
                throw new Error("R3F: The args prop must be an array!");
            _ = Ga(new v(...h), {
                type: d,
                root: x,
                attach: m,
                memoizedProps: {
                    args: h
                }
            })
        }
        return _.__r3f.attach === void 0 && (_ instanceof St ? _.__r3f.attach = "geometry" : _ instanceof Fn && (_.__r3f.attach = "material")),
        S !== "inject" && $g(_, g),
        _
    }
    function i(d, h) {
        let m = !1;
        if (h) {
            var g, x;
            (g = h.__r3f) != null && g.attach ? Xg(d, h, h.__r3f.attach) : h.isObject3D && d.isObject3D && (d.add(h),
            m = !0),
            m || (x = d.__r3f) == null || x.objects.push(h),
            h.__r3f || Ga(h, {}),
            h.__r3f.parent = d,
            $1(h),
            Wa(h)
        }
    }
    function r(d, h, m) {
        let g = !1;
        if (h) {
            var x, S;
            if ((x = h.__r3f) != null && x.attach)
                Xg(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                h.parent = d,
                h.dispatchEvent({
                    type: "added"
                }),
                d.dispatchEvent({
                    type: "childadded",
                    child: h
                });
                const _ = d.children.filter(M => M !== h)
                  , v = _.indexOf(m);
                d.children = [..._.slice(0, v), h, ..._.slice(v)],
                g = !0
            }
            g || (S = d.__r3f) == null || S.objects.push(h),
            h.__r3f || Ga(h, {}),
            h.__r3f.parent = d,
            $1(h),
            Wa(h)
        }
    }
    function s(d, h, m=!1) {
        d && [...d].forEach(g => o(h, g, m))
    }
    function o(d, h, m) {
        if (h) {
            var g, x, S;
            if (h.__r3f && (h.__r3f.parent = null),
            (g = d.__r3f) != null && g.objects && (d.__r3f.objects = d.__r3f.objects.filter(E => E !== h)),
            (x = h.__r3f) != null && x.attach)
                PM(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                var _;
                d.remove(h),
                (_ = h.__r3f) != null && _.root && IF(ph(h), h)
            }
            const M = (S = h.__r3f) == null ? void 0 : S.primitive
              , w = !M && (m === void 0 ? h.dispose !== null : m);
            if (!M) {
                var v;
                s((v = h.__r3f) == null ? void 0 : v.objects, h, w),
                s(h.children, h, w)
            }
            if (delete h.__r3f,
            w && h.dispose && h.type !== "Scene") {
                const E = () => {
                    try {
                        h.dispose()
                    } catch {}
                }
                ;
                typeof IS_REACT_ACT_ENVIRONMENT > "u" ? j1.unstable_scheduleCallback(j1.unstable_IdlePriority, E) : E()
            }
            Wa(d)
        }
    }
    function l(d, h, m, g) {
        var x;
        const S = (x = d.__r3f) == null ? void 0 : x.parent;
        if (!S)
            return;
        const _ = t(h, m, d.__r3f.root);
        if (d.children) {
            for (const v of d.children)
                v.__r3f && i(_, v);
            d.children = d.children.filter(v => !v.__r3f)
        }
        d.__r3f.objects.forEach(v => i(_, v)),
        d.__r3f.objects = [],
        d.__r3f.autoRemovedBeforeAppend || o(S, d),
        _.parent && (_.__r3f.autoRemovedBeforeAppend = !0),
        i(S, _),
        _.raycast && _.__r3f.eventCount && ph(_).getState().internal.interaction.push(_),
        [g, g.alternate].forEach(v => {
            v !== null && (v.stateNode = _,
            v.ref && (typeof v.ref == "function" ? v.ref(_) : v.ref.current = _))
        }
        )
    }
    const u = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: MF({
            createInstance: t,
            removeChild: o,
            appendChild: i,
            appendInitialChild: i,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (d, h) => {
                if (!h)
                    return;
                const m = d.getState().scene;
                m.__r3f && (m.__r3f.root = d,
                i(m, h))
            }
            ,
            removeChildFromContainer: (d, h) => {
                h && o(d.getState().scene, h)
            }
            ,
            insertInContainerBefore: (d, h, m) => {
                if (!h || !m)
                    return;
                const g = d.getState().scene;
                g.__r3f && r(g, h, m)
            }
            ,
            getRootHostContext: () => null,
            getChildHostContext: d => d,
            finalizeInitialChildren(d) {
                var h;
                return !!((h = d == null ? void 0 : d.__r3f) != null ? h : {}).handlers
            },
            prepareUpdate(d, h, m, g) {
                var x;
                if (((x = d == null ? void 0 : d.__r3f) != null ? x : {}).primitive && g.object && g.object !== d)
                    return [!0];
                {
                    const {args: _=[], children: v, ...M} = g
                      , {args: w=[], children: E, ...O} = m;
                    if (!Array.isArray(_))
                        throw new Error("R3F: the args prop must be an array!");
                    if (_.some( (A, F) => A !== w[F]))
                        return [!0];
                    const R = XE(d, M, O, !0);
                    return R.changes.length ? [!1, R] : null
                }
            },
            commitUpdate(d, [h,m], g, x, S, _) {
                h ? l(d, g, S, _) : $g(d, m)
            },
            commitMount(d, h, m, g) {
                var x;
                const S = (x = d.__r3f) != null ? x : {};
                d.raycast && S.handlers && S.eventCount && ph(d).getState().internal.interaction.push(d)
            },
            getPublicInstance: d => d,
            prepareForCommit: () => null,
            preparePortalMount: d => Ga(d.getState().scene),
            resetAfterCommit: () => {}
            ,
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance(d) {
                var h;
                const {attach: m, parent: g} = (h = d.__r3f) != null ? h : {};
                m && g && PM(g, d, m),
                d.isObject3D && (d.visible = !1),
                Wa(d)
            },
            unhideInstance(d, h) {
                var m;
                const {attach: g, parent: x} = (m = d.__r3f) != null ? m : {};
                g && x && Xg(x, d, g),
                (d.isObject3D && h.visible == null || h.visible) && (d.visible = !0),
                Wa(d)
            },
            createTextInstance: u,
            hideTextInstance: u,
            unhideTextInstance: u,
            getCurrentEventPriority: () => e ? e() : Za.DefaultEventPriority,
            beforeActiveInstanceBlur: () => {}
            ,
            afterActiveInstanceBlur: () => {}
            ,
            detachDeletedInstance: () => {}
            ,
            now: typeof performance < "u" && Yt.fun(performance.now) ? performance.now : Yt.fun(Date.now) ? Date.now : () => 0,
            scheduleTimeout: Yt.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: Yt.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: $g
    }
}
var CM, TM;
const jg = n => "colorSpace"in n || "outputColorSpace"in n
  , zE = () => {
    var n;
    return (n = Hx.ColorManagement) != null ? n : null
}
  , VE = n => n && n.isOrthographicCamera
  , bF = n => n && n.hasOwnProperty("current")
  , ju = typeof window < "u" && ((CM = window.document) != null && CM.createElement || ((TM = window.navigator) == null ? void 0 : TM.product) === "ReactNative") ? N.useLayoutEffect : N.useEffect;
function HE(n) {
    const e = N.useRef(n);
    return ju( () => void (e.current = n), [n]),
    e
}
function EF({set: n}) {
    return ju( () => (n(new Promise( () => null)),
    () => n(!1)), [n]),
    null
}
class GE extends N.Component {
    constructor(...e) {
        super(...e),
        this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
GE.getDerivedStateFromError = () => ({
    error: !0
});
const WE = "__default"
  , AM = new Map
  , CF = n => n && !!n.memoized && !!n.changes;
function jE(n) {
    var e;
    const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n
}
const gc = n => {
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
;
function ph(n) {
    let e = n.__r3f.root;
    for (; e.getState().previousRoot; )
        e = e.getState().previousRoot;
    return e
}
const Yt = {
    obj: n => n === Object(n) && !Yt.arr(n) && typeof n != "function",
    fun: n => typeof n == "function",
    str: n => typeof n == "string",
    num: n => typeof n == "number",
    boo: n => typeof n == "boolean",
    und: n => n === void 0,
    arr: n => Array.isArray(n),
    equ(n, e, {arrays: t="shallow", objects: i="reference", strict: r=!0}={}) {
        if (typeof n != typeof e || !!n != !!e)
            return !1;
        if (Yt.str(n) || Yt.num(n) || Yt.boo(n))
            return n === e;
        const s = Yt.obj(n);
        if (s && i === "reference")
            return n === e;
        const o = Yt.arr(n);
        if (o && t === "reference")
            return n === e;
        if ((o || s) && n === e)
            return !0;
        let l;
        for (l in n)
            if (!(l in e))
                return !1;
        if (s && t === "shallow" && i === "shallow") {
            for (l in r ? e : n)
                if (!Yt.equ(n[l], e[l], {
                    strict: r,
                    objects: "reference"
                }))
                    return !1
        } else
            for (l in r ? e : n)
                if (n[l] !== e[l])
                    return !1;
        if (Yt.und(l)) {
            if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (n !== e)
                return !1
        }
        return !0
    }
};
function TF(n) {
    n.dispose && n.type !== "Scene" && n.dispose();
    for (const e in n)
        e.dispose == null || e.dispose(),
        delete n[e]
}
function Ga(n, e) {
    const t = n;
    return t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    },
    n
}
function X1(n, e) {
    let t = n;
    if (e.includes("-")) {
        const i = e.split("-")
          , r = i.pop();
        return t = i.reduce( (s, o) => s[o], n),
        {
            target: t,
            key: r
        }
    } else
        return {
            target: t,
            key: e
        }
}
const RM = /-\d+$/;
function Xg(n, e, t) {
    if (Yt.str(t)) {
        if (RM.test(t)) {
            const s = t.replace(RM, "")
              , {target: o, key: l} = X1(n, s);
            Array.isArray(o[l]) || (o[l] = [])
        }
        const {target: i, key: r} = X1(n, t);
        e.__r3f.previousAttach = i[r],
        i[r] = e
    } else
        e.__r3f.previousAttach = t(n, e)
}
function PM(n, e, t) {
    var i, r;
    if (Yt.str(t)) {
        const {target: s, key: o} = X1(n, t)
          , l = e.__r3f.previousAttach;
        l === void 0 ? delete s[o] : s[o] = l
    } else
        (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
    (r = e.__r3f) == null || delete r.previousAttach
}
function XE(n, {children: e, key: t, ref: i, ...r}, {children: s, key: o, ref: l, ...u}={}, f=!1) {
    const d = n.__r3f
      , h = Object.entries(r)
      , m = [];
    if (f) {
        const x = Object.keys(u);
        for (let S = 0; S < x.length; S++)
            r.hasOwnProperty(x[S]) || h.unshift([x[S], WE + "remove"])
    }
    h.forEach( ([x,S]) => {
        var _;
        if ((_ = n.__r3f) != null && _.primitive && x === "object" || Yt.equ(S, u[x]))
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(x))
            return m.push([x, S, !0, []]);
        let v = [];
        x.includes("-") && (v = x.split("-")),
        m.push([x, S, !1, v]);
        for (const M in r) {
            const w = r[M];
            M.startsWith(`${x}-`) && m.push([M, w, !1, M.split("-")])
        }
    }
    );
    const g = {
        ...r
    };
    return d != null && d.memoizedProps && d != null && d.memoizedProps.args && (g.args = d.memoizedProps.args),
    d != null && d.memoizedProps && d != null && d.memoizedProps.attach && (g.attach = d.memoizedProps.attach),
    {
        memoized: g,
        changes: m
    }
}
const AF = typeof process < "u" && !1;
function $g(n, e) {
    var t;
    const i = n.__r3f
      , r = i == null ? void 0 : i.root
      , s = r == null || r.getState == null ? void 0 : r.getState()
      , {memoized: o, changes: l} = CF(e) ? e : XE(n, e)
      , u = i == null ? void 0 : i.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = o);
    for (let d = 0; d < l.length; d++) {
        let[h,m,g,x] = l[d];
        if (jg(n)) {
            const M = "srgb"
              , w = "srgb-linear";
            h === "encoding" ? (h = "colorSpace",
            m = m === 3001 ? M : w) : h === "outputEncoding" && (h = "outputColorSpace",
            m = m === 3001 ? M : w)
        }
        let S = n
          , _ = S[h];
        if (x.length && (_ = x.reduce( (v, M) => v[M], n),
        !(_ && _.set))) {
            const [v,...M] = x.reverse();
            S = M.reverse().reduce( (w, E) => w[E], n),
            h = v
        }
        if (m === WE + "remove")
            if (S.constructor) {
                let v = AM.get(S.constructor);
                v || (v = new S.constructor,
                AM.set(S.constructor, v)),
                m = v[h]
            } else
                m = 0;
        if (g && i)
            m ? i.handlers[h] = m : delete i.handlers[h],
            i.eventCount = Object.keys(i.handlers).length;
        else if (_ && _.set && (_.copy || _ instanceof Fo)) {
            if (Array.isArray(m))
                _.fromArray ? _.fromArray(m) : _.set(...m);
            else if (_.copy && m && m.constructor && (AF ? _.constructor.name === m.constructor.name : _.constructor === m.constructor))
                _.copy(m);
            else if (m !== void 0) {
                const v = _ instanceof Oe;
                !v && _.setScalar ? _.setScalar(m) : _ instanceof Fo && m instanceof Fo ? _.mask = m.mask : _.set(m),
                !zE() && s && !s.linear && v && _.convertSRGBToLinear()
            }
        } else if (S[h] = m,
        S[h]instanceof en && S[h].format === qn && S[h].type === fr && s) {
            const v = S[h];
            jg(v) && jg(s.gl) ? v.colorSpace = s.gl.outputColorSpace : v.encoding = s.gl.outputEncoding
        }
        Wa(n)
    }
    if (i && i.parent && n.raycast && u !== i.eventCount) {
        const d = ph(n).getState().internal
          , h = d.interaction.indexOf(n);
        h > -1 && d.interaction.splice(h, 1),
        i.eventCount && d.interaction.push(n)
    }
    return !(l.length === 1 && l[0][0] === "onUpdate") && l.length && (t = n.__r3f) != null && t.parent && $1(n),
    n
}
function Wa(n) {
    var e, t;
    const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    i && i.internal.frames === 0 && i.invalidate()
}
function $1(n) {
    n.onUpdate == null || n.onUpdate(n)
}
function RF(n, e) {
    n.manual || (VE(n) ? (n.left = e.width / -2,
    n.right = e.width / 2,
    n.top = e.height / 2,
    n.bottom = e.height / -2) : n.aspect = e.width / e.height,
    n.updateProjectionMatrix(),
    n.updateMatrixWorld())
}
function Zd(n) {
    return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}
function PF() {
    var n;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e)
        return Za.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
        return Za.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
        return Za.ContinuousEventPriority;
    default:
        return Za.DefaultEventPriority
    }
}
function $E(n, e, t, i) {
    const r = t.get(e);
    r && (t.delete(e),
    t.size === 0 && (n.delete(i),
    r.target.releasePointerCapture(i)))
}
function IF(n, e) {
    const {internal: t} = n.getState();
    t.interaction = t.interaction.filter(i => i !== e),
    t.initialHits = t.initialHits.filter(i => i !== e),
    t.hovered.forEach( (i, r) => {
        (i.eventObject === e || i.object === e) && t.hovered.delete(r)
    }
    ),
    t.capturedMap.forEach( (i, r) => {
        $E(t.capturedMap, e, i, r)
    }
    )
}
function LF(n) {
    function e(u) {
        const {internal: f} = n.getState()
          , d = u.offsetX - f.initialClick[0]
          , h = u.offsetY - f.initialClick[1];
        return Math.round(Math.sqrt(d * d + h * h))
    }
    function t(u) {
        return u.filter(f => ["Move", "Over", "Enter", "Out", "Leave"].some(d => {
            var h;
            return (h = f.__r3f) == null ? void 0 : h.handlers["onPointer" + d]
        }
        ))
    }
    function i(u, f) {
        const d = n.getState()
          , h = new Set
          , m = []
          , g = f ? f(d.internal.interaction) : d.internal.interaction;
        for (let v = 0; v < g.length; v++) {
            const M = gc(g[v]);
            M && (M.raycaster.camera = void 0)
        }
        d.previousRoot || d.events.compute == null || d.events.compute(u, d);
        function x(v) {
            const M = gc(v);
            if (!M || !M.events.enabled || M.raycaster.camera === null)
                return [];
            if (M.raycaster.camera === void 0) {
                var w;
                M.events.compute == null || M.events.compute(u, M, (w = M.previousRoot) == null ? void 0 : w.getState()),
                M.raycaster.camera === void 0 && (M.raycaster.camera = null)
            }
            return M.raycaster.camera ? M.raycaster.intersectObject(v, !0) : []
        }
        let S = g.flatMap(x).sort( (v, M) => {
            const w = gc(v.object)
              , E = gc(M.object);
            return !w || !E ? v.distance - M.distance : E.events.priority - w.events.priority || v.distance - M.distance
        }
        ).filter(v => {
            const M = Zd(v);
            return h.has(M) ? !1 : (h.add(M),
            !0)
        }
        );
        d.events.filter && (S = d.events.filter(S, d));
        for (const v of S) {
            let M = v.object;
            for (; M; ) {
                var _;
                (_ = M.__r3f) != null && _.eventCount && m.push({
                    ...v,
                    eventObject: M
                }),
                M = M.parent
            }
        }
        if ("pointerId"in u && d.internal.capturedMap.has(u.pointerId))
            for (let v of d.internal.capturedMap.get(u.pointerId).values())
                h.has(Zd(v.intersection)) || m.push(v.intersection);
        return m
    }
    function r(u, f, d, h) {
        const m = n.getState();
        if (u.length) {
            const g = {
                stopped: !1
            };
            for (const x of u) {
                const S = gc(x.object) || m
                  , {raycaster: _, pointer: v, camera: M, internal: w} = S
                  , E = new B(v.x,v.y,0).unproject(M)
                  , O = P => {
                    var D, W;
                    return (D = (W = w.capturedMap.get(P)) == null ? void 0 : W.has(x.eventObject)) != null ? D : !1
                }
                  , R = P => {
                    const D = {
                        intersection: x,
                        target: f.target
                    };
                    w.capturedMap.has(P) ? w.capturedMap.get(P).set(x.eventObject, D) : w.capturedMap.set(P, new Map([[x.eventObject, D]])),
                    f.target.setPointerCapture(P)
                }
                  , A = P => {
                    const D = w.capturedMap.get(P);
                    D && $E(w.capturedMap, x.eventObject, D, P)
                }
                ;
                let F = {};
                for (let P in f) {
                    let D = f[P];
                    typeof D != "function" && (F[P] = D)
                }
                let I = {
                    ...x,
                    ...F,
                    pointer: v,
                    intersections: u,
                    stopped: g.stopped,
                    delta: d,
                    unprojectedPoint: E,
                    ray: _.ray,
                    camera: M,
                    stopPropagation() {
                        const P = "pointerId"in f && w.capturedMap.get(f.pointerId);
                        if ((!P || P.has(x.eventObject)) && (I.stopped = g.stopped = !0,
                        w.hovered.size && Array.from(w.hovered.values()).find(D => D.eventObject === x.eventObject))) {
                            const D = u.slice(0, u.indexOf(x));
                            s([...D, x])
                        }
                    },
                    target: {
                        hasPointerCapture: O,
                        setPointerCapture: R,
                        releasePointerCapture: A
                    },
                    currentTarget: {
                        hasPointerCapture: O,
                        setPointerCapture: R,
                        releasePointerCapture: A
                    },
                    nativeEvent: f
                };
                if (h(I),
                g.stopped === !0)
                    break
            }
        }
        return u
    }
    function s(u) {
        const {internal: f} = n.getState();
        for (const d of f.hovered.values())
            if (!u.length || !u.find(h => h.object === d.object && h.index === d.index && h.instanceId === d.instanceId)) {
                const m = d.eventObject.__r3f
                  , g = m == null ? void 0 : m.handlers;
                if (f.hovered.delete(Zd(d)),
                m != null && m.eventCount) {
                    const x = {
                        ...d,
                        intersections: u
                    };
                    g.onPointerOut == null || g.onPointerOut(x),
                    g.onPointerLeave == null || g.onPointerLeave(x)
                }
            }
    }
    function o(u, f) {
        for (let d = 0; d < f.length; d++) {
            const h = f[d].__r3f;
            h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(u)
        }
    }
    function l(u) {
        switch (u) {
        case "onPointerLeave":
        case "onPointerCancel":
            return () => s([]);
        case "onLostPointerCapture":
            return f => {
                const {internal: d} = n.getState();
                "pointerId"in f && d.capturedMap.has(f.pointerId) && requestAnimationFrame( () => {
                    d.capturedMap.has(f.pointerId) && (d.capturedMap.delete(f.pointerId),
                    s([]))
                }
                )
            }
        }
        return function(d) {
            const {onPointerMissed: h, internal: m} = n.getState();
            m.lastEvent.current = d;
            const g = u === "onPointerMove"
              , x = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick"
              , _ = i(d, g ? t : void 0)
              , v = x ? e(d) : 0;
            u === "onPointerDown" && (m.initialClick = [d.offsetX, d.offsetY],
            m.initialHits = _.map(w => w.eventObject)),
            x && !_.length && v <= 2 && (o(d, m.interaction),
            h && h(d)),
            g && s(_);
            function M(w) {
                const E = w.eventObject
                  , O = E.__r3f
                  , R = O == null ? void 0 : O.handlers;
                if (O != null && O.eventCount)
                    if (g) {
                        if (R.onPointerOver || R.onPointerEnter || R.onPointerOut || R.onPointerLeave) {
                            const A = Zd(w)
                              , F = m.hovered.get(A);
                            F ? F.stopped && w.stopPropagation() : (m.hovered.set(A, w),
                            R.onPointerOver == null || R.onPointerOver(w),
                            R.onPointerEnter == null || R.onPointerEnter(w))
                        }
                        R.onPointerMove == null || R.onPointerMove(w)
                    } else {
                        const A = R[u];
                        A ? (!x || m.initialHits.includes(E)) && (o(d, m.interaction.filter(F => !m.initialHits.includes(F))),
                        A(w)) : x && m.initialHits.includes(E) && o(d, m.interaction.filter(F => !m.initialHits.includes(F)))
                    }
            }
            r(_, d, v, M)
        }
    }
    return {
        handlePointer: l
    }
}
const qE = n => !!(n != null && n.render)
  , YE = N.createContext(null)
  , NF = (n, e) => {
    const t = _F( (l, u) => {
        const f = new B
          , d = new B
          , h = new B;
        function m(v=u().camera, M=d, w=u().size) {
            const {width: E, height: O, top: R, left: A} = w
              , F = E / O;
            M instanceof B ? h.copy(M) : h.set(...M);
            const I = v.getWorldPosition(f).distanceTo(h);
            if (VE(v))
                return {
                    width: E / v.zoom,
                    height: O / v.zoom,
                    top: R,
                    left: A,
                    factor: 1,
                    distance: I,
                    aspect: F
                };
            {
                const P = v.fov * Math.PI / 180
                  , D = 2 * Math.tan(P / 2) * I
                  , W = D * (E / O);
                return {
                    width: W,
                    height: D,
                    top: R,
                    left: A,
                    factor: E / W,
                    distance: I,
                    aspect: F
                }
            }
        }
        let g;
        const x = v => l(M => ({
            performance: {
                ...M.performance,
                current: v
            }
        }))
          , S = new he;
        return {
            set: l,
            get: u,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            xr: null,
            scene: null,
            invalidate: (v=1) => n(u(), v),
            advance: (v, M) => e(v, M, u()),
            legacy: !1,
            linear: !1,
            flat: !1,
            controls: null,
            clock: new kx,
            pointer: S,
            mouse: S,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: () => {
                    const v = u();
                    g && clearTimeout(g),
                    v.performance.current !== v.performance.min && x(v.performance.min),
                    g = setTimeout( () => x(u().performance.max), v.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                updateStyle: !1
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: m
            },
            setEvents: v => l(M => ({
                ...M,
                events: {
                    ...M.events,
                    ...v
                }
            })),
            setSize: (v, M, w, E, O) => {
                const R = u().camera
                  , A = {
                    width: v,
                    height: M,
                    top: E || 0,
                    left: O || 0,
                    updateStyle: w
                };
                l(F => ({
                    size: A,
                    viewport: {
                        ...F.viewport,
                        ...m(R, d, A)
                    }
                }))
            }
            ,
            setDpr: v => l(M => {
                const w = jE(v);
                return {
                    viewport: {
                        ...M.viewport,
                        dpr: w,
                        initialDpr: M.viewport.initialDpr || w
                    }
                }
            }
            ),
            setFrameloop: (v="always") => {
                const M = u().clock;
                M.stop(),
                M.elapsedTime = 0,
                v !== "never" && (M.start(),
                M.elapsedTime = 0),
                l( () => ({
                    frameloop: v
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                active: !1,
                priority: 0,
                frames: 0,
                lastEvent: N.createRef(),
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                subscribe: (v, M, w) => {
                    const E = u().internal;
                    return E.priority = E.priority + (M > 0 ? 1 : 0),
                    E.subscribers.push({
                        ref: v,
                        priority: M,
                        store: w
                    }),
                    E.subscribers = E.subscribers.sort( (O, R) => O.priority - R.priority),
                    () => {
                        const O = u().internal;
                        O != null && O.subscribers && (O.priority = O.priority - (M > 0 ? 1 : 0),
                        O.subscribers = O.subscribers.filter(R => R.ref !== v))
                    }
                }
            }
        }
    }
    )
      , i = t.getState();
    let r = i.size
      , s = i.viewport.dpr
      , o = i.camera;
    return t.subscribe( () => {
        const {camera: l, size: u, viewport: f, gl: d, set: h} = t.getState();
        if (u.width !== r.width || u.height !== r.height || f.dpr !== s) {
            var m;
            r = u,
            s = f.dpr,
            RF(l, u),
            d.setPixelRatio(f.dpr);
            const g = (m = u.updateStyle) != null ? m : typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement;
            d.setSize(u.width, u.height, g)
        }
        l !== o && (o = l,
        h(g => ({
            viewport: {
                ...g.viewport,
                ...g.viewport.getCurrentViewport(l)
            }
        })))
    }
    ),
    t.subscribe(l => n(l)),
    t
}
;
function OF(n, e) {
    const t = {
        callback: n
    };
    return e.add(t),
    () => void e.delete(t)
}
let Kd, ZE = new Set, DF = new Set, UF = new Set;
const FF = n => OF(n, ZE);
function qg(n, e) {
    if (n.size)
        for (const {callback: t} of n.values())
            t(e)
}
function vc(n, e) {
    switch (n) {
    case "before":
        return qg(ZE, e);
    case "after":
        return qg(DF, e);
    case "tail":
        return qg(UF, e)
    }
}
let Yg, Zg;
function Kg(n, e, t) {
    let i = e.clock.getDelta();
    for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = n),
    Yg = e.internal.subscribers,
    Kd = 0; Kd < Yg.length; Kd++)
        Zg = Yg[Kd],
        Zg.ref.current(Zg.store.getState(), i, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
function kF(n) {
    let e = !1, t = !1, i, r, s;
    function o(f) {
        r = requestAnimationFrame(o),
        e = !0,
        i = 0,
        vc("before", f),
        t = !0;
        for (const h of n.values()) {
            var d;
            s = h.store.getState(),
            s.internal.active && (s.frameloop === "always" || s.internal.frames > 0) && !((d = s.gl.xr) != null && d.isPresenting) && (i += Kg(f, s))
        }
        if (t = !1,
        vc("after", f),
        i === 0)
            return vc("tail", f),
            e = !1,
            cancelAnimationFrame(r)
    }
    function l(f, d=1) {
        var h;
        if (!f)
            return n.forEach(m => l(m.store.getState(), d));
        (h = f.gl.xr) != null && h.isPresenting || !f.internal.active || f.frameloop === "never" || (d > 1 ? f.internal.frames = Math.min(60, f.internal.frames + d) : t ? f.internal.frames = 2 : f.internal.frames = 1,
        e || (e = !0,
        requestAnimationFrame(o)))
    }
    function u(f, d=!0, h, m) {
        if (d && vc("before", f),
        h)
            Kg(f, h, m);
        else
            for (const g of n.values())
                Kg(f, g.store.getState());
        d && vc("after", f)
    }
    return {
        loop: o,
        invalidate: l,
        advance: u
    }
}
function KE() {
    const n = N.useContext(YE);
    if (!n)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return n
}
function Nr(n=t => t, e) {
    return KE()(n, e)
}
function Xu(n, e=0) {
    const t = KE()
      , i = t.getState().internal.subscribe
      , r = HE(n);
    return ju( () => i(r, e, t), [e, i, t]),
    null
}
const gl = new Map
  , {invalidate: IM, advance: LM} = kF(gl)
  , {reconciler: ap, applyProps: Eo} = wF(gl, PF)
  , za = {
    objects: "shallow",
    strict: !1
}
  , BF = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return qE(t) ? t : new zb({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...n
    })
}
;
function zF(n, e) {
    const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
    if (e) {
        const {width: i, height: r, top: s, left: o, updateStyle: l=t} = e;
        return {
            width: i,
            height: r,
            top: s,
            left: o,
            updateStyle: l
        }
    } else if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
        const {width: i, height: r, top: s, left: o} = n.parentElement.getBoundingClientRect();
        return {
            width: i,
            height: r,
            top: s,
            left: o,
            updateStyle: t
        }
    } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
        return {
            width: n.width,
            height: n.height,
            top: 0,
            left: 0,
            updateStyle: t
        };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}
function VF(n) {
    const e = gl.get(n)
      , t = e == null ? void 0 : e.fiber
      , i = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const r = typeof reportError == "function" ? reportError : console.error
      , s = i || NF(IM, LM)
      , o = t || ap.createContainer(s, Za.ConcurrentRoot, null, !1, null, "", r, null);
    e || gl.set(n, {
        fiber: o,
        store: s
    });
    let l, u = !1, f;
    return {
        configure(d={}) {
            let {gl: h, size: m, scene: g, events: x, onCreated: S, shadows: _=!1, linear: v=!1, flat: M=!1, legacy: w=!1, orthographic: E=!1, frameloop: O="always", dpr: R=[1, 2], performance: A, raycaster: F, camera: I, onPointerMissed: P} = d
              , D = s.getState()
              , W = D.gl;
            D.gl || D.set({
                gl: W = BF(h, n)
            });
            let X = D.raycaster;
            X || D.set({
                raycaster: X = new NE
            });
            const {params: G, ...q} = F || {};
            if (Yt.equ(q, X, za) || Eo(X, {
                ...q
            }),
            Yt.equ(G, X.params, za) || Eo(X, {
                params: {
                    ...X.params,
                    ...G
                }
            }),
            !D.camera || D.camera === f && !Yt.equ(f, I, za)) {
                f = I;
                const Q = I instanceof Uu
                  , ce = Q ? I : E ? new qo(0,0,0,0,.1,1e3) : new yn(75,0,.1,1e3);
                Q || (ce.position.z = 5,
                I && (Eo(ce, I),
                ("aspect"in I || "left"in I || "right"in I || "bottom"in I || "top"in I) && (ce.manual = !0,
                ce.updateProjectionMatrix())),
                !D.camera && !(I != null && I.rotation) && ce.lookAt(0, 0, 0)),
                D.set({
                    camera: ce
                }),
                X.camera = ce
            }
            if (!D.scene) {
                let Q;
                g instanceof ip ? Q = g : (Q = new ip,
                g && Eo(Q, g)),
                D.set({
                    scene: Ga(Q)
                })
            }
            if (!D.xr) {
                var K;
                const Q = (Ue, se) => {
                    const ue = s.getState();
                    ue.frameloop !== "never" && LM(Ue, !0, ue, se)
                }
                  , ce = () => {
                    const Ue = s.getState();
                    Ue.gl.xr.enabled = Ue.gl.xr.isPresenting,
                    Ue.gl.xr.setAnimationLoop(Ue.gl.xr.isPresenting ? Q : null),
                    Ue.gl.xr.isPresenting || IM(Ue)
                }
                  , be = {
                    connect() {
                        const Ue = s.getState().gl;
                        Ue.xr.addEventListener("sessionstart", ce),
                        Ue.xr.addEventListener("sessionend", ce)
                    },
                    disconnect() {
                        const Ue = s.getState().gl;
                        Ue.xr.removeEventListener("sessionstart", ce),
                        Ue.xr.removeEventListener("sessionend", ce)
                    }
                };
                typeof ((K = W.xr) == null ? void 0 : K.addEventListener) == "function" && be.connect(),
                D.set({
                    xr: be
                })
            }
            if (W.shadowMap) {
                const Q = W.shadowMap.enabled
                  , ce = W.shadowMap.type;
                if (W.shadowMap.enabled = !!_,
                Yt.boo(_))
                    W.shadowMap.type = Rc;
                else if (Yt.str(_)) {
                    var oe;
                    const be = {
                        basic: Lw,
                        percentage: Wp,
                        soft: Rc,
                        variance: sr
                    };
                    W.shadowMap.type = (oe = be[_]) != null ? oe : Rc
                } else
                    Yt.obj(_) && Object.assign(W.shadowMap, _);
                (Q !== W.shadowMap.enabled || ce !== W.shadowMap.type) && (W.shadowMap.needsUpdate = !0)
            }
            const z = zE();
            z && ("enabled"in z ? z.enabled = !w : "legacyMode"in z && (z.legacyMode = w)),
            u || Eo(W, {
                outputEncoding: v ? 3e3 : 3001,
                toneMapping: M ? Pr : Jv
            }),
            D.legacy !== w && D.set( () => ({
                legacy: w
            })),
            D.linear !== v && D.set( () => ({
                linear: v
            })),
            D.flat !== M && D.set( () => ({
                flat: M
            })),
            h && !Yt.fun(h) && !qE(h) && !Yt.equ(h, W, za) && Eo(W, h),
            x && !D.events.handlers && D.set({
                events: x(s)
            });
            const ee = zF(n, m);
            return Yt.equ(ee, D.size, za) || D.setSize(ee.width, ee.height, ee.updateStyle, ee.top, ee.left),
            R && D.viewport.dpr !== jE(R) && D.setDpr(R),
            D.frameloop !== O && D.setFrameloop(O),
            D.onPointerMissed || D.set({
                onPointerMissed: P
            }),
            A && !Yt.equ(A, D.performance, za) && D.set(Q => ({
                performance: {
                    ...Q.performance,
                    ...A
                }
            })),
            l = S,
            u = !0,
            this
        },
        render(d) {
            return u || this.configure(),
            ap.updateContainer(T.jsx(HF, {
                store: s,
                children: d,
                onCreated: l,
                rootElement: n
            }), o, null, () => {}
            ),
            s
        },
        unmount() {
            JE(n)
        }
    }
}
function HF({store: n, children: e, onCreated: t, rootElement: i}) {
    return ju( () => {
        const r = n.getState();
        r.set(s => ({
            internal: {
                ...s.internal,
                active: !0
            }
        })),
        t && t(r),
        n.getState().events.connected || r.events.connect == null || r.events.connect(i)
    }
    , []),
    T.jsx(YE.Provider, {
        value: n,
        children: e
    })
}
function JE(n, e) {
    const t = gl.get(n)
      , i = t == null ? void 0 : t.fiber;
    if (i) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1),
        ap.updateContainer(null, i, null, () => {
            r && setTimeout( () => {
                try {
                    var s, o, l, u;
                    r.events.disconnect == null || r.events.disconnect(),
                    (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(),
                    (l = r.gl) == null || l.forceContextLoss == null || l.forceContextLoss(),
                    (u = r.gl) != null && u.xr && r.xr.disconnect(),
                    TF(r),
                    gl.delete(n)
                } catch {}
            }
            , 500)
        }
        )
    }
}
ap.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: N.version
});
function q1(n, e, t) {
    var i, r, s, o, l;
    e == null && (e = 100);
    function u() {
        var d = Date.now() - o;
        d < e && d >= 0 ? i = setTimeout(u, e - d) : (i = null,
        t || (l = n.apply(s, r),
        s = r = null))
    }
    var f = function() {
        s = this,
        r = arguments,
        o = Date.now();
        var d = t && !i;
        return i || (i = setTimeout(u, e)),
        d && (l = n.apply(s, r),
        s = r = null),
        l
    };
    return f.clear = function() {
        i && (clearTimeout(i),
        i = null)
    }
    ,
    f.flush = function() {
        i && (l = n.apply(s, r),
        s = r = null,
        clearTimeout(i),
        i = null)
    }
    ,
    f
}
q1.debounce = q1;
var GF = q1;
const NM = s3(GF);
function WF(n) {
    let {debounce: e, scroll: t, polyfill: i, offsetSize: r} = n === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : n;
    const s = i || (typeof window > "u" ? class {
    }
    : window.ResizeObserver);
    if (!s)
        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o,l] = N.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    })
      , u = N.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    })
      , f = e ? typeof e == "number" ? e : e.scroll : null
      , d = e ? typeof e == "number" ? e : e.resize : null
      , h = N.useRef(!1);
    N.useEffect( () => (h.current = !0,
    () => void (h.current = !1)));
    const [m,g,x] = N.useMemo( () => {
        const M = () => {
            if (!u.current.element)
                return;
            const {left: w, top: E, width: O, height: R, bottom: A, right: F, x: I, y: P} = u.current.element.getBoundingClientRect()
              , D = {
                left: w,
                top: E,
                width: O,
                height: R,
                bottom: A,
                right: F,
                x: I,
                y: P
            };
            u.current.element instanceof HTMLElement && r && (D.height = u.current.element.offsetHeight,
            D.width = u.current.element.offsetWidth),
            Object.freeze(D),
            h.current && !qF(u.current.lastBounds, D) && l(u.current.lastBounds = D)
        }
        ;
        return [M, d ? NM(M, d) : M, f ? NM(M, f) : M]
    }
    , [l, r, f, d]);
    function S() {
        u.current.scrollContainers && (u.current.scrollContainers.forEach(M => M.removeEventListener("scroll", x, !0)),
        u.current.scrollContainers = null),
        u.current.resizeObserver && (u.current.resizeObserver.disconnect(),
        u.current.resizeObserver = null)
    }
    function _() {
        u.current.element && (u.current.resizeObserver = new s(x),
        u.current.resizeObserver.observe(u.current.element),
        t && u.current.scrollContainers && u.current.scrollContainers.forEach(M => M.addEventListener("scroll", x, {
            capture: !0,
            passive: !0
        })))
    }
    const v = M => {
        !M || M === u.current.element || (S(),
        u.current.element = M,
        u.current.scrollContainers = QE(M),
        _())
    }
    ;
    return XF(x, !!t),
    jF(g),
    N.useEffect( () => {
        S(),
        _()
    }
    , [t, x, g]),
    N.useEffect( () => S, []),
    [v, o, m]
}
function jF(n) {
    N.useEffect( () => {
        const e = n;
        return window.addEventListener("resize", e),
        () => void window.removeEventListener("resize", e)
    }
    , [n])
}
function XF(n, e) {
    N.useEffect( () => {
        if (e) {
            const t = n;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }),
            () => void window.removeEventListener("scroll", t, !0)
        }
    }
    , [n, e])
}
function QE(n) {
    const e = [];
    if (!n || n === document.body)
        return e;
    const {overflow: t, overflowX: i, overflowY: r} = window.getComputedStyle(n);
    return [t, i, r].some(s => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...QE(n.parentElement)]
}
const $F = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , qF = (n, e) => $F.every(t => n[t] === e[t]);
var YF = Object.defineProperty, ZF = Object.defineProperties, KF = Object.getOwnPropertyDescriptors, OM = Object.getOwnPropertySymbols, JF = Object.prototype.hasOwnProperty, QF = Object.prototype.propertyIsEnumerable, DM = (n, e, t) => e in n ? YF(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t, UM = (n, e) => {
    for (var t in e || (e = {}))
        JF.call(e, t) && DM(n, t, e[t]);
    if (OM)
        for (var t of OM(e))
            QF.call(e, t) && DM(n, t, e[t]);
    return n
}
, ek = (n, e) => ZF(n, KF(e)), FM, kM;
typeof window < "u" && ((FM = window.document) != null && FM.createElement || ((kM = window.navigator) == null ? void 0 : kM.product) === "ReactNative") ? N.useLayoutEffect : N.useEffect;
function eC(n, e, t) {
    if (!n)
        return;
    if (t(n) === !0)
        return n;
    let i = n.child;
    for (; i; ) {
        const r = eC(i, e, t);
        if (r)
            return r;
        i = i.sibling
    }
}
function tC(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return n
    }
}
const BM = console.error;
console.error = function() {
    const n = [...arguments].join("");
    if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
        console.error = BM;
        return
    }
    return BM.apply(this, arguments)
}
;
const Gx = tC(N.createContext(null));
class nC extends N.Component {
    render() {
        return N.createElement(Gx.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
function tk() {
    const n = N.useContext(Gx);
    if (n === null)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = N.useId();
    return N.useMemo( () => {
        for (const i of [n, n == null ? void 0 : n.alternate]) {
            if (!i)
                continue;
            const r = eC(i, !1, s => {
                let o = s.memoizedState;
                for (; o; ) {
                    if (o.memoizedState === e)
                        return !0;
                    o = o.next
                }
            }
            );
            if (r)
                return r
        }
    }
    , [n, e])
}
function nk() {
    const n = tk()
      , [e] = N.useState( () => new Map);
    e.clear();
    let t = n;
    for (; t; ) {
        if (t.type && typeof t.type == "object") {
            const r = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
            r && r !== Gx && !e.has(r) && e.set(r, N.useContext(tC(r)))
        }
        t = t.return
    }
    return e
}
function ik() {
    const n = nk();
    return N.useMemo( () => Array.from(n.keys()).reduce( (e, t) => i => N.createElement(e, null, N.createElement(t.Provider, ek(UM({}, i), {
        value: n.get(t)
    }))), e => N.createElement(nC, UM({}, e))), [n])
}
const Jg = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function rk(n) {
    const {handlePointer: e} = LF(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, i, r) {
            i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1),
            i.raycaster.setFromCamera(i.pointer, i.camera)
        },
        connected: void 0,
        handlers: Object.keys(Jg).reduce( (t, i) => ({
            ...t,
            [i]: e(i)
        }), {}),
        update: () => {
            var t;
            const {events: i, internal: r} = n.getState();
            (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current)
        }
        ,
        connect: t => {
            var i;
            const {set: r, events: s} = n.getState();
            s.disconnect == null || s.disconnect(),
            r(o => ({
                events: {
                    ...o.events,
                    connected: t
                }
            })),
            Object.entries((i = s.handlers) != null ? i : []).forEach( ([o,l]) => {
                const [u,f] = Jg[o];
                t.addEventListener(u, l, {
                    passive: f
                })
            }
            )
        }
        ,
        disconnect: () => {
            const {set: t, events: i} = n.getState();
            if (i.connected) {
                var r;
                Object.entries((r = i.handlers) != null ? r : []).forEach( ([s,o]) => {
                    if (i && i.connected instanceof HTMLElement) {
                        const [l] = Jg[s];
                        i.connected.removeEventListener(l, o)
                    }
                }
                ),
                t(s => ({
                    events: {
                        ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const sk = N.forwardRef(function({children: e, fallback: t, resize: i, style: r, gl: s, events: o=rk, eventSource: l, eventPrefix: u, shadows: f, linear: d, flat: h, legacy: m, orthographic: g, frameloop: x, dpr: S, performance: _, raycaster: v, camera: M, scene: w, onPointerMissed: E, onCreated: O, ...R}, A) {
    N.useMemo( () => Wu(DE), []);
    const F = ik()
      , [I,P] = WF({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...i
    })
      , D = N.useRef(null)
      , W = N.useRef(null);
    N.useImperativeHandle(A, () => D.current);
    const X = HE(E)
      , [G,q] = N.useState(!1)
      , [K,oe] = N.useState(!1);
    if (G)
        throw G;
    if (K)
        throw K;
    const z = N.useRef(null);
    ju( () => {
        const Q = D.current;
        P.width > 0 && P.height > 0 && Q && (z.current || (z.current = VF(Q)),
        z.current.configure({
            gl: s,
            events: o,
            shadows: f,
            linear: d,
            flat: h,
            legacy: m,
            orthographic: g,
            frameloop: x,
            dpr: S,
            performance: _,
            raycaster: v,
            camera: M,
            scene: w,
            size: P,
            onPointerMissed: (...ce) => X.current == null ? void 0 : X.current(...ce),
            onCreated: ce => {
                ce.events.connect == null || ce.events.connect(l ? bF(l) ? l.current : l : W.current),
                u && ce.setEvents({
                    compute: (be, Ue) => {
                        const se = be[u + "X"]
                          , ue = be[u + "Y"];
                        Ue.pointer.set(se / Ue.size.width * 2 - 1, -(ue / Ue.size.height) * 2 + 1),
                        Ue.raycaster.setFromCamera(Ue.pointer, Ue.camera)
                    }
                }),
                O == null || O(ce)
            }
        }),
        z.current.render(T.jsx(F, {
            children: T.jsx(GE, {
                set: oe,
                children: T.jsx(N.Suspense, {
                    fallback: T.jsx(EF, {
                        set: q
                    }),
                    children: e
                })
            })
        })))
    }
    ),
    N.useEffect( () => {
        const Q = D.current;
        if (Q)
            return () => JE(Q)
    }
    , []);
    const ee = l ? "none" : "auto";
    return T.jsx("div", {
        ref: W,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: ee,
            ...r
        },
        ...R,
        children: T.jsx("div", {
            ref: I,
            style: {
                width: "100%",
                height: "100%"
            },
            children: T.jsx("canvas", {
                ref: D,
                style: {
                    display: "block"
                },
                children: t
            })
        })
    })
})
  , ok = N.forwardRef(function(e, t) {
    return T.jsx(nC, {
        children: T.jsx(sk, {
            ...e,
            ref: t
        })
    })
})
  , $u = new B
  , Wx = new B
  , ak = new B
  , zM = new he;
function lk(n, e, t) {
    const i = $u.setFromMatrixPosition(n.matrixWorld);
    i.project(e);
    const r = t.width / 2
      , s = t.height / 2;
    return [i.x * r + r, -(i.y * s) + s]
}
function ck(n, e) {
    const t = $u.setFromMatrixPosition(n.matrixWorld)
      , i = Wx.setFromMatrixPosition(e.matrixWorld)
      , r = t.sub(i)
      , s = e.getWorldDirection(ak);
    return r.angleTo(s) > Math.PI / 2
}
function uk(n, e, t, i) {
    const r = $u.setFromMatrixPosition(n.matrixWorld)
      , s = r.clone();
    s.project(e),
    zM.set(s.x, s.y),
    t.setFromCamera(zM, e);
    const o = t.intersectObjects(i, !0);
    if (o.length) {
        const l = o[0].distance;
        return r.distanceTo(t.ray.origin) < l
    }
    return !0
}
function fk(n, e) {
    if (e instanceof qo)
        return e.zoom;
    if (e instanceof yn) {
        const t = $u.setFromMatrixPosition(n.matrixWorld)
          , i = Wx.setFromMatrixPosition(e.matrixWorld)
          , r = e.fov * Math.PI / 180
          , s = t.distanceTo(i);
        return 1 / (2 * Math.tan(r / 2) * s)
    } else
        return 1
}
function dk(n, e, t) {
    if (e instanceof yn || e instanceof qo) {
        const i = $u.setFromMatrixPosition(n.matrixWorld)
          , r = Wx.setFromMatrixPosition(e.matrixWorld)
          , s = i.distanceTo(r)
          , o = (t[1] - t[0]) / (e.far - e.near)
          , l = t[1] - o * e.far;
        return Math.round(o * s + l)
    }
}
const Y1 = n => Math.abs(n) < 1e-10 ? 0 : n;
function iC(n, e, t="") {
    let i = "matrix3d(";
    for (let r = 0; r !== 16; r++)
        i += Y1(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
    return t + i
}
const hk = (n => e => iC(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1])
  , pk = (n => (e, t) => iC(e, n(t), "translate(-50%,-50%)"))(n => [1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]);
function mk(n) {
    return n && typeof n == "object" && "current"in n
}
const rC = N.forwardRef( ({children: n, eps: e=.001, style: t, className: i, prepend: r, center: s, fullscreen: o, portal: l, distanceFactor: u, sprite: f=!1, transform: d=!1, occlude: h, onOcclude: m, castShadow: g, receiveShadow: x, material: S, geometry: _, zIndexRange: v=[16777271, 0], calculatePosition: M=lk, as: w="div", wrapperClass: E, pointerEvents: O="auto", ...R}, A) => {
    const {gl: F, camera: I, scene: P, size: D, raycaster: W, events: X, viewport: G} = Nr()
      , [q] = N.useState( () => document.createElement(w))
      , K = N.useRef()
      , oe = N.useRef(null)
      , z = N.useRef(0)
      , ee = N.useRef([0, 0])
      , Q = N.useRef(null)
      , ce = N.useRef(null)
      , be = (l == null ? void 0 : l.current) || X.connected || F.domElement.parentNode
      , Ue = N.useRef(null)
      , se = N.useRef(!1)
      , ue = N.useMemo( () => h && h !== "blending" || Array.isArray(h) && h.length && mk(h[0]), [h]);
    N.useLayoutEffect( () => {
        const ze = F.domElement;
        h && h === "blending" ? (ze.style.zIndex = `${Math.floor(v[0] / 2)}`,
        ze.style.position = "absolute",
        ze.style.pointerEvents = "none") : (ze.style.zIndex = null,
        ze.style.position = null,
        ze.style.pointerEvents = null)
    }
    , [h]),
    N.useLayoutEffect( () => {
        if (oe.current) {
            const ze = K.current = R5(q);
            if (P.updateMatrixWorld(),
            d)
                q.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
                const ke = M(oe.current, I, D);
                q.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${ke[0]}px,${ke[1]}px,0);transform-origin:0 0;`
            }
            return be && (r ? be.prepend(q) : be.appendChild(q)),
            () => {
                be && be.removeChild(q),
                ze.unmount()
            }
        }
    }
    , [be, d]),
    N.useLayoutEffect( () => {
        E && (q.className = E)
    }
    , [E]);
    const Te = N.useMemo( () => d ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: D.width,
        height: D.height,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
    } : {
        position: "absolute",
        transform: s ? "translate3d(-50%,-50%,0)" : "none",
        ...o && {
            top: -D.height / 2,
            left: -D.width / 2,
            width: D.width,
            height: D.height
        },
        ...t
    }, [t, s, o, D, d])
      , Me = N.useMemo( () => ({
        position: "absolute",
        pointerEvents: O
    }), [O]);
    N.useLayoutEffect( () => {
        if (se.current = !1,
        d) {
            var ze;
            (ze = K.current) == null || ze.render(N.createElement("div", {
                ref: Q,
                style: Te
            }, N.createElement("div", {
                ref: ce,
                style: Me
            }, N.createElement("div", {
                ref: A,
                className: i,
                style: t,
                children: n
            }))))
        } else {
            var ke;
            (ke = K.current) == null || ke.render(N.createElement("div", {
                ref: A,
                style: Te,
                className: i,
                children: n
            }))
        }
    }
    );
    const Ye = N.useRef(!0);
    Xu(ze => {
        if (oe.current) {
            I.updateMatrixWorld(),
            oe.current.updateWorldMatrix(!0, !1);
            const ke = d ? ee.current : M(oe.current, I, D);
            if (d || Math.abs(z.current - I.zoom) > e || Math.abs(ee.current[0] - ke[0]) > e || Math.abs(ee.current[1] - ke[1]) > e) {
                const k = ck(oe.current, I);
                let pe = !1;
                ue && (Array.isArray(h) ? pe = h.map($e => $e.current) : h !== "blending" && (pe = [P]));
                const ye = Ye.current;
                if (pe) {
                    const $e = uk(oe.current, I, W, pe);
                    Ye.current = $e && !k
                } else
                    Ye.current = !k;
                ye !== Ye.current && (m ? m(!Ye.current) : q.style.display = Ye.current ? "block" : "none");
                const Pe = Math.floor(v[0] / 2)
                  , fe = h ? ue ? [v[0], Pe] : [Pe - 1, 0] : v;
                if (q.style.zIndex = `${dk(oe.current, I, fe)}`,
                d) {
                    const [$e,Le] = [D.width / 2, D.height / 2]
                      , Be = I.projectionMatrix.elements[5] * Le
                      , {isOrthographicCamera: H, top: L, left: te, bottom: _e, right: ge} = I
                      , ve = hk(I.matrixWorldInverse)
                      , Ke = H ? `scale(${Be})translate(${Y1(-(ge + te) / 2)}px,${Y1((L + _e) / 2)}px)` : `translateZ(${Be}px)`;
                    let we = oe.current.matrixWorld;
                    f && (we = I.matrixWorldInverse.clone().transpose().copyPosition(we).scale(oe.current.scale),
                    we.elements[3] = we.elements[7] = we.elements[11] = 0,
                    we.elements[15] = 1),
                    q.style.width = D.width + "px",
                    q.style.height = D.height + "px",
                    q.style.perspective = H ? "" : `${Be}px`,
                    Q.current && ce.current && (Q.current.style.transform = `${Ke}${ve}translate(${$e}px,${Le}px)`,
                    ce.current.style.transform = pk(we, 1 / ((u || 10) / 400)))
                } else {
                    const $e = u === void 0 ? 1 : fk(oe.current, I) * u;
                    q.style.transform = `translate3d(${ke[0]}px,${ke[1]}px,0) scale(${$e})`
                }
                ee.current = ke,
                z.current = I.zoom
            }
        }
        if (!ue && Ue.current && !se.current)
            if (d) {
                if (Q.current) {
                    const ke = Q.current.children[0];
                    if (ke != null && ke.clientWidth && ke != null && ke.clientHeight) {
                        const {isOrthographicCamera: k} = I;
                        if (k || _)
                            R.scale && (Array.isArray(R.scale) ? R.scale instanceof B ? Ue.current.scale.copy(R.scale.clone().divideScalar(1)) : Ue.current.scale.set(1 / R.scale[0], 1 / R.scale[1], 1 / R.scale[2]) : Ue.current.scale.setScalar(1 / R.scale));
                        else {
                            const pe = (u || 10) / 400
                              , ye = ke.clientWidth * pe
                              , Pe = ke.clientHeight * pe;
                            Ue.current.scale.set(ye, Pe, 1)
                        }
                        se.current = !0
                    }
                }
            } else {
                const ke = q.children[0];
                if (ke != null && ke.clientWidth && ke != null && ke.clientHeight) {
                    const k = 1 / G.factor
                      , pe = ke.clientWidth * k
                      , ye = ke.clientHeight * k;
                    Ue.current.scale.set(pe, ye, 1),
                    se.current = !0
                }
                Ue.current.lookAt(ze.camera.position)
            }
    }
    );
    const Qe = N.useMemo( () => ({
        vertexShader: d ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    }), [d]);
    return N.createElement("group", ol({}, R, {
        ref: oe
    }), h && !ue && N.createElement("mesh", {
        castShadow: g,
        receiveShadow: x,
        ref: Ue
    }, _ || N.createElement("planeGeometry", null), S || N.createElement("shaderMaterial", {
        side: lr,
        vertexShader: Qe.vertexShader,
        fragmentShader: Qe.fragmentShader
    })))
}
);
let jx = Yu();
const At = n => qu(n, jx);
let Xx = Yu();
At.write = n => qu(n, Xx);
let wm = Yu();
At.onStart = n => qu(n, wm);
let $x = Yu();
At.onFrame = n => qu(n, $x);
let qx = Yu();
At.onFinish = n => qu(n, qx);
let il = [];
At.setTimeout = (n, e) => {
    let t = At.now() + e
      , i = () => {
        let s = il.findIndex(o => o.cancel == i);
        ~s && il.splice(s, 1),
        Fs -= ~s ? 1 : 0
    }
      , r = {
        time: t,
        handler: n,
        cancel: i
    };
    return il.splice(sC(t), 0, r),
    Fs += 1,
    oC(),
    r
}
;
let sC = n => ~(~il.findIndex(e => e.time > n) || ~il.length);
At.cancel = n => {
    wm.delete(n),
    $x.delete(n),
    qx.delete(n),
    jx.delete(n),
    Xx.delete(n)
}
;
At.sync = n => {
    Z1 = !0,
    At.batchedUpdates(n),
    Z1 = !1
}
;
At.throttle = n => {
    let e;
    function t() {
        try {
            n(...e)
        } finally {
            e = null
        }
    }
    function i(...r) {
        e = r,
        At.onStart(t)
    }
    return i.handler = n,
    i.cancel = () => {
        wm.delete(t),
        e = null
    }
    ,
    i
}
;
let Yx = typeof window < "u" ? window.requestAnimationFrame : () => {}
;
At.use = n => Yx = n;
At.now = typeof performance < "u" ? () => performance.now() : Date.now;
At.batchedUpdates = n => n();
At.catch = console.error;
At.frameLoop = "always";
At.advance = () => {
    At.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : lC()
}
;
let Us = -1
  , Fs = 0
  , Z1 = !1;
function qu(n, e) {
    Z1 ? (e.delete(n),
    n(0)) : (e.add(n),
    oC())
}
function oC() {
    Us < 0 && (Us = 0,
    At.frameLoop !== "demand" && Yx(aC))
}
function gk() {
    Us = -1
}
function aC() {
    ~Us && (Yx(aC),
    At.batchedUpdates(lC))
}
function lC() {
    let n = Us;
    Us = At.now();
    let e = sC(Us);
    if (e && (cC(il.splice(0, e), t => t.handler()),
    Fs -= e),
    !Fs) {
        gk();
        return
    }
    wm.flush(),
    jx.flush(n ? Math.min(64, Us - n) : 16.667),
    $x.flush(),
    Xx.flush(),
    qx.flush()
}
function Yu() {
    let n = new Set
      , e = n;
    return {
        add(t) {
            Fs += e == n && !n.has(t) ? 1 : 0,
            n.add(t)
        },
        delete(t) {
            return Fs -= e == n && n.has(t) ? 1 : 0,
            n.delete(t)
        },
        flush(t) {
            e.size && (n = new Set,
            Fs -= e.size,
            cC(e, i => i(t) && n.add(i)),
            Fs += n.size,
            e = n)
        }
    }
}
function cC(n, e) {
    n.forEach(t => {
        try {
            e(t)
        } catch (i) {
            At.catch(i)
        }
    }
    )
}
function vk() {}
const xk = (n, e, t) => Object.defineProperty(n, e, {
    value: t,
    writable: !0,
    configurable: !0
})
  , cn = {
    arr: Array.isArray,
    obj: n => !!n && n.constructor.name === "Object",
    fun: n => typeof n == "function",
    str: n => typeof n == "string",
    num: n => typeof n == "number",
    und: n => n === void 0
};
function _k(n, e) {
    if (cn.arr(n)) {
        if (!cn.arr(e) || n.length !== e.length)
            return !1;
        for (let t = 0; t < n.length; t++)
            if (n[t] !== e[t])
                return !1;
        return !0
    }
    return n === e
}
const rs = (n, e) => n.forEach(e);
function K1(n, e, t) {
    if (cn.arr(n)) {
        for (let i = 0; i < n.length; i++)
            e.call(t, n[i], `${i}`);
        return
    }
    for (const i in n)
        n.hasOwnProperty(i) && e.call(t, n[i], i)
}
const Jd = n => cn.und(n) ? [] : cn.arr(n) ? n : [n]
  , Zx = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
let Kx, uC, Vs = null, fC = !1, Jx = vk;
const yk = n => {
    n.to && (uC = n.to),
    n.now && (At.now = n.now),
    n.colors !== void 0 && (Vs = n.colors),
    n.skipAnimation != null && (fC = n.skipAnimation),
    n.createStringInterpolator && (Kx = n.createStringInterpolator),
    n.requestAnimationFrame && At.use(n.requestAnimationFrame),
    n.batchedUpdates && (At.batchedUpdates = n.batchedUpdates),
    n.willAdvance && (Jx = n.willAdvance),
    n.frameLoop && (At.frameLoop = n.frameLoop)
}
;
var yu = Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
        return Kx
    },
    get to() {
        return uC
    },
    get colors() {
        return Vs
    },
    get skipAnimation() {
        return fC
    },
    get willAdvance() {
        return Jx
    },
    assign: yk
});
const Bc = new Set;
let ji = []
  , Qg = []
  , lp = 0;
const Qx = {
    get idle() {
        return !Bc.size && !ji.length
    },
    start(n) {
        lp > n.priority ? (Bc.add(n),
        At.onStart(Sk)) : (dC(n),
        At(J1))
    },
    advance: J1,
    sort(n) {
        if (lp)
            At.onFrame( () => Qx.sort(n));
        else {
            const e = ji.indexOf(n);
            ~e && (ji.splice(e, 1),
            hC(n))
        }
    },
    clear() {
        ji = [],
        Bc.clear()
    }
};
function Sk() {
    Bc.forEach(dC),
    Bc.clear(),
    At(J1)
}
function dC(n) {
    ji.includes(n) || hC(n)
}
function hC(n) {
    ji.splice(Mk(ji, e => e.priority > n.priority), 0, n)
}
function J1(n) {
    const e = Qg;
    for (let t = 0; t < ji.length; t++) {
        const i = ji[t];
        lp = i.priority,
        i.idle || (Jx(i),
        i.advance(n),
        i.idle || e.push(i))
    }
    return lp = 0,
    Qg = ji,
    Qg.length = 0,
    ji = e,
    ji.length > 0
}
function Mk(n, e) {
    const t = n.findIndex(e);
    return t < 0 ? n.length : t
}
const wk = (n, e, t) => Math.min(Math.max(t, n), e)
  , bk = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
}
  , ur = "[-+]?\\d*\\.?\\d+"
  , cp = ur + "%";
function bm(...n) {
    return "\\(\\s*(" + n.join(")\\s*,\\s*(") + ")\\s*\\)"
}
const Ek = new RegExp("rgb" + bm(ur, ur, ur))
  , Ck = new RegExp("rgba" + bm(ur, ur, ur, ur))
  , Tk = new RegExp("hsl" + bm(ur, cp, cp))
  , Ak = new RegExp("hsla" + bm(ur, cp, cp, ur))
  , Rk = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/
  , Pk = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/
  , Ik = /^#([0-9a-fA-F]{6})$/
  , Lk = /^#([0-9a-fA-F]{8})$/;
function Nk(n) {
    let e;
    return typeof n == "number" ? n >>> 0 === n && n >= 0 && n <= 4294967295 ? n : null : (e = Ik.exec(n)) ? parseInt(e[1] + "ff", 16) >>> 0 : Vs && Vs[n] !== void 0 ? Vs[n] : (e = Ek.exec(n)) ? (Va(e[1]) << 24 | Va(e[2]) << 16 | Va(e[3]) << 8 | 255) >>> 0 : (e = Ck.exec(n)) ? (Va(e[1]) << 24 | Va(e[2]) << 16 | Va(e[3]) << 8 | GM(e[4])) >>> 0 : (e = Rk.exec(n)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = Lk.exec(n)) ? parseInt(e[1], 16) >>> 0 : (e = Pk.exec(n)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = Tk.exec(n)) ? (VM(HM(e[1]), Qd(e[2]), Qd(e[3])) | 255) >>> 0 : (e = Ak.exec(n)) ? (VM(HM(e[1]), Qd(e[2]), Qd(e[3])) | GM(e[4])) >>> 0 : null
}
function e1(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n
}
function VM(n, e, t) {
    const i = t < .5 ? t * (1 + e) : t + e - t * e
      , r = 2 * t - i
      , s = e1(r, i, n + 1 / 3)
      , o = e1(r, i, n)
      , l = e1(r, i, n - 1 / 3);
    return Math.round(s * 255) << 24 | Math.round(o * 255) << 16 | Math.round(l * 255) << 8
}
function Va(n) {
    const e = parseInt(n, 10);
    return e < 0 ? 0 : e > 255 ? 255 : e
}
function HM(n) {
    return (parseFloat(n) % 360 + 360) % 360 / 360
}
function GM(n) {
    const e = parseFloat(n);
    return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255)
}
function Qd(n) {
    const e = parseFloat(n);
    return e < 0 ? 0 : e > 100 ? 1 : e / 100
}
function WM(n) {
    let e = Nk(n);
    if (e === null)
        return n;
    e = e || 0;
    let t = (e & 4278190080) >>> 24
      , i = (e & 16711680) >>> 16
      , r = (e & 65280) >>> 8
      , s = (e & 255) / 255;
    return `rgba(${t}, ${i}, ${r}, ${s})`
}
const Su = (n, e, t) => {
    if (cn.fun(n))
        return n;
    if (cn.arr(n))
        return Su({
            range: n,
            output: e,
            extrapolate: t
        });
    if (cn.str(n.output[0]))
        return Kx(n);
    const i = n
      , r = i.output
      , s = i.range || [0, 1]
      , o = i.extrapolateLeft || i.extrapolate || "extend"
      , l = i.extrapolateRight || i.extrapolate || "extend"
      , u = i.easing || (f => f);
    return f => {
        const d = Dk(f, s);
        return Ok(f, s[d], s[d + 1], r[d], r[d + 1], u, o, l, i.map)
    }
}
;
function Ok(n, e, t, i, r, s, o, l, u) {
    let f = u ? u(n) : n;
    if (f < e) {
        if (o === "identity")
            return f;
        o === "clamp" && (f = e)
    }
    if (f > t) {
        if (l === "identity")
            return f;
        l === "clamp" && (f = t)
    }
    return i === r ? i : e === t ? n <= e ? i : r : (e === -1 / 0 ? f = -f : t === 1 / 0 ? f = f - e : f = (f - e) / (t - e),
    f = s(f),
    i === -1 / 0 ? f = -f : r === 1 / 0 ? f = f + i : f = f * (r - i) + i,
    f)
}
function Dk(n, e) {
    for (var t = 1; t < e.length - 1 && !(e[t] >= n); ++t)
        ;
    return t - 1
}
const Uk = (n, e="end") => t => {
    t = e === "end" ? Math.min(t, .999) : Math.max(t, .001);
    const i = t * n
      , r = e === "end" ? Math.floor(i) : Math.ceil(i);
    return wk(0, 1, r / n)
}
  , up = 1.70158
  , eh = up * 1.525
  , jM = up + 1
  , XM = 2 * Math.PI / 3
  , $M = 2 * Math.PI / 4.5
  , th = n => n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375
  , Fk = {
    linear: n => n,
    easeInQuad: n => n * n,
    easeOutQuad: n => 1 - (1 - n) * (1 - n),
    easeInOutQuad: n => n < .5 ? 2 * n * n : 1 - Math.pow(-2 * n + 2, 2) / 2,
    easeInCubic: n => n * n * n,
    easeOutCubic: n => 1 - Math.pow(1 - n, 3),
    easeInOutCubic: n => n < .5 ? 4 * n * n * n : 1 - Math.pow(-2 * n + 2, 3) / 2,
    easeInQuart: n => n * n * n * n,
    easeOutQuart: n => 1 - Math.pow(1 - n, 4),
    easeInOutQuart: n => n < .5 ? 8 * n * n * n * n : 1 - Math.pow(-2 * n + 2, 4) / 2,
    easeInQuint: n => n * n * n * n * n,
    easeOutQuint: n => 1 - Math.pow(1 - n, 5),
    easeInOutQuint: n => n < .5 ? 16 * n * n * n * n * n : 1 - Math.pow(-2 * n + 2, 5) / 2,
    easeInSine: n => 1 - Math.cos(n * Math.PI / 2),
    easeOutSine: n => Math.sin(n * Math.PI / 2),
    easeInOutSine: n => -(Math.cos(Math.PI * n) - 1) / 2,
    easeInExpo: n => n === 0 ? 0 : Math.pow(2, 10 * n - 10),
    easeOutExpo: n => n === 1 ? 1 : 1 - Math.pow(2, -10 * n),
    easeInOutExpo: n => n === 0 ? 0 : n === 1 ? 1 : n < .5 ? Math.pow(2, 20 * n - 10) / 2 : (2 - Math.pow(2, -20 * n + 10)) / 2,
    easeInCirc: n => 1 - Math.sqrt(1 - Math.pow(n, 2)),
    easeOutCirc: n => Math.sqrt(1 - Math.pow(n - 1, 2)),
    easeInOutCirc: n => n < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * n, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * n + 2, 2)) + 1) / 2,
    easeInBack: n => jM * n * n * n - up * n * n,
    easeOutBack: n => 1 + jM * Math.pow(n - 1, 3) + up * Math.pow(n - 1, 2),
    easeInOutBack: n => n < .5 ? Math.pow(2 * n, 2) * ((eh + 1) * 2 * n - eh) / 2 : (Math.pow(2 * n - 2, 2) * ((eh + 1) * (n * 2 - 2) + eh) + 2) / 2,
    easeInElastic: n => n === 0 ? 0 : n === 1 ? 1 : -Math.pow(2, 10 * n - 10) * Math.sin((n * 10 - 10.75) * XM),
    easeOutElastic: n => n === 0 ? 0 : n === 1 ? 1 : Math.pow(2, -10 * n) * Math.sin((n * 10 - .75) * XM) + 1,
    easeInOutElastic: n => n === 0 ? 0 : n === 1 ? 1 : n < .5 ? -(Math.pow(2, 20 * n - 10) * Math.sin((20 * n - 11.125) * $M)) / 2 : Math.pow(2, -20 * n + 10) * Math.sin((20 * n - 11.125) * $M) / 2 + 1,
    easeInBounce: n => 1 - th(1 - n),
    easeOutBounce: th,
    easeInOutBounce: n => n < .5 ? (1 - th(1 - 2 * n)) / 2 : (1 + th(2 * n - 1)) / 2,
    steps: Uk
};
function Q1() {
    return Q1 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    Q1.apply(this, arguments)
}
const vl = Symbol.for("FluidValue.get")
  , xl = Symbol.for("FluidValue.observers")
  , fp = n => !!(n && n[vl])
  , dp = n => n && n[vl] ? n[vl]() : n;
function kk(n, e) {
    n.eventObserved ? n.eventObserved(e) : n(e)
}
function ev(n, e) {
    let t = n[xl];
    t && t.forEach(i => {
        kk(i, e)
    }
    )
}
class Bk {
    constructor(e) {
        if (this[vl] = void 0,
        this[xl] = void 0,
        !e && !(e = this.get))
            throw Error("Unknown getter");
        zk(this, e)
    }
}
const zk = (n, e) => mC(n, vl, e);
function pC(n, e) {
    if (n[vl]) {
        let t = n[xl];
        t || mC(n, xl, t = new Set),
        t.has(e) || (t.add(e),
        n.observerAdded && n.observerAdded(t.size, e))
    }
    return e
}
function tv(n, e) {
    let t = n[xl];
    if (t && t.has(e)) {
        const i = t.size - 1;
        i ? t.delete(e) : n[xl] = null,
        n.observerRemoved && n.observerRemoved(i, e)
    }
}
const mC = (n, e, t) => Object.defineProperty(n, e, {
    value: t,
    writable: !0,
    configurable: !0
})
  , mh = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g
  , Vk = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi
  , qM = new RegExp(`(${mh.source})(%|[a-z]+)`,"i")
  , Hk = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi
  , Em = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/
  , gC = n => {
    const [e,t] = Gk(n);
    if (!e || Zx())
        return n;
    const i = window.getComputedStyle(document.documentElement).getPropertyValue(e);
    if (i)
        return i.trim();
    if (t && t.startsWith("--")) {
        const r = window.getComputedStyle(document.documentElement).getPropertyValue(t);
        return r || n
    } else {
        if (t && Em.test(t))
            return gC(t);
        if (t)
            return t
    }
    return n
}
  , Gk = n => {
    const e = Em.exec(n);
    if (!e)
        return [, ];
    const [,t,i] = e;
    return [t, i]
}
;
let t1;
const Wk = (n, e, t, i, r) => `rgba(${Math.round(e)}, ${Math.round(t)}, ${Math.round(i)}, ${r})`
  , vC = n => {
    t1 || (t1 = Vs ? new RegExp(`(${Object.keys(Vs).join("|")})(?!\\w)`,"g") : /^\b$/);
    const e = n.output.map(s => dp(s).replace(Em, gC).replace(Vk, WM).replace(t1, WM))
      , t = e.map(s => s.match(mh).map(Number))
      , r = t[0].map( (s, o) => t.map(l => {
        if (!(o in l))
            throw Error('The arity of each "output" value must be equal');
        return l[o]
    }
    )).map(s => Su(Q1({}, n, {
        output: s
    })));
    return s => {
        var o;
        const l = !qM.test(e[0]) && ((o = e.find(f => qM.test(f))) == null ? void 0 : o.replace(mh, ""));
        let u = 0;
        return e[0].replace(mh, () => `${r[u++](s)}${l || ""}`).replace(Hk, Wk)
    }
}
  , xC = "react-spring: "
  , _C = n => {
    const e = n;
    let t = !1;
    if (typeof e != "function")
        throw new TypeError(`${xC}once requires a function parameter`);
    return (...i) => {
        t || (e(...i),
        t = !0)
    }
}
  , jk = _C(console.warn);
function Xk() {
    jk(`${xC}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
_C(console.warn);
function yC(n) {
    return cn.str(n) && (n[0] == "#" || /\d/.test(n) || !Zx() && Em.test(n) || n in (Vs || {}))
}
const SC = Zx() ? N.useEffect : N.useLayoutEffect
  , $k = () => {
    const n = N.useRef(!1);
    return SC( () => (n.current = !0,
    () => {
        n.current = !1
    }
    ), []),
    n
}
;
function qk() {
    const n = N.useState()[1]
      , e = $k();
    return () => {
        e.current && n(Math.random())
    }
}
function Yk(n, e) {
    const [t] = N.useState( () => ({
        inputs: e,
        result: n()
    }))
      , i = N.useRef()
      , r = i.current;
    let s = r;
    return s ? e && s.inputs && Zk(e, s.inputs) || (s = {
        inputs: e,
        result: n()
    }) : s = t,
    N.useEffect( () => {
        i.current = s,
        r == t && (t.inputs = t.result = void 0)
    }
    , [s]),
    s.result
}
function Zk(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0; t < n.length; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
const Kk = n => N.useEffect(n, Jk)
  , Jk = []
  , Mu = Symbol.for("Animated:node")
  , Qk = n => !!n && n[Mu] === n
  , e_ = n => n && n[Mu]
  , MC = (n, e) => xk(n, Mu, e)
  , t_ = n => n && n[Mu] && n[Mu].getPayload();
class wC {
    constructor() {
        this.payload = void 0,
        MC(this, this)
    }
    getPayload() {
        return this.payload || []
    }
}
class Zu extends wC {
    constructor(e) {
        super(),
        this.done = !0,
        this.elapsedTime = void 0,
        this.lastPosition = void 0,
        this.lastVelocity = void 0,
        this.v0 = void 0,
        this.durationProgress = 0,
        this._value = e,
        cn.num(this._value) && (this.lastPosition = this._value)
    }
    static create(e) {
        return new Zu(e)
    }
    getPayload() {
        return [this]
    }
    getValue() {
        return this._value
    }
    setValue(e, t) {
        return cn.num(e) && (this.lastPosition = e,
        t && (e = Math.round(e / t) * t,
        this.done && (this.lastPosition = e))),
        this._value === e ? !1 : (this._value = e,
        !0)
    }
    reset() {
        const {done: e} = this;
        this.done = !1,
        cn.num(this._value) && (this.elapsedTime = 0,
        this.durationProgress = 0,
        this.lastPosition = this._value,
        e && (this.lastVelocity = null),
        this.v0 = null)
    }
}
class Cm extends Zu {
    constructor(e) {
        super(0),
        this._string = null,
        this._toString = void 0,
        this._toString = Su({
            output: [e, e]
        })
    }
    static create(e) {
        return new Cm(e)
    }
    getValue() {
        let e = this._string;
        return e ?? (this._string = this._toString(this._value))
    }
    setValue(e) {
        if (cn.str(e)) {
            if (e == this._string)
                return !1;
            this._string = e,
            this._value = 1
        } else if (super.setValue(e))
            this._string = null;
        else
            return !1;
        return !0
    }
    reset(e) {
        e && (this._toString = Su({
            output: [this.getValue(), e]
        })),
        this._value = 0,
        super.reset()
    }
}
const hp = {
    dependencies: null
};
class n_ extends wC {
    constructor(e) {
        super(),
        this.source = e,
        this.setValue(e)
    }
    getValue(e) {
        const t = {};
        return K1(this.source, (i, r) => {
            Qk(i) ? t[r] = i.getValue(e) : fp(i) ? t[r] = dp(i) : e || (t[r] = i)
        }
        ),
        t
    }
    setValue(e) {
        this.source = e,
        this.payload = this._makePayload(e)
    }
    reset() {
        this.payload && rs(this.payload, e => e.reset())
    }
    _makePayload(e) {
        if (e) {
            const t = new Set;
            return K1(e, this._addToPayload, t),
            Array.from(t)
        }
    }
    _addToPayload(e) {
        hp.dependencies && fp(e) && hp.dependencies.add(e);
        const t = t_(e);
        t && rs(t, i => this.add(i))
    }
}
class i_ extends n_ {
    constructor(e) {
        super(e)
    }
    static create(e) {
        return new i_(e)
    }
    getValue() {
        return this.source.map(e => e.getValue())
    }
    setValue(e) {
        const t = this.getPayload();
        return e.length == t.length ? t.map( (i, r) => i.setValue(e[r])).some(Boolean) : (super.setValue(e.map(eB)),
        !0)
    }
}
function eB(n) {
    return (yC(n) ? Cm : Zu).create(n)
}
function tB(n) {
    const e = e_(n);
    return e ? e.constructor : cn.arr(n) ? i_ : yC(n) ? Cm : Zu
}
function pp() {
    return pp = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    pp.apply(this, arguments)
}
const YM = (n, e) => {
    const t = !cn.fun(n) || n.prototype && n.prototype.isReactComponent;
    return N.forwardRef( (i, r) => {
        const s = N.useRef(null)
          , o = t && N.useCallback(x => {
            s.current = rB(r, x)
        }
        , [r])
          , [l,u] = iB(i, e)
          , f = qk()
          , d = () => {
            const x = s.current;
            if (t && !x)
                return;
            (x ? e.applyAnimatedValues(x, l.getValue(!0)) : !1) === !1 && f()
        }
          , h = new nB(d,u)
          , m = N.useRef();
        SC( () => (m.current = h,
        rs(u, x => pC(x, h)),
        () => {
            m.current && (rs(m.current.deps, x => tv(x, m.current)),
            At.cancel(m.current.update))
        }
        )),
        N.useEffect(d, []),
        Kk( () => () => {
            const x = m.current;
            rs(x.deps, S => tv(S, x))
        }
        );
        const g = e.getComponentProps(l.getValue());
        return N.createElement(n, pp({}, g, {
            ref: o
        }))
    }
    )
}
;
class nB {
    constructor(e, t) {
        this.update = e,
        this.deps = t
    }
    eventObserved(e) {
        e.type == "change" && At.write(this.update)
    }
}
function iB(n, e) {
    const t = new Set;
    return hp.dependencies = t,
    n.style && (n = pp({}, n, {
        style: e.createAnimatedStyle(n.style)
    })),
    n = new n_(n),
    hp.dependencies = null,
    [n, t]
}
function rB(n, e) {
    return n && (cn.fun(n) ? n(e) : n.current = e),
    e
}
const ZM = Symbol.for("AnimatedComponent")
  , sB = (n, {applyAnimatedValues: e= () => !1, createAnimatedStyle: t=r => new n_(r), getComponentProps: i=r => r}={}) => {
    const r = {
        applyAnimatedValues: e,
        createAnimatedStyle: t,
        getComponentProps: i
    }
      , s = o => {
        const l = KM(o) || "Anonymous";
        return cn.str(o) ? o = s[o] || (s[o] = YM(o, r)) : o = o[ZM] || (o[ZM] = YM(o, r)),
        o.displayName = `Animated(${l})`,
        o
    }
    ;
    return K1(n, (o, l) => {
        cn.arr(n) && (l = KM(o)),
        s[l] = s(o)
    }
    ),
    {
        animated: s
    }
}
  , KM = n => cn.str(n) ? n : n && cn.str(n.displayName) ? n.displayName : cn.fun(n) && n.name || null;
function nv() {
    return nv = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    nv.apply(this, arguments)
}
const oB = {
    default: {
        tension: 170,
        friction: 26
    },
    gentle: {
        tension: 120,
        friction: 14
    },
    wobbly: {
        tension: 180,
        friction: 12
    },
    stiff: {
        tension: 210,
        friction: 20
    },
    slow: {
        tension: 280,
        friction: 60
    },
    molasses: {
        tension: 280,
        friction: 120
    }
};
nv({}, oB.default, {
    mass: 1,
    damping: 1,
    easing: Fk.linear,
    clamp: !1
});
const JM = n => n instanceof bC;
let aB = 1;
class bC extends Bk {
    constructor(...e) {
        super(...e),
        this.id = aB++,
        this.key = void 0,
        this._priority = 0
    }
    get priority() {
        return this._priority
    }
    set priority(e) {
        this._priority != e && (this._priority = e,
        this._onPriorityChange(e))
    }
    get() {
        const e = e_(this);
        return e && e.getValue()
    }
    to(...e) {
        return yu.to(this, e)
    }
    interpolate(...e) {
        return Xk(),
        yu.to(this, e)
    }
    toJSON() {
        return this.get()
    }
    observerAdded(e) {
        e == 1 && this._attach()
    }
    observerRemoved(e) {
        e == 0 && this._detach()
    }
    _attach() {}
    _detach() {}
    _onChange(e, t=!1) {
        ev(this, {
            type: "change",
            parent: this,
            value: e,
            idle: t
        })
    }
    _onPriorityChange(e) {
        this.idle || Qx.sort(this),
        ev(this, {
            type: "priority",
            parent: this,
            priority: e
        })
    }
}
function lB(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
const cB = ["children"]
  , r_ = n => {
    let {children: e} = n
      , t = lB(n, cB);
    const i = N.useContext(mp)
      , r = t.pause || !!i.pause
      , s = t.immediate || !!i.immediate;
    t = Yk( () => ({
        pause: r,
        immediate: s
    }), [r, s]);
    const {Provider: o} = mp;
    return N.createElement(o, {
        value: t
    }, e)
}
  , mp = uB(r_, {});
r_.Provider = mp.Provider;
r_.Consumer = mp.Consumer;
function uB(n, e) {
    return Object.assign(n, N.createContext(e)),
    n.Provider._context = n,
    n.Consumer._context = n,
    n
}
let QM;
(function(n) {
    n.MOUNT = "mount",
    n.ENTER = "enter",
    n.UPDATE = "update",
    n.LEAVE = "leave"
}
)(QM || (QM = {}));
class fB extends bC {
    constructor(e, t) {
        super(),
        this.key = void 0,
        this.idle = !0,
        this.calc = void 0,
        this._active = new Set,
        this.source = e,
        this.calc = Su(...t);
        const i = this._get()
          , r = tB(i);
        MC(this, r.create(i))
    }
    advance(e) {
        const t = this._get()
          , i = this.get();
        _k(t, i) || (e_(this).setValue(t),
        this._onChange(t, this.idle)),
        !this.idle && e3(this._active) && n1(this)
    }
    _get() {
        const e = cn.arr(this.source) ? this.source.map(dp) : Jd(dp(this.source));
        return this.calc(...e)
    }
    _start() {
        this.idle && !e3(this._active) && (this.idle = !1,
        rs(t_(this), e => {
            e.done = !1
        }
        ),
        yu.skipAnimation ? (At.batchedUpdates( () => this.advance()),
        n1(this)) : Qx.start(this))
    }
    _attach() {
        let e = 1;
        rs(Jd(this.source), t => {
            fp(t) && pC(t, this),
            JM(t) && (t.idle || this._active.add(t),
            e = Math.max(e, t.priority + 1))
        }
        ),
        this.priority = e,
        this._start()
    }
    _detach() {
        rs(Jd(this.source), e => {
            fp(e) && tv(e, this)
        }
        ),
        this._active.clear(),
        n1(this)
    }
    eventObserved(e) {
        e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent),
        this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = Jd(this.source).reduce( (t, i) => Math.max(t, (JM(i) ? i.priority : 0) + 1), 0))
    }
}
function dB(n) {
    return n.idle !== !1
}
function e3(n) {
    return !n.size || Array.from(n).every(dB)
}
function n1(n) {
    n.idle || (n.idle = !0,
    rs(t_(n), e => {
        e.done = !0
    }
    ),
    ev(n, {
        type: "idle",
        parent: n
    }))
}
yu.assign({
    createStringInterpolator: vC,
    to: (n, e) => new fB(n,e)
});
const hB = ["primitive"].concat(Object.keys(DE).filter(n => /^[A-Z]/.test(n)).map(n => n[0].toLowerCase() + n.slice(1)));
yu.assign({
    createStringInterpolator: vC,
    colors: bk,
    frameLoop: "demand"
});
FF( () => {
    At.advance()
}
);
const pB = sB(hB, {
    applyAnimatedValues: Eo
})
  , mB = pB.animated;
function Tm(n, e, t, i) {
    const r = class extends Yi {
        constructor(o={}) {
            const l = Object.entries(n);
            super({
                uniforms: l.reduce( (u, [f,d]) => {
                    const h = gx.clone({
                        [f]: {
                            value: d
                        }
                    });
                    return {
                        ...u,
                        ...h
                    }
                }
                , {}),
                vertexShader: e,
                fragmentShader: t
            }),
            this.key = "",
            l.forEach( ([u]) => Object.defineProperty(this, u, {
                get: () => this.uniforms[u].value,
                set: f => this.uniforms[u].value = f
            })),
            Object.assign(this, o)
        }
    }
    ;
    return r.key = Cb.generateUUID(),
    r
}
function gB(n, e, t) {
    const i = Nr(m => m.size)
      , r = Nr(m => m.viewport)
      , s = typeof n == "number" ? n : i.width * r.dpr
      , o = i.height * r.dpr
      , l = (typeof n == "number" ? t : n) || {}
      , {samples: u=0, depth: f, ...d} = l
      , h = N.useMemo( () => {
        const m = new qi(s,o,{
            minFilter: ln,
            magFilter: ln,
            type: Xo,
            ...d
        });
        return f && (m.depthTexture = new tm(s,o,ii)),
        m.samples = u,
        m
    }
    , []);
    return N.useLayoutEffect( () => {
        h.setSize(s, o),
        u && (h.samples = u)
    }
    , [u, h, s, o]),
    N.useEffect( () => () => h.dispose(), []),
    h
}
const vB = n => typeof n == "function"
  , xB = N.forwardRef( ({envMap: n, resolution: e=256, frames: t=1 / 0, makeDefault: i, children: r, ...s}, o) => {
    const l = Nr( ({set: _}) => _)
      , u = Nr( ({camera: _}) => _)
      , f = Nr( ({size: _}) => _)
      , d = N.useRef(null);
    N.useImperativeHandle(o, () => d.current, []);
    const h = N.useRef(null)
      , m = gB(e);
    N.useLayoutEffect( () => {
        s.manual || (d.current.aspect = f.width / f.height)
    }
    , [f, s]),
    N.useLayoutEffect( () => {
        d.current.updateProjectionMatrix()
    }
    );
    let g = 0
      , x = null;
    const S = vB(r);
    return Xu(_ => {
        S && (t === 1 / 0 || g < t) && (h.current.visible = !1,
        _.gl.setRenderTarget(m),
        x = _.scene.background,
        n && (_.scene.background = n),
        _.gl.render(_.scene, d.current),
        _.scene.background = x,
        _.gl.setRenderTarget(null),
        h.current.visible = !0,
        g++)
    }
    ),
    N.useLayoutEffect( () => {
        if (i) {
            const _ = u;
            return l( () => ({
                camera: d.current
            })),
            () => l( () => ({
                camera: _
            }))
        }
    }
    , [d, i, l]),
    N.createElement(N.Fragment, null, N.createElement("perspectiveCamera", ol({
        ref: d
    }, s), !S && r), N.createElement("group", {
        ref: h
    }, S && r(m.texture)))
}
);
function _B({all: n, scene: e, camera: t}) {
    const i = Nr( ({gl: o}) => o)
      , r = Nr( ({camera: o}) => o)
      , s = Nr( ({scene: o}) => o);
    return N.useLayoutEffect( () => {
        const o = [];
        n && (e || s).traverse(f => {
            f.visible === !1 && (o.push(f),
            f.visible = !0)
        }
        ),
        i.compile(e || s, t || r);
        const l = new xx(128);
        new vx(.01,1e5,l).update(i, e || s),
        l.dispose(),
        o.forEach(f => f.visible = !1)
    }
    , []),
    null
}
const yB = N.createContext(null);
function SB({iterations: n=10, ms: e=250, threshold: t=.75, step: i=.1, factor: r=.5, flipflops: s=1 / 0, bounds: o=m => m > 100 ? [60, 100] : [40, 60], onIncline: l, onDecline: u, onChange: f, onFallback: d, children: h}) {
    const m = Math.pow(10, 0)
      , [g,x] = N.useState( () => ({
        fps: 0,
        index: 0,
        factor: r,
        flipped: 0,
        refreshrate: 0,
        fallback: !1,
        frames: [],
        averages: [],
        subscriptions: new Map,
        subscribe: _ => {
            const v = Symbol();
            return g.subscriptions.set(v, _.current),
            () => void g.subscriptions.delete(v)
        }
    }));
    let S = 0;
    return Xu( () => {
        const {frames: _, averages: v} = g;
        if (!g.fallback && v.length < n) {
            _.push(performance.now());
            const M = _[_.length - 1] - _[0];
            if (M >= e) {
                if (g.fps = Math.round(_.length / M * 1e3 * m) / m,
                g.refreshrate = Math.max(g.refreshrate, g.fps),
                v[g.index++ % n] = g.fps,
                v.length === n) {
                    const [w,E] = o(g.refreshrate)
                      , O = v.filter(A => A >= E)
                      , R = v.filter(A => A < w);
                    O.length > n * t && (g.factor = Math.min(1, g.factor + i),
                    g.flipped++,
                    l && l(g),
                    g.subscriptions.forEach(A => A.onIncline && A.onIncline(g))),
                    R.length > n * t && (g.factor = Math.max(0, g.factor - i),
                    g.flipped++,
                    u && u(g),
                    g.subscriptions.forEach(A => A.onDecline && A.onDecline(g))),
                    S !== g.factor && (S = g.factor,
                    f && f(g),
                    g.subscriptions.forEach(A => A.onChange && A.onChange(g))),
                    g.flipped > s && !g.fallback && (g.fallback = !0,
                    d && d(g),
                    g.subscriptions.forEach(A => A.onFallback && A.onFallback(g))),
                    g.averages = []
                }
                g.frames = []
            }
        }
    }
    ),
    N.createElement(yB.Provider, {
        value: g
    }, h)
}
const MB = `        uniform float time;
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform vec3 uColor3;

varying vec2 vUv;

const float innerRadius = 0.6;
const float noiseScale = 0.7;

vec3 hash33(vec3 p3) {
    p3 = fract(p3 * vec3(.1031, .11369, .13787));
    p3 += dot(p3, p3.yxz+19.19);
    return -1.0 + 2.0 * fract(vec3(p3.x+p3.y, p3.x+p3.z, p3.y+p3.z)*p3.zyx);
}

float snoise(vec3 uv, float res) {
	const vec3 s = vec3(1e0, 1e2, 1e3);
	uv *= res;
	vec3 uv0 = floor(mod(uv, res))*s;
	vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;
	vec3 f = fract(uv); f = f*f*(3.0-2.0*f);
	vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
		      	  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);
	vec4 r = fract(sin(v*1e-1)*1e3);
	float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
	r = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);
	float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
	return mix(r0, r1, f.z)*2.-1.;
}

float snoise3(vec3 p) {
    const float K1 = 0.333333333;
    const float K2 = 0.166666667;

    vec3 i = floor(p + (p.x + p.y + p.z) * K1);
    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);

    vec3 e = step(vec3(0.0), d0 - d0.yzx);
    vec3 i1 = e * (1.0 - e.zxy);
    vec3 i2 = 1.0 - e.zxy * (1.0 - e);

    vec3 d1 = d0 - (i1 - K2);
    vec3 d2 = d0 - (i2 - K1);
    vec3 d3 = d0 - 0.5;

    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);
    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));

    return dot(vec4(31.316), n);
}

vec4 extractAlpha(vec3 colorIn)
{
    vec4 colorOut;
    float maxValue = min(max(max(colorIn.r, colorIn.g), colorIn.b), 1.0);
    if (maxValue > 1e-5)
    {
        colorOut.rgb = colorIn.rgb * (1.0 / maxValue);
        colorOut.a = maxValue;
    }
    else
    {
        colorOut = vec4(0.0);
    }
    return colorOut;
}

float light1(float intensity, float attenuation, float dist)
{
    return intensity / (1.0 + dist * attenuation);
}
float light2(float intensity, float attenuation, float dist)
{
    return intensity / (1.0 + dist * dist * attenuation);
}

void main() {
//    vec2 centerPos = vUv.xy / .5 - vec2(1., 1.) * 1.1;
//    vec2 centerPos = vUv.xy / .5 - vec2(1., 1.) * 1.1;
    vec2 centerPos = (vUv.xy - .5) / .5;


    float _time = time;
    int colorStyle = 0;
    bool hole = true;

    vec3 color1 = uColor1;
    vec3 color2 = uColor2;
    vec3 color3 = uColor3;
    vec2 uv = centerPos;

    float ang = atan(uv.y, uv.x);
    float cl = cos(ang + _time * 2.0) * 0.5 + 0.5;
    float len = length(uv);
    float v0, v1, v2, v3;
    float r0, d0, n0;
    float r, d;

    // ring
    n0 = snoise3(vec3(uv * noiseScale, _time * 0.5)) * 0.5 + 0.5;
    r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);
    d0 = distance(uv, r0 / len * uv);
    v0 = light1(1.0, 10.0, d0);
    v0 *= smoothstep(r0 * 1.05, r0, len);

    // high light
    float a = _time * -1.0;
    vec2 pos = vec2(cos(a), sin(a)) * r0;
    d = distance(uv, pos);
    v1 = light2(1.5, 5.0, d);
    v1 *= light1(1.0, 50.0, d0);

    // back decay
    v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);

    // hole
    v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.6), len);

    // color
    vec3 c = mix(color1, color2, cl);
    vec3 col = mix(color1, color2, cl);
    col = mix(color3, col, v0);
    col = (col + v1) * v2;
    if (hole) {
        col *= v3;
    }
    col.rgb = clamp(col.rgb, 0.0, 1.0);

    gl_FragColor = extractAlpha(col);
}
`
  , EC = Tm({
    time: 0,
    uColor1: new Oe("#9c43fe"),
    uColor2: new Oe("#4cc2e9"),
    uColor3: new Oe("#101499")
}, `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }`, MB);
Wu({
    DaoMaterial: EC
});
const wB = `#define detail_steps_ 13
#define mod3_      vec3(.1031, .11369, .13787)

uniform float time;
uniform float noiseMultiplier;
uniform float radiusMinus;
uniform vec2 resolution;
uniform vec3 uColor1;
uniform vec3 uColor2;
uniform vec3 uColor3;

varying vec2 vUv;



vec3 hash3_3(vec3 p3) {
	p3 = fract(p3 * mod3_);
    p3 += dot(p3, p3.yxz + 19.19);
    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));
}

float perlin_noise3(vec3 p) {
    vec3 pi = floor(p);
    vec3 pf = p - pi;

    vec3 w = pf * pf * (3. - 2. * pf);

    return 	mix(
    	mix(
            mix(
                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))),
                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),
                w.x),
            mix(
                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))),
                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),
                w.x),
    	w.z),
        mix(
            mix(
                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))),
                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),
                w.x),
            mix(
                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))),
                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),
                w.x),
     	w.z),
	w.y);
}


float noise_sum_abs3(vec3 p) {
    float f = 0.;
    p = p * noiseMultiplier;

    f += 1.0000 * abs(perlin_noise3(p)); p = 2. * p;
//    f += 0.5000 * abs(perlin_noise3(p)); p = 3. * p;
//	f += 0.2500 * abs(perlin_noise3(p)); p = 4. * p;
	// f += 0.1250 * abs(perlin_noise3(p)); p = 5. * p;
//	f += 0.0625 * abs(perlin_noise3(p)); p = 6. * p;

    return f;
}

vec2 domain(vec2 uv, float s) {
    return (2.*uv.xy-resolution.xy) / resolution.x*s;
}


vec4 extractAlpha(vec3 colorIn)
{
    vec4 colorOut;
    float maxValue = min(max(max(colorIn.r, colorIn.g), colorIn.b), 1.0);
    if (maxValue > 1e-5)
    {
        colorOut.rgb = colorIn.rgb * (1.0 / maxValue);
        colorOut.a = maxValue;
    }
    else
    {
        colorOut = vec4(0.0);
    }
    return colorOut;
}

void main() {
    vec2 p = (vUv.xy - .5) / .13;

    float ang = atan(p.y, p.x);
    float cl = cos(ang + time * 2.0) * 0.5 + 0.5;

    float electric_density = .9;

    //
//    float electric_radius  = length(p) + .9;
    //

//    float electric_radius  = length(p) - .4;
    float electric_radius  = length(p) - radiusMinus;

    float velocity = .5;

    float moving_coord = cl * 2.;
//    float moving_coord = max(cos(time), sin(time));
    vec3  electric_local_domain = vec3(p, moving_coord);
    float electric_field = electric_density * noise_sum_abs3(electric_local_domain);

//    vec3 col = vec3(107, 148, 196) / 255.;
    vec3 col = mix(uColor1, uColor2, cl);
    col = mix(col, uColor3, cl);
 	col += (1. - (electric_field + electric_radius));
    for(int i = 0; i < detail_steps_; i++) {
    	if(length(col) >= 2.1 + float(i) / 2.)
            col -= .3;
    }
    col += 1. - 4.2*electric_field;
    vec4 final = extractAlpha(col);
    final.a = final.a / 1.4;
    gl_FragColor = final;
}
`
  , CC = Tm({
    time: 0,
    noiseMultiplier: 3,
    radiusMinus: .1,
    uColor1: new Oe("#9c43fe"),
    uColor2: new Oe("#4cc2e9"),
    uColor3: new Oe("#101499")
}, `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }`, wB);
Wu({
    LightningMaterial: CC
});
const bB = n => {
    const {t: e} = hn();
    return T.jsx(rC, {
        position: [0, 0, 0],
        center: !0,
        pointerEvents: "none",
        ...n,
        children: T.jsxs("div", {
            className: "w-[100vw] justify-center flex items-center flex-col",
            children: [T.jsx("div", {
                className: "fingerprint-icon w-[10vh] h-[10vh]",
                style: {
                    width: "calc(10vh)",
                    height: "calc(10vh)"
                }
            }), T.jsx("div", {
                className: "text-center text-[#B9B2C4] text-xs mt-3",
                children: e("Hold your finger here")
            })]
        })
    })
}
  , EB = `uniform float time;
uniform vec2 resolution;
uniform vec2 pointer;
varying vec2 vUv;


vec4 reaction() {
	vec3 c;
	float l,z=time;
	for(int i=0;i<6;i++) {
		vec2 uv,p=gl_FragCoord.xy/resolution;
        uv.y += 0.05;
        p.y += 0.0;
		uv=p;
		p-=.5;
		p.x*=resolution.x/resolution.y;
		z+=.07;
		l=length(p);
		uv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z-z));
		c[i]=.01/length(mod(uv,1.)-.5);
	}
	return vec4(c/l,time);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.263, 0.416, 0.557);
    return a + b * cos(6.28318 * (c * t + d));
}

void main() {
    gl_FragColor = vec4(reaction().rgb, .2);
}`
  , TC = Tm({
    time: 0,
    resolution: new he,
    pointer: new he
}, `
      varying vec2 vUv;
      void main() {
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
        vec4 viewPosition = viewMatrix * modelPosition;
        vec4 projectionPosition = projectionMatrix * viewPosition;
        gl_Position = projectionPosition;
        vUv = uv;
      }`, EB);
Wu({
    BackgroundMaterial: TC
});
const nh = ({onClick: n, ...e}) => T.jsx(rC, {
    position: [0, 0, 0],
    center: !0,
    ...e,
    children: T.jsx("div", {
        className: "h-[60px] w-[60px] rounded-full flex justify-center items-center z-50 shrink-0 grow-0",
        style: {
            background: "#262626"
        },
        onClick: n,
        children: T.jsxs("svg", {
            width: "42",
            height: "42",
            viewBox: "0 0 54 54",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: [T.jsx("path", {
                opacity: "0.2",
                d: "M47.25 27C47.25 31.0051 46.0624 34.9202 43.8373 38.2503C41.6122 41.5804 38.4496 44.1759 34.7494 45.7086C31.0491 47.2412 26.9775 47.6423 23.0494 46.8609C19.1213 46.0796 15.5131 44.1509 12.6811 41.3189C9.84908 38.4869 7.92046 34.8787 7.13911 30.9506C6.35776 27.0225 6.75877 22.9509 8.29145 19.2507C9.82412 15.5505 12.4196 12.3878 15.7497 10.1627C19.0798 7.93764 22.9949 6.75 27 6.75C32.3706 6.75 37.5213 8.88348 41.3189 12.6811C45.1165 16.4787 47.25 21.6294 47.25 27Z",
                fill: "white"
            }), T.jsx("path", {
                d: "M27 5.0625C22.6612 5.0625 18.4198 6.34911 14.8122 8.75964C11.2046 11.1702 8.3928 14.5963 6.7324 18.6049C5.07201 22.6134 4.63757 27.0243 5.48403 31.2798C6.3305 35.5353 8.41984 39.4441 11.4879 42.5122C14.5559 45.5802 18.4648 47.6695 22.7202 48.516C26.9757 49.3624 31.3866 48.928 35.3951 47.2676C39.4037 45.6072 42.8299 42.7954 45.2404 39.1878C47.6509 35.5802 48.9375 31.3388 48.9375 27C48.9314 21.1837 46.6181 15.6074 42.5054 11.4946C38.3926 7.38188 32.8163 5.06864 27 5.0625ZM27 45.5625C23.3287 45.5625 19.7398 44.4738 16.6872 42.4342C13.6347 40.3945 11.2554 37.4954 9.8505 34.1036C8.44554 30.7117 8.07794 26.9794 8.79418 23.3786C9.51042 19.7779 11.2783 16.4703 13.8743 13.8743C16.4704 11.2783 19.7779 9.51041 23.3786 8.79417C26.9794 8.07794 30.7117 8.44553 34.1036 9.85049C37.4954 11.2554 40.3945 13.6346 42.4342 16.6872C44.4738 19.7398 45.5625 23.3287 45.5625 27C45.5569 31.9214 43.5994 36.6396 40.1195 40.1195C36.6396 43.5994 31.9214 45.5569 27 45.5625ZM37.125 27C37.125 27.4476 36.9472 27.8768 36.6308 28.1932C36.3143 28.5097 35.8851 28.6875 35.4375 28.6875H28.6875V35.4375C28.6875 35.8851 28.5097 36.3143 28.1933 36.6307C27.8768 36.9472 27.4476 37.125 27 37.125C26.5525 37.125 26.1232 36.9472 25.8068 36.6307C25.4903 36.3143 25.3125 35.8851 25.3125 35.4375V28.6875H18.5625C18.115 28.6875 17.6857 28.5097 17.3693 28.1932C17.0528 27.8768 16.875 27.4476 16.875 27C16.875 26.5524 17.0528 26.1232 17.3693 25.8068C17.6857 25.4903 18.115 25.3125 18.5625 25.3125H25.3125V18.5625C25.3125 18.1149 25.4903 17.6857 25.8068 17.3693C26.1232 17.0528 26.5525 16.875 27 16.875C27.4476 16.875 27.8768 17.0528 28.1933 17.3693C28.5097 17.6857 28.6875 18.1149 28.6875 18.5625V25.3125H35.4375C35.8851 25.3125 36.3143 25.4903 36.6308 25.8068C36.9472 26.1232 37.125 26.5524 37.125 27Z",
                fill: "white"
            })]
        })
    })
});
class CB {
    constructor() {
        Hn(this, "isVibrating");
        this.isVibrating = !1,
        gp(this)
    }
    setIsVibrating(e) {
        this.isVibrating = e
    }
}
const Ka = new CB;
class TB {
    constructor() {
        Hn(this, "hideRender", !1);
        gp(this)
    }
    setHideRender(e) {
        this.hideRender = e
    }
}
const gh = new TB
  , AB = ({falloff: n=.1, glowInternalRadius: e=6, glowColor: t="#00ff00", glowSharpness: i=1, side: r=Dr, blending: s}) => {
    const o = N.useMemo( () => Tm({
        falloffAmount: n,
        glowInternalRadius: e,
        glowColor: new Oe(t),
        glowSharpness: i
    }, `
      varying vec3 vPosition;
      varying vec3 vNormal;
      void main() {
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * viewMatrix * modelPosition;
        vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
        vPosition = modelPosition.xyz;
        vNormal = modelNormal.xyz;
      }`, ` 
      uniform vec3 glowColor;
      uniform float falloffAmount;
      uniform float glowSharpness;
      uniform float glowInternalRadius;
      varying vec3 vPosition;
      varying vec3 vNormal;
      void main()
      {
        // Normal
        vec3 normal = normalize(vNormal);
        if(!gl_FrontFacing)
            normal *= - 1.0;
        vec3 viewDirection = normalize(cameraPosition - vPosition);
        float fresnel = dot(viewDirection, normal);
        fresnel = pow(fresnel, glowInternalRadius + 0.1);
        float falloff = smoothstep(0., falloffAmount, fresnel);
        float fakeGlow = fresnel;
        fakeGlow += fresnel * glowSharpness;
        fakeGlow *= falloff;
        gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));
      }`), [n, e, t, i]);
    return Wu({
        FakeGlowMaterial: o
    }),
    T.jsx("fakeGlowMaterial", {
        side: r,
        transparent: !0,
        blending: s || Jc
    }, o.key)
}
;
EC.key;
CC.key;
const RB = mB("lightningMaterial")
  , xc = ({position: n, onPointerDown: e= () => {}
, onPointerUp: t= () => {}
, scale: i, colors: r=["#9c43fe", "#4cc2e9", "#101499"], expression: s= () => Et.touch}) => {
    console.debug("GamePlayer");
    const o = N.useRef()
      , l = N.useRef();
    Xu( (x, S) => {
        o.current && (o.current.time += S * .5),
        l.current && (l.current.time += S * .5)
    }
    );
    const [u,f] = N.useState(.9)
      , [d,h] = N.useState(-1.9);
    N.useEffect( () => on(s, x => {
        f(x ? 1.5 : .5),
        h(x ? .9 : -1.9)
    }
    ), [s]);
    const {radiusMinus: m} = ss({
        radiusMinus: d,
        config: {
            duration: 1e4
        }
    })
      , {noiseMultiplier: g} = ss({
        noiseMultiplier: u,
        config: {
            duration: 1e4
        }
    });
    return T.jsxs("group", {
        scale: [i || 2, i || 2, 1],
        position: n || [0, 0, 0],
        onPointerDown: e,
        onPointerUp: t,
        onPointerLeave: t,
        onPointerCancel: t,
        onPointerOut: t,
        children: [T.jsxs("mesh", {
            scale: 1.05,
            children: [T.jsx("circleGeometry", {}), T.jsx(RB, {
                transparent: !0,
                ref: o,
                noiseMultiplier: g,
                radiusMinus: m,
                uColor1: r[0],
                uColor2: r[1],
                uColor3: r[2]
            })]
        }), T.jsxs("mesh", {
            children: [T.jsx("circleGeometry", {}), T.jsx("daoMaterial", {
                transparent: !0,
                ref: l,
                uColor1: r[0],
                uColor2: r[1],
                uColor3: r[2]
            })]
        })]
    })
}
  , PB = Pi( () => {
    const n = N.useRef({
        time: 0
    })
      , {viewport: e, size: t} = Nr();
    Xu( (r, s) => {
        var o, l;
        !((o = n.current) != null && o.time) && ((l = n.current) == null ? void 0 : l.time) !== 0 || (n.current.time += s * .2)
    }
    );
    const {isMegaFarmNow: i} = de;
    return i ? T.jsxs("mesh", {
        scale: [e.width, e.height, 1],
        children: [T.jsx("planeGeometry", {}), T.jsx("backgroundMaterial", {
            ref: n,
            transparent: !0,
            resolution: [t.width * e.dpr, t.height * e.dpr]
        }, TC.key)]
    }) : null
}
)
  , IB = Pi( () => Et.touch ? null : T.jsx(bB, {
    style: {
        pointerEvents: "none",
        opacity: .5
    }
}))
  , LB = () => {
    var G, q, K, oe;
    const [n,e] = N.useState(1)
      , [t,i] = N.useState(1)
      , [r,s] = N.useState(!1);
    console.log("GameScene");
    const [o,l] = N.useState(null)
      , u = o ? Ha[o] : xn[0];
    N.useEffect( () => on( () => {
        var z;
        return (z = de.profile) == null ? void 0 : z.hero
    }
    , z => {
        l(z || "galactic_night")
    }
    , {
        fireImmediately: !0
    }), []);
    const f = Rw();
    N.useEffect( () => on( () => de.dao_id, z => {
        z ? (s(!0),
        e(1.4)) : (s(!1),
        e(2.3))
    }
    , {
        fireImmediately: !0
    }), []),
    N.useEffect( () => on( () => de.currentLevel, z => {
        i(z)
    }
    , {
        fireImmediately: !0
    }), []);
    const [d,h] = N.useState(!1)
      , [m,g] = N.useState(!1)
      , [x,S] = N.useState(!1)
      , [_,v] = N.useState(!1)
      , [M,w] = N.useState("galactic_night")
      , [E,O] = N.useState("galactic_night")
      , [R,A] = N.useState("galactic_night")
      , [F,I] = N.useState("galactic_night")
      , P = M ? Ha[M] : xn[0]
      , D = E ? Ha[E] : xn[0]
      , W = R ? Ha[R] : xn[0]
      , X = F ? Ha[F] : xn[0];
    return N.useEffect( () => on( () => de.daoUser1Online, z => {
        h(z)
    }
    , {
        fireImmediately: !0
    }), []),
    N.useEffect( () => on( () => de.daoUser2Online, z => {
        g(z)
    }
    , {
        fireImmediately: !0
    }), []),
    N.useEffect( () => on( () => de.daoUser3Online, z => {
        S(z)
    }
    , {
        fireImmediately: !0
    }), []),
    N.useEffect( () => on( () => de.daoUser4Online, z => {
        v(z)
    }
    , {
        fireImmediately: !0
    }), []),
    N.useEffect( () => on( () => de.daoUsers, z => {
        var ee, Q, ce, be;
        w(((ee = z == null ? void 0 : z[0]) == null ? void 0 : ee.hero) || "galactic_night"),
        O(((Q = z == null ? void 0 : z[1]) == null ? void 0 : Q.hero) || "galactic_night"),
        A(((ce = z == null ? void 0 : z[2]) == null ? void 0 : ce.hero) || "galactic_night"),
        I(((be = z == null ? void 0 : z[3]) == null ? void 0 : be.hero) || "galactic_night")
    }
    , {
        fireImmediately: !0
    }), []),
    T.jsxs(T.Fragment, {
        children: [T.jsx(xB, {
            makeDefault: !0,
            position: [0, .25, 10]
        }), T.jsxs("mesh", {
            scale: 30,
            position: [0, 0, -30],
            children: [T.jsx("sphereGeometry", {}), T.jsx(AB, {
                glowSharpness: .1,
                glowColor: u[0],
                glowInternalRadius: 3,
                falloff: 5,
                blending: Jc
            })]
        }), T.jsx(xc, {
            onPointerDown: () => {
                Et.setTouch(!0)
            }
            ,
            onPointerUp: () => {
                Et.setTouch(!1)
            }
            ,
            scale: n,
            colors: u,
            expression: () => Ka.isVibrating
        }), r ? T.jsxs(T.Fragment, {
            children: [T.jsx(xc, {
                scale: .7,
                expression: () => {
                    var z, ee, Q;
                    return (Q = de.daoUsersTouching) == null ? void 0 : Q[(ee = (z = de.daoUsers) == null ? void 0 : z[0]) == null ? void 0 : ee.id]
                }
                ,
                colors: d ? P : xn[0],
                position: [-1.3, 1.6, 0]
            }), T.jsx(xc, {
                scale: .7,
                expression: () => {
                    var z, ee, Q;
                    return (Q = de.daoUsersTouching) == null ? void 0 : Q[(ee = (z = de.daoUsers) == null ? void 0 : z[1]) == null ? void 0 : ee.id]
                }
                ,
                colors: m ? D : xn[0],
                position: [1.3, 1.6, 0]
            }), T.jsx(xc, {
                scale: .7,
                expression: () => {
                    var z, ee, Q;
                    return (Q = de.daoUsersTouching) == null ? void 0 : Q[(ee = (z = de.daoUsers) == null ? void 0 : z[2]) == null ? void 0 : ee.id]
                }
                ,
                colors: x ? W : xn[0],
                position: [-1.3, -1.6, 0]
            }), T.jsx(xc, {
                scale: .7,
                expression: () => {
                    var z, ee, Q;
                    return (Q = de.daoUsersTouching) == null ? void 0 : Q[(ee = (z = de.daoUsers) == null ? void 0 : z[3]) == null ? void 0 : ee.id]
                }
                ,
                colors: _ ? X : xn[0],
                position: [1.3, -1.6, 0]
            }), (G = de.daoUsers) != null && G[0] ? null : T.jsx(nh, {
                onClick: () => f(),
                position: [-1.3, 1.6, 0]
            }), (q = de.daoUsers) != null && q[1] ? null : T.jsx(nh, {
                onClick: () => f(),
                position: [1.3, 1.6, 0]
            }), (K = de.daoUsers) != null && K[2] ? null : T.jsx(nh, {
                onClick: () => f(),
                position: [-1.3, -1.6, 0]
            }), (oe = de.daoUsers) != null && oe[3] ? null : T.jsx(nh, {
                onClick: () => f(),
                position: [1.3, -1.6, 0]
            })]
        }) : null, T.jsx(PB, {}), t === 1 ? T.jsx(IB, {}) : null]
    })
}
  , NB = () => {
    console.debug("GameCanvas");
    const [n,e] = N.useState(!1);
    N.useEffect( () => on( () => gh.hideRender, r => {
        e(r)
    }
    , {
        fireImmediately: !0
    }), []);
    const [t,i] = N.useState(1.5);
    return T.jsx(ok, {
        style: {
            backgroundColor: "#111111"
        },
        linear: !0,
        flat: !0,
        dpr: t,
        children: T.jsxs(N.Suspense, {
            fallback: null,
            children: [n ? null : T.jsx(LB, {}), T.jsx(SB, {
                onChange: ({factor: r, fps: s}) => {
                    s < 60 && i(Math.round(.5 + 1 * r))
                }
            }), T.jsx(_B, {
                all: !0
            })]
        })
    })
}
  , OB = () => {
    const n = o3()
      , [e,t] = N.useState(1)
      , [i,r] = N.useState(0)
      , [s,o] = N.useState("soft")
      , [l,u] = N.useState(1e3)
      , f = N.useCallback( () => {
        i === 0 ? (u(50),
        o("soft"),
        r(1)) : i === 1 ? (u(50),
        o("soft"),
        r(2)) : i === 2 ? (u(50),
        o("soft"),
        r(3)) : i === 3 ? (u(50),
        o("soft"),
        r(4)) : i === 4 ? (u(50),
        o("soft"),
        r(5)) : i === 5 && (u(50),
        o("soft"),
        r(0))
    }
    , [i])
      , d = N.useCallback( () => {
        i === 0 ? (u(50),
        o("light"),
        r(1)) : i === 1 ? (u(50),
        o("light"),
        r(2)) : i === 2 ? (u(50),
        o("light"),
        r(3)) : i === 3 ? (u(50),
        o("light"),
        r(4)) : i === 4 ? (u(50),
        o("light"),
        r(5)) : i === 5 && (u(50),
        o("light"),
        r(0))
    }
    , [i])
      , h = N.useCallback( () => {
        i === 0 ? (u(60),
        o("soft"),
        r(1)) : i === 1 ? (u(60),
        o("soft"),
        r(2)) : i === 2 ? (u(60),
        o("soft"),
        r(3)) : i === 3 ? (u(60),
        o("soft"),
        r(4)) : i === 4 ? (u(60),
        o("soft"),
        r(5)) : i === 5 && (u(60),
        o("soft"),
        r(0))
    }
    , [i])
      , m = N.useCallback( () => {
        i === 0 ? (u(60),
        o("rigid"),
        r(1)) : i === 1 ? (u(60),
        o("rigid"),
        r(2)) : i === 2 ? (u(60),
        o("rigid"),
        r(3)) : i === 3 ? (u(60),
        o("rigid"),
        r(4)) : i === 4 ? (u(60),
        o("rigid"),
        r(5)) : i === 5 && (u(60),
        o("rigid"),
        r(0))
    }
    , [i])
      , g = N.useCallback( () => {
        i === 0 ? (u(50),
        o("rigid"),
        r(1)) : i === 1 ? (u(50),
        o("rigid"),
        r(2)) : i === 2 ? (u(50),
        o("rigid"),
        r(3)) : i === 3 ? (u(50),
        o("rigid"),
        r(4)) : i === 4 ? (u(50),
        o("rigid"),
        r(5)) : i === 5 && (u(50),
        o("rigid"),
        r(0))
    }
    , [i])
      , x = N.useCallback( () => {
        i === 0 ? (u(55),
        o("soft"),
        r(1)) : i === 1 ? (u(55),
        o("light"),
        r(2)) : i === 2 ? (u(55),
        o("soft"),
        r(3)) : i === 3 ? (u(55),
        o("light"),
        r(4)) : i === 4 ? (u(55),
        o("soft"),
        r(5)) : i === 5 && (u(55),
        o("light"),
        r(0))
    }
    , [i])
      , S = N.useCallback( () => {
        e === 1 && f(),
        e === 2 && d(),
        e === 3 && h(),
        e === 4 && m(),
        e === 5 && g(),
        e === 6 && x()
    }
    , [f, d, h, m, g, x, e])
      , [_,v] = N.useState(!1);
    N.useEffect( () => {
        const w = navigator.userAgent
          , O = ( () => {
            const R = w.match(/Android\s([0-9.]*)/);
            return R ? parseInt(R[1]) : 0
        }
        )();
        O && O < 12 && v(!0)
    }
    , []);
    const M = N.useCallback( () => {
        var w, E, O, R, A, F, I, P, D, W;
        if (_) {
            (w = navigator == null ? void 0 : navigator.vibrate) == null || w.call(navigator, 1e3);
            return
        }
        s === "soft" ? (E = n == null ? void 0 : n.HapticFeedback) == null || E.impactOccurred("soft") : s === "heavy" ? (O = n == null ? void 0 : n.HapticFeedback) == null || O.impactOccurred("heavy") : s === "light" ? (R = n == null ? void 0 : n.HapticFeedback) == null || R.impactOccurred("light") : s === "medium" ? (A = n == null ? void 0 : n.HapticFeedback) == null || A.impactOccurred("medium") : s === "rigid" ? (F = n == null ? void 0 : n.HapticFeedback) == null || F.impactOccurred("rigid") : s === "error" ? (I = n == null ? void 0 : n.HapticFeedback) == null || I.notificationOccurred("error") : s === "success" ? (P = n == null ? void 0 : n.HapticFeedback) == null || P.notificationOccurred("success") : s === "warning" ? (D = n == null ? void 0 : n.HapticFeedback) == null || D.notificationOccurred("warning") : s === "selection" && ((W = n == null ? void 0 : n.HapticFeedback) == null || W.selectionChanged())
    }
    , [s, n == null ? void 0 : n.HapticFeedback, _]);
    return {
        vibrationCycle: i,
        setVibrationCycle: r,
        vibrationType: s,
        setVibrationType: o,
        vibrationDelay: l,
        setVibrationByStyle: S,
        vibrate: M,
        vibrationStyle: e,
        setVibrationStyle: t
    }
}
  , DB = n => {
    Et.lastEnergyRestoredFrame + 200 <= n && Et.setLastEnergyRestoredFrame(n),
    Et.lastSecond + 500 < n && (Et.lastSecond = n,
    de.updateIsMegaFarmNow(),
    de.updateDaoUsersTouching()),
    Et.touching && !Et.touch ? (console.debug("End of touch"),
    Et.touching = !1,
    Ka.setIsVibrating(!1),
    de.setLastTapTime()) : !Et.touching && !Et.touch ? Ka.setIsVibrating(!1) : !Et.touching && Et.touch ? Et.touching = !0 : Et.touching && Et.touch && n - Et.lastCountedFrame >= 1e3 / 2 && (de.tap() ? (Et.lastCountedFrame = n,
    Ka.setIsVibrating(!0)) : Ka.setIsVibrating(!1))
}
  , UB = Pi( () => {
    const n = o3()
      , [e,t] = N.useState(performance.now())
      , {pathname: i} = Wo();
    N.useEffect( () => {
        i !== "/" && Et.setTouch(!1)
    }
    , [i]),
    N.useEffect( () => {
        const S = () => {
            Et.setTouch(!1)
        }
        ;
        return Yf.onEvent("viewportChanged", S),
        () => {
            Yf.offEvent("viewportChanged", S)
        }
    }
    , []),
    N.useEffect( () => {
        const S = () => {
            Et.setTouch(!1)
        }
        ;
        return Yf.onEvent("viewportChanged", S),
        () => {
            Yf.offEvent("viewportChanged", S)
        }
    }
    , []);
    const {vibrationCycle: r, setVibrationCycle: s, vibrationType: o, setVibrationType: l, vibrationDelay: u, setVibrationByStyle: f, vibrate: d} = OB();
    N.useEffect( () => {
        let S;
        const _ = v => {
            S = requestAnimationFrame(_),
            t(v),
            DB(v)
        }
        ;
        return requestAnimationFrame(_),
        () => cancelAnimationFrame(S)
    }
    , []);
    const h = N.useRef(performance.now())
      , m = N.useRef(performance.now())
      , g = N.useRef(performance.now());
    N.useEffect( () => {
        f()
    }
    , []),
    N.useEffect( () => {
        var S, _;
        m.current + 1e3 <= e && (m.current = e,
        de.updateIsMegaFarmNow()),
        g.current + 1e3 <= e && (g.current = e,
        (_ = (S = de.centrifugo) == null ? void 0 : S.rpc("sync", {})) == null || _.then(v => {
            var M, w, E;
            de.setEnergy((M = v.data) == null ? void 0 : M.energy),
            de.setCoins((w = v.data) == null ? void 0 : w.coins),
            de.setDaoProfit((E = v.data) == null ? void 0 : E.dao_coins),
            console.debug("sync", v.data)
        }
        )),
        m.current + 500 <= e && (m.current = e,
        Et.endTouch > Et.startTouch ? de.touchTime !== 0 && Et.setTouchTime(0) : Et.startTouch > 0 && Et.endTouch < performance.now() ? Et.setTouchTime(performance.now() - Et.startTouch) : Et.setTouchTime(0),
        Et.touch || Et.setTouchTime(0)),
        Et.touch && x.current && e - h.current >= u && (d(),
        h.current = e)
    }
    , [e, r, s, o, l, n == null ? void 0 : n.HapticFeedback, u, f, d]);
    const x = N.useRef(!1);
    return N.useEffect( () => on( () => Ka.isVibrating, S => {
        S ? x.current = !0 : x.current = !1
    }
    , {
        fireImmediately: !0
    }), []),
    null
}
)
  , t3 = () => (N.useEffect( () => {
    const n = e => e.preventDefault();
    return window.addEventListener("touchmove", n, {
        passive: !1
    }),
    () => window.removeEventListener("touchmove", n)
}
),
console.debug("GameScreen"),
T.jsxs(T.Fragment, {
    children: [T.jsx(jo, {}), T.jsxs("div", {
        className: "absolute left-0 right-0 top-0 bottom-0 z-10 flex flex-col items-stretch justify-between overflow-hidden",
        children: [T.jsx("div", {
            className: "absolute left-0 right-0 top-0 bottom-0 z-0 overflow-hidden",
            children: T.jsx(NB, {})
        }), T.jsx("div", {
            className: "absolute left-0 right-0 top-0 z-10 flex flex-col items-stretch text-white",
            children: T.jsx(d8, {})
        }), T.jsx("div", {
            className: "absolute left-0 right-0 bottom-6 pb-16 z-10 flex flex-col items-stretch text-white",
            children: T.jsx(h8, {})
        })]
    }), T.jsx(UB, {})]
}))
  , FB = () => {
    const [n,e] = N.useState(0)
      , {t} = hn()
      , i = dr()
      , [r,s] = f3()
      , [o,l] = N.useState(!1)
      , [u,f] = N.useState(1);
    N.useLayoutEffect( () => {
        gh.setHideRender(!0)
    }
    , []),
    N.useEffect( () => {
        n === 1 && setTimeout( () => {
            gh.setHideRender(!1)
        }
        , 1500)
    }
    , [n]),
    N.useEffect( () => on( () => Et.touchTime, x => {
        x >= 4e3 ? (l(!0),
        de.setTutorialScreen(!1),
        localStorage.setItem("tutorialScreen", "false"),
        setTimeout( () => {
            i("/")
        }
        , 1e3)) : x !== 0 && f(1 - 1 / (4e3 / x))
    }
    ), []),
    N.useEffect( () => on( () => Et.touch, x => {
        x || f(1)
    }
    ), []),
    N.useEffect( () => {
        n === 2 && gh.setHideRender(!1)
    }
    , [n]);
    const d = r * 1.5
      , h = `${d}px`
      , m = n === 2 ? `-${s * .5 - d / 2}px` : n === 1 ? `${s / 2}px` : `${s}px`
      , g = n === 2 ? "0.7" : "1.5";
    return T.jsxs(T.Fragment, {
        children: [T.jsx("div", {
            className: "absolute top-0 w-full z-[9999999] bg-black opacity-0 " + (n === 2 ? "h-[32vh]" : "h-[50vh]")
        }), T.jsx("div", {
            className: "absolute bottom-0 w-full z-[9999999] bg-black opacity-0 " + (n === 2 ? "h-[32vh]" : "h-[50vh]")
        }), T.jsxs("div", {
            className: "OnboardingScreen h-full w-[100vw] absolute z-[99999999] flex flex-col items-center text-white overflow-hidden duration-1000 transition-all pointer-events-none select-none",
            style: {
                opacity: o ? 0 : u
            },
            children: [T.jsx("div", {
                className: "fingerprint-icon absolute transition-all pointer-events-none select-none",
                style: {
                    width: "5rem",
                    height: "5rem",
                    transitionDuration: "1.5s",
                    top: "50%",
                    left: "0",
                    opacity: n === 2 ? .7 : 0,
                    transform: `translate(-50%, -50%) translateX(${n === 2 ? "50" : "0"}vw)`
                }
            }), T.jsx("div", {
                className: "OnboardingScreenBackground absolute bottom-0 transition-all duration-1000",
                style: {
                    width: h,
                    height: h,
                    transform: `translateY(${m}) scale(${g})`
                }
            }), T.jsxs("div", {
                className: "sora-bold text-4xl mt-4 text-center leading-[2.835rem] pt-2",
                children: [T.jsx("div", {
                    className: "text-4xl mb-2",
                    children: "🚀"
                }), t("Welcome"), T.jsx("br", {}), t("to the future"), T.jsx("br", {})]
            }), T.jsx("div", {
                className: "poppins text-base text-center mt-4 px-6",
                children: t("Earn $DAO by Vibrating together with your friends or bigger communities!")
            }), T.jsxs("div", {
                className: `sora-bold text-xl relative mt-24 w-full px-6 z-10 transition-all duration-1000 transition-transform ${n < 2 ? "translate-x-0" : "translate-x-[200vw]"}`,
                children: [T.jsxs("div", {
                    className: `absolute top-0 left-6 bottom-0 right-6 transition-all duration-1000 ${n === 0 ? "opacity-100" : "opacity-0"}`,
                    children: [T.jsx("div", {
                        className: "bg-[#150150] rounded-2xl w-full py-4 px-4 text-center mb-3 opacity-in",
                        children: t("1. Start Vibing ✨")
                    }), T.jsx("div", {
                        className: "bg-[#150150] rounded-2xl w-full py-4 px-4 text-center mb-3 opacity-in",
                        children: t("2. Earn $DAO")
                    }), T.jsxs("div", {
                        className: "bg-[#150150] rounded-2xl w-full py-4 px-4 text-center mb-3 opacity-in",
                        children: [t("3. Create a DAO"), T.jsx("br", {}), t("and Get Mega Bonuses! 🥳")]
                    })]
                }), T.jsxs("div", {
                    className: `absolute top-0 left-6 bottom-0 right-6 transition-all duration-1000 ${n === 1 ? "opacity-100" : "opacity-0"}`,
                    children: [T.jsx("div", {
                        className: "bg-[#150150] rounded-2xl w-full py-4 px-4 text-center mb-3 opacity-in",
                        children: t("Take your first bonus! 🏆")
                    }), T.jsx("div", {
                        className: "w-full py-4 px-4 text-center mb-3 opacity-in",
                        children: "100,000 $DAO"
                    })]
                })]
            }), T.jsxs("div", {
                className: `sora-bold text-xl mt-24 w-full px-6 z-10 absolute bottom-0 transition-all duration-1000 transition-transform ${n === 2 ? "translate-x-0" : "translate-x-[200vw]"}`,
                children: [T.jsx("div", {
                    className: "w-full py-2 text-center mb-1 opacity-in",
                    children: t("Hold for 5 seconds to start!")
                }), T.jsx("div", {
                    className: "w-full pb-8 text-center  mb-4 text-sm opacity-in",
                    children: t("Don't tap, simply hold 😅")
                })]
            })]
        }), n === 0 && T.jsx("div", {
            className: "mt-auto absolute bottom-0 mb-6 w-full px-6 z-[9999999999] transition-transform ",
            children: T.jsx(_h, {
                onClick: () => e(1),
                children: t("Next!")
            })
        }), n > 0 && T.jsx("div", {
            className: `mt-auto absolute bottom-0 mb-6 w-full px-6 z-[9999999999] transition-transform ${n < 2 ? "translate-x-0" : "translate-x-[200vw]"}`,
            children: T.jsx(_h, {
                onClick: () => e(2),
                children: t("Start vibing!")
            })
        })]
    })
}
  , kB = Pi( () => {
    const {onClickCloseModal: n} = wu()
      , e = N.useCallback( () => {
        de.setGlobalLoading(!0),
        vp.postTasksStartUserTask({
            taskId: sn.openedTask.id
        }),
        sn.fetchTasks().then( () => {
            var r;
            sn.openedTask.link && ((r = t.current) == null || r.click()),
            de.setGlobalLoading(!1),
            n()
        }
        )
    }
    , [n])
      , t = N.useRef(null)
      , {t: i} = hn();
    return sn.openedTask ? T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "absolute left-0 right-0 bottom-0 z-40 rounded-t-xl flex flex-col justify-between items-stretch text-center pt-4 pb-6",
            style: {
                background: "#111111"
            },
            children: [T.jsxs("div", {
                className: "pb-6 px-6",
                children: [T.jsx("div", {
                    className: "text-xl  text-left text-white sora-bold mb-2",
                    children: sn.openedTask.name
                }), T.jsxs("div", {
                    className: "text-lg   text-left pb-6",
                    style: {
                        color: "#C7C7C7"
                    },
                    children: [" ", sn.openedTask.description]
                }), T.jsx("button", {
                    className: "text-white px-4 py-3 w-full rounded-lg sora-bold text-base",
                    style: {
                        background: "#4200FF"
                    },
                    onClick: e,
                    children: i("Start the Task")
                }), T.jsx("a", {
                    className: "hidden",
                    style: {
                        background: "#4200FF"
                    },
                    href: sn.openedTask.link || "",
                    ref: r => t.current = r,
                    children: i("Start the Task")
                })]
            }), T.jsx("div", {
                className: "h-16"
            })]
        })
    }) : null
}
)
  , BB = () => {
    console.log("BeforeLayout");
    const n = dr()
      , {pathname: e} = Wo();
    return N.useEffect( () => on( () => [de.dao_id, de.isDaoAvailable], ([t,i]) => {
        !t && i && e === "/" && n("/modal/newdao")
    }
    , {
        fireImmediately: !0
    }), [n, e]),
    T.jsx(jo, {})
}
  , zB = Pi( () => {
    const {onClickCloseModal: n} = wu()
      , e = N.useCallback( () => {
        de.setGlobalLoading(!0),
        setTimeout( () => {
            vp.postTasksStartUserTask({
                taskId: sn.openedTask.id
            }),
            sn.fetchTasks().then( () => {
                de.setGlobalLoading(!1),
                n()
            }
            )
        }
        , 1e3)
    }
    , [n])
      , {t} = hn();
    return sn.openedTask ? T.jsx(T.Fragment, {
        children: T.jsxs("div", {
            className: "absolute left-0 right-0 bottom-0 z-40 rounded-t-xl flex flex-col justify-between items-stretch text-center pt-4 pb-6",
            style: {
                background: "#111111"
            },
            children: [T.jsxs("div", {
                className: "pb-6 px-6",
                children: [T.jsx("div", {
                    className: "text-xl  text-left text-white sora-bold mb-2",
                    children: sn.openedTask.name
                }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(i => T.jsxs("div", {
                    className: "text-sm text-left text-white sora-bold mb-2",
                    children: ["Day ", i, ":"]
                })), T.jsx("button", {
                    className: "text-white px-4 py-3 w-full rounded-lg sora-bold text-base",
                    style: {
                        background: "#4200FF"
                    },
                    onClick: e,
                    children: t("Start the Task")
                })]
            }), T.jsx("div", {
                className: "h-16"
            })]
        })
    }) : null
}
)
  , iz = () => T.jsx(J5, {
    children: T.jsx(P5, {
        children: T.jsx(fn, {
            path: "/",
            element: T.jsx(BB, {}),
            children: T.jsxs(fn, {
                path: "/",
                element: T.jsx(oT, {}),
                children: [T.jsxs(fn, {
                    path: "/",
                    element: T.jsx(t3, {}),
                    children: [T.jsx(fn, {
                        path: "tutorial",
                        element: T.jsx(FB, {})
                    }), T.jsxs(fn, {
                        path: "modal",
                        element: T.jsx(rg, {}),
                        children: [T.jsx(fn, {
                            path: "newdao",
                            element: T.jsx(o8, {})
                        }), T.jsx(fn, {
                            path: "daosettings",
                            element: T.jsx(j2, {})
                        }), T.jsx(fn, {
                            path: "megafarm",
                            element: T.jsx(s8, {})
                        }), T.jsx(fn, {
                            path: "tutorial",
                            element: T.jsx(r8, {})
                        })]
                    })]
                }), T.jsx(fn, {
                    path: "new",
                    element: T.jsx(t3, {})
                }), T.jsxs(fn, {
                    path: "dao",
                    element: T.jsx(lT, {}),
                    children: [T.jsx(fn, {
                        path: "",
                        element: T.jsx(UT, {}),
                        children: T.jsx(fn, {
                            path: "modal",
                            element: T.jsx(rg, {}),
                            children: T.jsx(fn, {
                                path: "daosettings",
                                element: T.jsx(j2, {})
                            })
                        })
                    }), T.jsx(fn, {
                        path: "invites",
                        element: T.jsx(cT, {})
                    })]
                }), T.jsx(fn, {
                    path: "boosts",
                    element: T.jsx($y, {})
                }), T.jsx(fn, {
                    path: "stats",
                    element: T.jsx($y, {})
                }), T.jsx(fn, {
                    path: "tasks",
                    element: T.jsx(kT, {}),
                    children: T.jsxs(fn, {
                        path: "modal",
                        element: T.jsx(rg, {
                            navigateTo: "/tasks"
                        }),
                        children: [T.jsx(fn, {
                            path: "",
                            element: T.jsx(kB, {})
                        }), T.jsx(fn, {
                            path: "daily",
                            element: T.jsx(zB, {})
                        })]
                    })
                })]
            })
        })
    })
});
export {iz as App};
